---
title: Assembly di riferimento
description: Informazioni sugli assembly di riferimento, un tipo speciale di assembly in .NET che contengono solo la superficie dell'API pubblica della libreria
author: MSDN-WhiteKnight
ms.date: 09/12/2019
ms.technology: dotnet-standard
ms.openlocfilehash: c38f208c2daac914176bbeedbde9e69fd68f55c6
ms.sourcegitcommit: 22be09204266253d45ece46f51cc6f080f2b3fd6
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 11/07/2019
ms.locfileid: "73740487"
---
# <a name="reference-assemblies"></a><span data-ttu-id="9a918-103">Assembly di riferimento</span><span class="sxs-lookup"><span data-stu-id="9a918-103">Reference assemblies</span></span>

<span data-ttu-id="9a918-104">Gli *assembly di riferimento* sono un tipo speciale di assembly che contiene solo la quantità minima di metadati necessaria per rappresentare la superficie dell'API pubblica della libreria.</span><span class="sxs-lookup"><span data-stu-id="9a918-104">*Reference assemblies* are a special type of assembly that contain only the minimum amount of metadata required to represent the library's public API surface.</span></span> <span data-ttu-id="9a918-105">Sono incluse le dichiarazioni per tutti i membri che sono significativi quando si fa riferimento a un assembly negli strumenti di compilazione (da qui il nome), ma si escludono tutte le implementazioni dei membri, nonché le dichiarazioni di membri privati che non hanno alcun impatto osservabile sul contratto API.</span><span class="sxs-lookup"><span data-stu-id="9a918-105">They include declarations for all members that are significant when referencing an assembly in build tools (hence the name), but exclude all member implementations as well as declarations of private members that have no observable impact on their API contract.</span></span> <span data-ttu-id="9a918-106">Al contrario, gli assembly regolari vengono chiamati *assembly di implementazione*.</span><span class="sxs-lookup"><span data-stu-id="9a918-106">In contrast, regular assemblies are called *implementation assemblies*.</span></span>

<span data-ttu-id="9a918-107">Gli assembly di riferimento non possono essere caricati per l'esecuzione, ma possono essere passati come input del compilatore nello stesso modo degli assembly di implementazione.</span><span class="sxs-lookup"><span data-stu-id="9a918-107">Reference assemblies cannot be loaded for execution, but they can be passed as compiler input in the same way as implementation assemblies.</span></span> <span data-ttu-id="9a918-108">Gli assembly di riferimento sono in genere distribuiti con il Software Development Kit (SDK) di una particolare piattaforma o libreria, un componente software speciale installato solo nei computer di sviluppo.</span><span class="sxs-lookup"><span data-stu-id="9a918-108">Reference assemblies are usually distributed with the Software Development Kit (SDK) of a particular platform or library, a special software component installed only on developer machines.</span></span>

<span data-ttu-id="9a918-109">L'uso di un assembly di riferimento consente agli sviluppatori di compilare programmi destinati a una versione specifica della libreria senza avere l'assembly di implementazione completo per tale versione.</span><span class="sxs-lookup"><span data-stu-id="9a918-109">Using a reference assembly enables developers to build programs that target a specific library version without having the full implementation assembly for that version.</span></span> <span data-ttu-id="9a918-110">Si supponga di avere solo la versione più recente di una raccolta nel computer, ma si vuole compilare un programma destinato a un computer con una versione precedente di tale libreria.</span><span class="sxs-lookup"><span data-stu-id="9a918-110">Suppose, you have only the latest version of some library on your machine, but you want to build a program that targets a machine with an earlier version of that library.</span></span> <span data-ttu-id="9a918-111">Se si compila direttamente nell'assembly di implementazione, si potrebbero usare inavvertitamente i membri dell'API che non sono disponibili nella versione precedente e questo errore si verifica solo quando si esegue il test del programma nel computer di destinazione.</span><span class="sxs-lookup"><span data-stu-id="9a918-111">If you compile directly against the implementation assembly, you might inadvertently use API members that aren't available in the earlier version, and you'll only find this mistake when testing the program on the target machine.</span></span> <span data-ttu-id="9a918-112">Se si esegue la compilazione in base all'assembly di riferimento per la versione precedente, si otterrà immediatamente un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="9a918-112">If you compile against the reference assembly for the earlier version, you'll immediately get a compile-time error.</span></span>

<span data-ttu-id="9a918-113">Inoltre, un assembly di riferimento può rappresentare un contratto, ovvero un set di API che non corrisponde all'assembly di implementazione concreto.</span><span class="sxs-lookup"><span data-stu-id="9a918-113">Additionally, a reference assembly can represent a contract, that is, a set of APIs that doesn't correspond to the concrete implementation assembly.</span></span> <span data-ttu-id="9a918-114">Tale assembly di riferimento, denominato *assembly del contratto*, può essere utilizzato per più piattaforme che supportano lo stesso set di API.</span><span class="sxs-lookup"><span data-stu-id="9a918-114">Such reference assembly, called the *contract assembly*, can be used to target multiple platforms that support the same set of APIs.</span></span> <span data-ttu-id="9a918-115">Ad esempio, .NET Standard fornisce l'assembly del contratto, *netstandard. dll*, che rappresenta il set di API comuni condivise tra diverse piattaforme .NET.</span><span class="sxs-lookup"><span data-stu-id="9a918-115">For example, .NET Standard provides the contract assembly, *netstandard.dll*, that represents the set of common APIs shared between different .NET platforms.</span></span> <span data-ttu-id="9a918-116">Le implementazioni di queste API sono contenute in assembly diversi su piattaforme diverse, ad esempio *mscorlib. dll* in .NET Framework o *System. private. CoreLib. dll* in .NET Core.</span><span class="sxs-lookup"><span data-stu-id="9a918-116">The implementations of these APIs are contained in different assemblies on different platforms, such as *mscorlib.dll* on .NET Framework or *System.Private.CoreLib.dll* on .NET Core.</span></span> <span data-ttu-id="9a918-117">Una libreria destinata a .NET Standard può essere eseguita in tutte le piattaforme che supportano .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="9a918-117">A library that targets .NET Standard can run on all platforms that support .NET Standard.</span></span>

## <a name="using-reference-assemblies"></a><span data-ttu-id="9a918-118">Uso di assembly di riferimento</span><span class="sxs-lookup"><span data-stu-id="9a918-118">Using reference assemblies</span></span>

<span data-ttu-id="9a918-119">Per usare determinate API dal progetto, è necessario aggiungere riferimenti ai relativi assembly.</span><span class="sxs-lookup"><span data-stu-id="9a918-119">To use certain APIs from your project, you must add references to their assemblies.</span></span> <span data-ttu-id="9a918-120">È possibile aggiungere riferimenti a assembly di implementazione direttamente o a assembly di riferimento.</span><span class="sxs-lookup"><span data-stu-id="9a918-120">You can add references either to implementation assemblies directly or to reference assemblies.</span></span> <span data-ttu-id="9a918-121">Si consiglia vivamente di utilizzare gli assembly di riferimento ogni volta che sono disponibili, perché in questo modo si garantisce che vengano utilizzati solo i membri API supportati nella versione di destinazione e che siano destinati a essere utilizzati da progettazione API (in altre parole, senza assumere una dipendenza sui dettagli di implementazione.</span><span class="sxs-lookup"><span data-stu-id="9a918-121">We strongly recommend that you use reference assemblies whenever they are available, because doing so ensures that you are using only API members that are supported in the target version and are meant to be used by API designers (in other words, not taking a dependency on implementation details).</span></span>

<span data-ttu-id="9a918-122">Gli assembly di riferimento per le librerie di .NET Framework vengono distribuiti con i targeting pack.</span><span class="sxs-lookup"><span data-stu-id="9a918-122">Reference assemblies for the .NET Framework libraries are distributed with targeting packs.</span></span> <span data-ttu-id="9a918-123">È possibile ottenerli scaricando un programma di installazione autonomo o selezionando un componente nel programma di installazione di Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="9a918-123">You can obtain them by downloading a standalone installer or by selecting a component in Visual Studio installer.</span></span> <span data-ttu-id="9a918-124">Per ulteriori informazioni, vedere [Install the .NET Framework for Developers](../../framework/install/guide-for-developers.md).</span><span class="sxs-lookup"><span data-stu-id="9a918-124">For more information, see [Install the .NET Framework for developers](../../framework/install/guide-for-developers.md).</span></span> <span data-ttu-id="9a918-125">Per .NET Core e .NET Standard, gli assembly di riferimento vengono scaricati automaticamente in base alle necessità (tramite NuGet) e a cui si fa riferimento.</span><span class="sxs-lookup"><span data-stu-id="9a918-125">For .NET Core and .NET Standard, reference assemblies are automatically downloaded as necessary (via NuGet) and referenced.</span></span> <span data-ttu-id="9a918-126">Per .NET Core 3,0 e versioni successive, gli assembly di riferimento per il Framework di base sono inclusi nel pacchetto [Microsoft. NETCore. app. Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) (il pacchetto [Microsoft. NETCore. app](https://www.nuget.org/packages/Microsoft.NETCore.App) viene usato in alternativa per le versioni precedenti a 3,0).</span><span class="sxs-lookup"><span data-stu-id="9a918-126">For .NET Core 3.0 and higher, the reference assemblies for the core framework are in the [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) package (the [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) package is used instead for versions before 3.0).</span></span> <span data-ttu-id="9a918-127">Per altre informazioni, vedere [pacchetti, metapacchetti e Framework](../../core/packages.md) nella Guida di .NET Core.</span><span class="sxs-lookup"><span data-stu-id="9a918-127">For more information, see [Packages, metapackages and frameworks](../../core/packages.md) in the .NET Core Guide.</span></span>

<span data-ttu-id="9a918-128">Quando si aggiungono riferimenti a assembly .NET Framework in Visual Studio usando la finestra di dialogo **Aggiungi riferimento** , si seleziona un assembly dall'elenco e Visual Studio rileva automaticamente gli assembly di riferimento che corrispondono alla versione del Framework di destinazione selezionato nel progetto.</span><span class="sxs-lookup"><span data-stu-id="9a918-128">When you add references to .NET Framework assemblies in Visual Studio using the **Add reference** dialog, you select an assembly from the list, and Visual Studio automatically finds reference assemblies that correspond to the target framework version selected in your project.</span></span> <span data-ttu-id="9a918-129">Lo stesso vale per l'aggiunta di riferimenti direttamente al progetto MSBuild utilizzando l'elemento di progetto di [riferimento](/visualstudio/msbuild/common-msbuild-project-items#reference) : è sufficiente specificare il nome dell'assembly, non il percorso completo del file.</span><span class="sxs-lookup"><span data-stu-id="9a918-129">The same applies to adding references directly into MSBuild project using the  [Reference](/visualstudio/msbuild/common-msbuild-project-items#reference) project item: you only need to specify the assembly name, not the full file path.</span></span> <span data-ttu-id="9a918-130">Quando si aggiungono riferimenti a questi assembly nella riga di comando usando l'opzione del compilatore `-reference`[( C# in](../../csharp/language-reference/compiler-options/reference-compiler-option.md) e in [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) o usando il metodo <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> nell'API Roslyn, è necessario specificare manualmente i file di assembly di riferimento per il versione della piattaforma di destinazione corretta.</span><span class="sxs-lookup"><span data-stu-id="9a918-130">When you add references to these assemblies in the command line by using the `-reference` compiler option ([in C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) and in [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) or by using the <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> method in the Roslyn API, you must manually specify reference assembly files for the correct target platform version.</span></span> <span data-ttu-id="9a918-131">.NET Framework file di assembly di riferimento si trovano negli *assembly di riferimento% ProgramFiles (x86)%\\\\Microsoft\\Framework\\. Directory NETFramework* .</span><span class="sxs-lookup"><span data-stu-id="9a918-131">.NET Framework reference assembly files are located in the *%ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework* directory.</span></span> <span data-ttu-id="9a918-132">Per .NET Core, è possibile forzare l'operazione di pubblicazione per copiare gli assembly di riferimento per la piattaforma di destinazione nella sottodirectory *Publish/refs* della directory di output impostando la proprietà `PreserveCompilationContext` project su `true`.</span><span class="sxs-lookup"><span data-stu-id="9a918-132">For .NET Core, you can force publish operation to copy reference assemblies for your target platform into the *publish/refs* subdirectory of your output directory by setting the `PreserveCompilationContext` project property to `true`.</span></span> <span data-ttu-id="9a918-133">Quindi, è possibile passare questi file di assembly di riferimento al compilatore.</span><span class="sxs-lookup"><span data-stu-id="9a918-133">Then you can pass these reference assembly files to the compiler.</span></span> <span data-ttu-id="9a918-134">L'uso di `DependencyContext` dal pacchetto [Microsoft. Extensions. DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) può aiutare a individuare i percorsi.</span><span class="sxs-lookup"><span data-stu-id="9a918-134">Using `DependencyContext` from [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) package can help locate their paths.</span></span>

<span data-ttu-id="9a918-135">Poiché non contengono alcuna implementazione, non è possibile caricare gli assembly di riferimento per l'esecuzione; il tentativo di eseguire questa operazione comporta un <xref:System.BadImageFormatException?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9a918-135">Because they contain no implementation, reference assemblies cannot be loaded for execution; trying to do so results in a <xref:System.BadImageFormatException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9a918-136">Tuttavia, possono comunque essere caricati nel contesto di sola reflection (usando il metodo <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>), se è necessario esaminarne il contenuto.</span><span class="sxs-lookup"><span data-stu-id="9a918-136">However, they still can be loaded into the reflection-only context (using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>) method, if you need to examine their contents.</span></span>

## <a name="generating-reference-assemblies"></a><span data-ttu-id="9a918-137">Generazione di assembly di riferimento</span><span class="sxs-lookup"><span data-stu-id="9a918-137">Generating reference assemblies</span></span>

<span data-ttu-id="9a918-138">La generazione di assembly di riferimento per le librerie può essere utile quando i consumer della libreria spesso devono compilare i programmi rispetto a diverse versioni della libreria, ovvero quando è necessario implementare una funzionalità simile a .NET Framework Targeting Pack menzionato in precedenza per il proprio progetto.</span><span class="sxs-lookup"><span data-stu-id="9a918-138">Generating reference assemblies for your libraries can be useful when your library consumers often need to build their programs against many different versions of the library (that is, when you need to implement a feature similar to .NET Framework Targeting Packs mentioned above for your own project).</span></span> <span data-ttu-id="9a918-139">La distribuzione degli assembly di implementazione per tutte queste versioni potrebbe risultare poco pratica a causa delle dimensioni elevate.</span><span class="sxs-lookup"><span data-stu-id="9a918-139">Distributing implementation assemblies for all these versions might be impractical due to their large size.</span></span> <span data-ttu-id="9a918-140">Gli assembly di riferimento hanno dimensioni minori, quindi la loro distribuzione come parte dell'SDK della libreria riduce le dimensioni del download e consente di risparmiare spazio su disco.</span><span class="sxs-lookup"><span data-stu-id="9a918-140">Reference assemblies are smaller in size, so distributing them as a part of your library's SDK reduces download size and saves disk space.</span></span>

<span data-ttu-id="9a918-141">Gli IDE e gli strumenti di compilazione possono inoltre sfruttare gli assembly di riferimento per ridurre i tempi di compilazione in caso di soluzioni di grandi dimensioni costituite da più librerie di classi.</span><span class="sxs-lookup"><span data-stu-id="9a918-141">IDEs and build tools also can take advantage of reference assemblies to reduce build times in case of large solutions consisting of multiple class libraries.</span></span> <span data-ttu-id="9a918-142">In genere, negli scenari di compilazione incrementale un progetto viene ricompilato quando uno dei relativi file di input viene modificato, inclusi gli assembly da cui dipende.</span><span class="sxs-lookup"><span data-stu-id="9a918-142">Usually, in incremental build scenarios a project is rebuilt when any of its input files are changed, including the assemblies it depends on.</span></span> <span data-ttu-id="9a918-143">L'assembly di implementazione cambia ogni volta che il programmatore modifica l'implementazione di un membro.</span><span class="sxs-lookup"><span data-stu-id="9a918-143">The implementation assembly changes whenever the programmer changes the implementation of any member.</span></span> <span data-ttu-id="9a918-144">L'assembly di riferimento cambia solo quando è interessata l'API pubblica.</span><span class="sxs-lookup"><span data-stu-id="9a918-144">The reference assembly only changes when its public API is affected.</span></span> <span data-ttu-id="9a918-145">Pertanto, l'utilizzo dell'assembly di riferimento come file di input anziché dell'assembly di implementazione consente di ignorare la compilazione del progetto dipendente in alcuni casi.</span><span class="sxs-lookup"><span data-stu-id="9a918-145">Therefore, using the reference assembly as an input file instead of the implementation assembly allows to skip the build of the dependent project in some cases.</span></span>

<span data-ttu-id="9a918-146">È possibile generare gli assembly di riferimento:</span><span class="sxs-lookup"><span data-stu-id="9a918-146">You can generate reference assemblies:</span></span>

- <span data-ttu-id="9a918-147">In un progetto MSBuild, usando la [proprietà `ProduceReferenceAssembly` Project](/visualstudio/msbuild/common-msbuild-project-properties).</span><span class="sxs-lookup"><span data-stu-id="9a918-147">In an MSBuild project, by using the [`ProduceReferenceAssembly` project property](/visualstudio/msbuild/common-msbuild-project-properties).</span></span>
- <span data-ttu-id="9a918-148">Quando si compila il programma dalla riga di comando, specifica `-refonly`[( C#in ](../../csharp/language-reference/compiler-options/refonly-compiler-option.md), in [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) o `-refout`[( C#in ](../../csharp/language-reference/compiler-options/refout-compiler-option.md), in [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) opzioni del compilatore.</span><span class="sxs-lookup"><span data-stu-id="9a918-148">When compiling program from command line, by specifiying `-refonly` ([in C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md), [in Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) or `-refout` ([in C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md), [in Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) compiler options.</span></span>
- <span data-ttu-id="9a918-149">Quando si usa l'API Roslyn, impostando <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> su `true` e <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> su `false` in un oggetto passato al metodo <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9a918-149">When using the Roslyn API, by setting <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> to `true` and <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> to `false` in an object passed to the <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="9a918-150">Se si desidera distribuire gli assembly di riferimento con i pacchetti NuGet, è necessario includerli nella sottodirectory *ref \\* nella directory del pacchetto anziché nella sottodirectory *lib \\* utilizzata per gli assembly di implementazione.</span><span class="sxs-lookup"><span data-stu-id="9a918-150">If you want to distribute reference assemblies with NuGet packages, you must include them in the *ref\\* subdirectory under the package directory instead of in the *lib\\* subdirectory used for implementation assemblies.</span></span>

## <a name="reference-assemblies-structure"></a><span data-ttu-id="9a918-151">Struttura degli assembly di riferimento</span><span class="sxs-lookup"><span data-stu-id="9a918-151">Reference assemblies structure</span></span>

<span data-ttu-id="9a918-152">Gli assembly di riferimento sono un'espansione del concetto correlato, *assembly di soli metadati*.</span><span class="sxs-lookup"><span data-stu-id="9a918-152">Reference assemblies are an expansion of the related concept, *metadata-only assemblies*.</span></span> <span data-ttu-id="9a918-153">Per gli assembly di soli metadati i corpi di metodo vengono sostituiti con un singolo corpo `throw null`, ma sono inclusi tutti i membri, tranne i tipi anonimi.</span><span class="sxs-lookup"><span data-stu-id="9a918-153">Metadata-only assemblies have their method bodies replaced with a single `throw null` body, but include all members except anonymous types.</span></span> <span data-ttu-id="9a918-154">Il motivo per l'uso di corpi `throw null` (in contrapposizione a nessun corpo) è in modo che PEVerify possa essere eseguito e superato (convalidando quindi la completezza dei metadati).</span><span class="sxs-lookup"><span data-stu-id="9a918-154">The reason for using `throw null` bodies (as opposed to no bodies) is so that PEVerify can run and pass (thus validating the completeness of the metadata).</span></span>

<span data-ttu-id="9a918-155">Gli assembly di riferimento rimuovono ulteriormente i metadati (membri privati) dagli assembly di soli metadati:</span><span class="sxs-lookup"><span data-stu-id="9a918-155">Reference assemblies further remove metadata (private members) from metadata-only assemblies:</span></span>

- <span data-ttu-id="9a918-156">Un assembly di riferimento include solo i riferimenti per i requisiti nella superficie dell'API.</span><span class="sxs-lookup"><span data-stu-id="9a918-156">A reference assembly only has references for what it needs in the API surface.</span></span> <span data-ttu-id="9a918-157">L'assembly reale può includere riferimenti aggiuntivi relativi a implementazioni specifiche.</span><span class="sxs-lookup"><span data-stu-id="9a918-157">The real assembly may have additional references related to specific implementations.</span></span> <span data-ttu-id="9a918-158">Ad esempio, l'assembly di riferimento per `class C { private void M() { dynamic d = 1; ... } }` non fa riferimento ai tipi necessari per `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="9a918-158">For instance, the reference assembly for `class C { private void M() { dynamic d = 1; ... } }` does not reference any types required for `dynamic`.</span></span>
- <span data-ttu-id="9a918-159">I membri-funzione privati (metodi, proprietà ed eventi) vengono rimossi quando la rimozione non impatta in maniera visibile sulla compilazione.</span><span class="sxs-lookup"><span data-stu-id="9a918-159">Private function-members (methods, properties, and events) are removed in cases where their removal doesn't observably impact compilation.</span></span> <span data-ttu-id="9a918-160">Se non sono presenti attributi [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) , vengono rimossi anche i membri della funzione interna.</span><span class="sxs-lookup"><span data-stu-id="9a918-160">If there are no [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) attributes, internal function members are also removed.</span></span>

<span data-ttu-id="9a918-161">I metadati negli assembly di riferimento continuano a mantenere le informazioni sugli elementi seguenti:</span><span class="sxs-lookup"><span data-stu-id="9a918-161">The metadata in reference assemblies continues to retain information about the following:</span></span>

- <span data-ttu-id="9a918-162">Tutti i tipi, inclusi i tipi privati e annidati.</span><span class="sxs-lookup"><span data-stu-id="9a918-162">All types, including private and nested types.</span></span>
- <span data-ttu-id="9a918-163">Tutti gli attributi, anche quelli interni.</span><span class="sxs-lookup"><span data-stu-id="9a918-163">All attributes, even internal ones.</span></span>
- <span data-ttu-id="9a918-164">Tutti i metodi virtuali.</span><span class="sxs-lookup"><span data-stu-id="9a918-164">All virtual methods.</span></span>
- <span data-ttu-id="9a918-165">Implementazioni esplicite dell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="9a918-165">Explicit interface implementations.</span></span>
- <span data-ttu-id="9a918-166">Proprietà ed eventi implementati in modo esplicito perché le relative funzioni di accesso sono virtuali.</span><span class="sxs-lookup"><span data-stu-id="9a918-166">Explicitly implemented properties and events, because their accessors are virtual.</span></span>
- <span data-ttu-id="9a918-167">Tutti i campi di strutture.</span><span class="sxs-lookup"><span data-stu-id="9a918-167">All fields of structures.</span></span>

<span data-ttu-id="9a918-168">Gli assembly di riferimento includono un attributo [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) a livello di assembly.</span><span class="sxs-lookup"><span data-stu-id="9a918-168">Reference assemblies include an assembly-level [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) attribute.</span></span> <span data-ttu-id="9a918-169">Questo attributo può essere specificato nell'origine. il compilatore non dovrà quindi sintetizzarlo.</span><span class="sxs-lookup"><span data-stu-id="9a918-169">This attribute may be specified in source; then the compiler won't need to synthesize it.</span></span> <span data-ttu-id="9a918-170">A causa di questo attributo, i runtime non caricheranno gli assembly di riferimento per l'esecuzione, che tuttavia possono essere caricati in modalità sola reflection.</span><span class="sxs-lookup"><span data-stu-id="9a918-170">Because of this attribute, runtimes will refuse to load reference assemblies for execution (but they can still be loaded in reflection-only mode).</span></span>

<span data-ttu-id="9a918-171">I dettagli della struttura di assembly di riferimento esatti dipendono dalla versione del compilatore.</span><span class="sxs-lookup"><span data-stu-id="9a918-171">Exact reference assembly structure details depend on the compiler version.</span></span> <span data-ttu-id="9a918-172">Le versioni più recenti possono scegliere di escludere un numero maggiore di metadati se è determinato come non influire sulla superficie dell'API pubblica.</span><span class="sxs-lookup"><span data-stu-id="9a918-172">Newer versions may choose to exclude more metadata if it is determined as not affecting the public API surface.</span></span>

> [!NOTE]
> <span data-ttu-id="9a918-173">Le informazioni contenute in questa sezione sono valide solo per gli assembly di riferimento generati dai compilatori Roslyn a partire dalla C# versione 7,1 o Visual Basic versione 15,3.</span><span class="sxs-lookup"><span data-stu-id="9a918-173">Information in this section is applicable only to reference assemblies generated by Roslyn compilers starting from C# version 7.1 or Visual Basic version 15.3.</span></span> <span data-ttu-id="9a918-174">La struttura degli assembly di riferimento per le librerie .NET Framework e .NET Core può differire in alcuni dettagli, perché usano il proprio meccanismo di generazione di assembly di riferimento.</span><span class="sxs-lookup"><span data-stu-id="9a918-174">The structure of reference assemblies for .NET Framework and .NET Core libraries can differ in some details, because they use their own mechanism of generating reference assemblies.</span></span> <span data-ttu-id="9a918-175">Ad esempio, possono avere corpi del metodo completamente vuoti anziché il corpo del `throw null`.</span><span class="sxs-lookup"><span data-stu-id="9a918-175">For example, they might have totally empty method bodies instead of the `throw null` body.</span></span> <span data-ttu-id="9a918-176">Tuttavia, il principio generale si applica comunque: non hanno implementazioni del metodo utilizzabili e contengono metadati solo per i membri che hanno un effetto osservabile da una prospettiva API pubblica.</span><span class="sxs-lookup"><span data-stu-id="9a918-176">But the general principle still applies: they don't have usable method implementations and contain metadata only for members that have an observable impact from a public API perspective.</span></span>

## <a name="see-also"></a><span data-ttu-id="9a918-177">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="9a918-177">See also</span></span>

- [<span data-ttu-id="9a918-178">Assembly in .NET</span><span class="sxs-lookup"><span data-stu-id="9a918-178">Assemblies in .NET</span></span>](index.md)
- [<span data-ttu-id="9a918-179">Panoramica sull'impostazione dei framework di destinazione</span><span class="sxs-lookup"><span data-stu-id="9a918-179">Framework targeting overview</span></span>](/visualstudio/ide/visual-studio-multi-targeting-overview)
- [<span data-ttu-id="9a918-180">Procedura: aggiungere o rimuovere riferimenti tramite Gestione riferimenti</span><span class="sxs-lookup"><span data-stu-id="9a918-180">How to: Add or remove references by using the Reference Manager</span></span>](/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager)
