---
title: Gestione delle sessioni WIF
ms.date: 03/30/2017
ms.assetid: 98bce126-18a9-401b-b20d-67ee462a5f8a
author: BrucePerlerMS
ms.openlocfilehash: 141eda509530cab1120d519c3cbc94693ef1cc51
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/22/2019
ms.locfileid: "69946229"
---
# <a name="wif-session-management"></a>Gestione delle sessioni WIF
Quando un client tenta di accedere per la prima volta a una risorsa protetta ospitata da una relying party, deve prima di tutto autenticarsi in un servizio token di sicurezza considerato attendibile dalla relying party. Il servizio token di sicurezza rilascia quindi un token di sicurezza al client. Il client presenta questo token alla relying party, che quindi concede al client l'accesso alla risorsa protetta. Non si vuole, tuttavia, che il client debba eseguire una nuova autenticazione nel servizio token di sicurezza per ogni richiesta, in particolare perché potrebbe anche non trovarsi nello stesso computer o nello stesso dominio della relying party. Windows Identity Foundation (WIF) fa invece in modo che il client e la relying party stabiliscano una sessione nella quale il client usa un token di sicurezza della sessione per autenticarsi nella relying party per tutte le richieste successive alla prima. La relying party può usare questo token di sicurezza della sessione, archiviato all'interno di un cookie, per ricostruire l'oggetto <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType> del client.  
  
 Il servizio token di sicurezza definisce il tipo di autenticazione che il client deve fornire. Il client può tuttavia avere più credenziali con le quali può autenticarsi nel servizio token di sicurezza. Può ad esempio avere un token di Windows Live, un nome utente e una password, un certificato e una smartkey. In tal caso, il servizio token di sicurezza concede diverse identità al client, ognuna delle quali corrisponde a una delle credenziali presentate dal client. La relying party può usare una o più di queste identità quando decide quale livello di accesso concedere al client.  
  
 <xref:System.IdentityModel.Tokens.SessionSecurityToken?displayProperty=nameWithType> viene usato per ricostruire l'oggetto <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType> del client, contenente tutte le identità del client in <xref:System.Security.Claims.ClaimsPrincipal.Identities%2A>. Ogni oggetto <xref:System.Security.Claims.ClaimsIdentity?displayProperty=nameWithType> nella raccolta contiene i token di bootstrap associati a tale identità.  
  
 Se viene rilasciato un nuovo token di sessione con l'ID sessione del token di sessione originale, <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler?displayProperty=nameWithType> non aggiorna il token di sessione nella cache dei token. È consigliabile creare sempre un'istanza di un token di sessione con un ID sessione univoco.  
  
> [!NOTE]
> Session.SecurityTokenHandler.ReadToken genera un'eccezione <xref:System.Xml.XmlException> se riceve input non valido, ad esempio se il cookie contenente il token di sessione è danneggiato. È consigliabile intercettare questa eccezione e fornire un comportamento specifico dell'applicazione.  
  
 Se una pagina Web protetta contiene numerose risorse (ad esempio, immagini di piccole dimensioni) che si trovano anche nel dominio protetto, il client deve eseguire di nuovo l'autenticazione nella relying party per scaricare ognuna di tali risorse. Se si usa un token di autenticazione della sessione non è necessario eseguire l'autenticazione nel servizio token di sicurezza per ogni richiesta, ma vengono comunque inviati numerosi cookie. È possibile configurare la pagina Web in modo che i dati e le risorse importanti vengano archiviati nel dominio protetto, mentre gli elementi secondari vengono archiviati in un dominio non protetto e ne viene inserito un collegamento dalla pagina Web principale. Impostare inoltre il percorso dei cookie in modo da fare riferimento solo al dominio protetto.  
  
 Per usare la modalità di riferimento, Microsoft consiglia di fornire un gestore per l'evento <xref:System.IdentityModel.Services.WSFederationAuthenticationModule.SessionSecurityTokenCreated> nel file **global.asax.cs** e di impostare la proprietà **IsReferenceMode** nel token passato nella proprietà <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A>. Questi aggiornamenti garantiscono che il token di sessione funzioni in modalità di riferimento per ogni richiesta è ciò è preferibile rispetto a impostare semplicemente la proprietà <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A> nel modulo di autenticazione della sessione.  
  
## <a name="extensibility"></a>Estendibilità  
 È possibile estendere il meccanismo di gestione della sessione. In tal modo è possibile migliorare le prestazioni. È possibile, ad esempio, creare un gestore di cookie personalizzato che trasforma o ottimizza il token di sicurezza della sessione tra lo stato in memoria e ciò che viene inserito nel cookie. A tale scopo, è possibile configurare la proprietà <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A?displayProperty=nameWithType> di <xref:System.IdentityModel.Services.SessionAuthenticationModule?displayProperty=nameWithType> per usare un gestore di cookie personalizzato che deriva da <xref:System.IdentityModel.Services.CookieHandler?displayProperty=nameWithType>. <xref:System.IdentityModel.Services.ChunkedCookieHandler?displayProperty=nameWithType> è il gestore di cookie predefinito, perché i cookie superano la dimensione consentita per HTTP (Hypertext Transfer Protocol). Se si usa invece un gestore di cookie personalizzato, è necessario implementare la suddivisione in blocchi.  
  
 Per ulteriori informazioni, vedere l'esempio [ClaimsAwareWebFarm](https://go.microsoft.com/fwlink/?LinkID=248408) . Questo esempio illustra un cache di sessione compatibile con la farm (in contrapposizione a tokenreplycache) grazie a cui è possibile usare le sessioni tramite riferimento invece di scambiare cookie di grandi dimensioni. L'esempio illustra anche un modo più semplice per proteggere i cookie in una farm. La cache di sessione è basata su WCF. Per quanto riguarda la protezione della sessione, l'esempio illustra una nuova funzionalità di WIF 4.5 relativa a una trasformazione di cookie basata su MachineKey, che è possibile attivare semplicemente incollando il frammento di codice appropriato in web.config. L'esempio non è inserito in un ambiente farm, ma illustra cosa occorre per rendere l'app compatibile con la farm.
