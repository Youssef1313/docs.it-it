---
title: Elevazione dei privilegi
ms.date: 03/30/2017
helpviewer_keywords:
- elevation of privilege [WCF]
- security [WCF], elevation of privilege
ms.assetid: 146e1c66-2a76-4ed3-98a5-fd77851a06d9
ms.openlocfilehash: eae3c2a72e686774ee510dfc3ec9db04df7db630
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 08/22/2019
ms.locfileid: "69966180"
---
# <a name="elevation-of-privilege"></a><span data-ttu-id="00dd5-102">Elevazione dei privilegi</span><span class="sxs-lookup"><span data-stu-id="00dd5-102">Elevation of Privilege</span></span>
<span data-ttu-id="00dd5-103">L' *elevazione dei privilegi* risulta da concedere a un utente malintenzionato autorizzazioni di autorizzazione oltre a quelle inizialmente concesse.</span><span class="sxs-lookup"><span data-stu-id="00dd5-103">*Elevation of privilege* results from giving an attacker authorization permissions beyond those initially granted.</span></span> <span data-ttu-id="00dd5-104">L'autore di un attacco con, ad esempio, un set di privilegi di autorizzazioni "di sola lettura" eleva il set per includere "lettura e scrittura".</span><span class="sxs-lookup"><span data-stu-id="00dd5-104">For example, an attacker with a privilege set of "read only" permissions somehow elevates the set to include "read and write."</span></span>  
  
## <a name="trusted-sts-should-sign-saml-token-claims"></a><span data-ttu-id="00dd5-105">Un servizio token di sicurezza affidabile deve firmare le attestazioni del token SAML</span><span class="sxs-lookup"><span data-stu-id="00dd5-105">Trusted STS Should Sign SAML Token Claims</span></span>  
 <span data-ttu-id="00dd5-106">Un token SAML (Security Assertions Markup Language) è un token XML generico che è il tipo predefinito per i token emessi.</span><span class="sxs-lookup"><span data-stu-id="00dd5-106">A Security Assertions Markup Language (SAML) token is a generic XML token that is the default type for issued tokens.</span></span> <span data-ttu-id="00dd5-107">Un token SAML può essere costruito da un servizio token di sicurezza (STS, Security Token Service) ritenuto affidabile dal servizio Web finale in uno scambio tipico.</span><span class="sxs-lookup"><span data-stu-id="00dd5-107">A SAML token can be constructed by a Security Token Service (STS) that the end Web service trusts in a typical exchange.</span></span> <span data-ttu-id="00dd5-108">Nelle istruzioni, i token SAML contengono attestazioni.</span><span class="sxs-lookup"><span data-stu-id="00dd5-108">SAML tokens contain claims in statements.</span></span> <span data-ttu-id="00dd5-109">L'autore di un attacco può copiare le attestazioni da un token valido, creare un nuovo token SAML e firmarlo con un emittente diverso.</span><span class="sxs-lookup"><span data-stu-id="00dd5-109">An attacker may copy the claims from a valid token, create a new SAML token, and sign it with a different issuer.</span></span> <span data-ttu-id="00dd5-110">Lo scopo è quello di determinare se il server sta convalidando gli emittenti e, in caso negativo, utilizzare la debolezza per costruire token SAML che consentano privilegi oltre quelli previsti da un servizio token di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="00dd5-110">The intent is to determine whether the server is validating issuers and, if not, utilize the weakness to construct SAML tokens that allow privileges beyond those intended by a trusted STS.</span></span>  
  
 <span data-ttu-id="00dd5-111">La classe <xref:System.IdentityModel.Tokens.SamlAssertion> verifica la firma digitale contenuta in un token SAML e l'oggetto <xref:System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator> predefinito richiede che i token SAML siano firmati da un certificato X.509 che sia valido quando l'oggetti <xref:System.ServiceModel.Security.IssuedTokenServiceCredential.CertificateValidationMode%2A> della classe <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> è impostata su <xref:System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust>.</span><span class="sxs-lookup"><span data-stu-id="00dd5-111">The <xref:System.IdentityModel.Tokens.SamlAssertion> class verifies the digital signature contained within a SAML token, and the default <xref:System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator> requires that SAML tokens be signed by an X.509 certificate that is valid when the <xref:System.ServiceModel.Security.IssuedTokenServiceCredential.CertificateValidationMode%2A> of the <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> class is set to <xref:System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust>.</span></span> <span data-ttu-id="00dd5-112">La sola modalità `ChainTrust` non è sufficiente per stabilire se l'emittente del token SAML è affidabile.</span><span class="sxs-lookup"><span data-stu-id="00dd5-112">`ChainTrust` mode alone is insufficient to determine whether the issuer of the SAML token is trusted.</span></span> <span data-ttu-id="00dd5-113">I servizi che richiedono un modello di affidabilità più granulare possono utilizzare i criteri di autorizzazione e di imposizione per controllare l'emittente dei set di attestazioni prodotti dall'autenticazione del token emesso oppure utilizzare le impostazioni di convalida X.509 in <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> per limitare il set di certificati di firma consentiti.</span><span class="sxs-lookup"><span data-stu-id="00dd5-113">Services that require a more granular trust model can either use authorization and enforcement policies to check the issuer of the claim sets produced by issued token authentication or use the X.509 validation settings on <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> to restrict the set of allowed signing certificates.</span></span> <span data-ttu-id="00dd5-114">Per ulteriori informazioni, vedere [gestione di attestazioni e autorizzazioni con il modello di identità e la](../../../../docs/framework/wcf/feature-details/managing-claims-and-authorization-with-the-identity-model.md) [Federazione e i token emessi](../../../../docs/framework/wcf/feature-details/federation-and-issued-tokens.md).</span><span class="sxs-lookup"><span data-stu-id="00dd5-114">For more information, see [Managing Claims and Authorization with the Identity Model](../../../../docs/framework/wcf/feature-details/managing-claims-and-authorization-with-the-identity-model.md) and [Federation and Issued Tokens](../../../../docs/framework/wcf/feature-details/federation-and-issued-tokens.md).</span></span>  
  
## <a name="switching-identity-without-a-security-context"></a><span data-ttu-id="00dd5-115">Cambio di identità senza un contesto di sicurezza</span><span class="sxs-lookup"><span data-stu-id="00dd5-115">Switching Identity Without a Security Context</span></span>  
 <span data-ttu-id="00dd5-116">Le condizioni seguenti si applicano solo a WinFX.</span><span class="sxs-lookup"><span data-stu-id="00dd5-116">The following applies only to WinFX.</span></span>  
  
 <span data-ttu-id="00dd5-117">Quando viene stabilita una connessione tra un client e un server, l'identità del client non cambia, tranne che in una situazione: dopo l'apertura del client WCF, se vengono soddisfatte tutte le condizioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="00dd5-117">When a connection is established between a client and server, the identity of the client does not change, except in one situation: after the WCF client is opened, if all of the following conditions are true:</span></span>  
  
- <span data-ttu-id="00dd5-118">Le procedure per stabilire un contesto di sicurezza (utilizzando una sessione di sicurezza del trasporto o una sessione di sicurezza del messaggio<xref:System.ServiceModel.NonDualMessageSecurityOverHttp.EstablishSecurityContext%2A> ) sono disattivate (la proprietà è impostata su `false` in caso di sicurezza del messaggio o il trasporto non è in grado di stabilire la sicurezza le sessioni vengono utilizzate nei casi di sicurezza del trasporto.</span><span class="sxs-lookup"><span data-stu-id="00dd5-118">The procedures to establish a security context (using a transport security session or message security session) is switched off (<xref:System.ServiceModel.NonDualMessageSecurityOverHttp.EstablishSecurityContext%2A> property is set to `false` in case of message security or transport not capable of establishing security sessions is used in transport security case.</span></span> <span data-ttu-id="00dd5-119">HTTPS è un esempio di questo tipo di trasporto.</span><span class="sxs-lookup"><span data-stu-id="00dd5-119">HTTPS is one example of such transport).</span></span>  
  
- <span data-ttu-id="00dd5-120">Viene utilizzata l'autenticazione di Windows.</span><span class="sxs-lookup"><span data-stu-id="00dd5-120">You are using Windows authentication.</span></span>  
  
- <span data-ttu-id="00dd5-121">La credenziale non è impostata in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="00dd5-121">You do not explicitly set the credential.</span></span>  
  
- <span data-ttu-id="00dd5-122">Il servizio viene chiamato nel contesto di sicurezza rappresentato.</span><span class="sxs-lookup"><span data-stu-id="00dd5-122">You are calling the service under the impersonated security context.</span></span>  
  
 <span data-ttu-id="00dd5-123">Se queste condizioni sono vere, l'identità utilizzata per autenticare il client al servizio potrebbe cambiare (potrebbe non essere l'identità rappresentata, ma l'identità del processo) dopo l'apertura del client WCF.</span><span class="sxs-lookup"><span data-stu-id="00dd5-123">If these conditions are true, the identity used to authenticate the client to the service might change (it might not be the impersonated identity but the process identity instead) after the WCF client is opened.</span></span> <span data-ttu-id="00dd5-124">Ciò accade perché la credenziale di Windows utilizzata per autenticare il client al servizio viene trasmessa con ogni messaggio e la credenziale utilizzata per l'autenticazione viene ottenuta dall'identità di Windows del thread corrente.</span><span class="sxs-lookup"><span data-stu-id="00dd5-124">This occurs because the Windows credential used to authenticate the client to the service is transmitted with every message, and the credential used for authentication is obtained from the current thread's Windows identity.</span></span> <span data-ttu-id="00dd5-125">Se l'identità di Windows del thread corrente cambia (ad esempio, rappresentando un chiamante diverso), potrebbe cambiare anche la credenziale allegata al messaggio e utilizzata per autenticare il client al servizio.</span><span class="sxs-lookup"><span data-stu-id="00dd5-125">If the Windows identity of the current thread changes (for example, by impersonating a different caller), the credential that is attached to the message and used to authenticate the client to the service might also change.</span></span>  
  
 <span data-ttu-id="00dd5-126">Se si desidera ottenere un comportamento deterministico quando si utilizza l'autenticazione di Windows assieme alla rappresentazione, è necessario impostare in modo esplicito la credenziale di Windows oppure stabilire un contesto di sicurezza con il servizio.</span><span class="sxs-lookup"><span data-stu-id="00dd5-126">If you want to have deterministic behavior when using Windows authentication together with impersonation you need to explicitly set the Windows credential or you need to establish a security context with the service.</span></span> <span data-ttu-id="00dd5-127">A tale scopo, utilizzare una sessione di sicurezza del messaggio o una sessione di sicurezza del trasporto.</span><span class="sxs-lookup"><span data-stu-id="00dd5-127">To do this, use a message security session or a transport security session.</span></span> <span data-ttu-id="00dd5-128">Il trasporto net.tcp, ad esempio, può fornire una sessione di sicurezza del trasporto.</span><span class="sxs-lookup"><span data-stu-id="00dd5-128">For example, the net.tcp transport can provide a transport security session.</span></span> <span data-ttu-id="00dd5-129">Quando si chiama il servizio , è inoltre necessario utilizzare solo una versione sincrona delle operazioni client.</span><span class="sxs-lookup"><span data-stu-id="00dd5-129">Additionally, you must use only a synchronous version of client operations when calling the service.</span></span> <span data-ttu-id="00dd5-130">Se si stabilisce un contesto di sicurezza del messaggio, non mantenere aperta la connessione al servizio oltre il periodo di rinnovo della sessione configurato, perché l'identità può cambiare anche durante il processo di rinnovo della sessione.</span><span class="sxs-lookup"><span data-stu-id="00dd5-130">If you establish a message security context, you should not keep the connection to the service open longer than the configured session renewal period, because the identity can also change during the session renewal process.</span></span>  
  
### <a name="credentials-capture"></a><span data-ttu-id="00dd5-131">Acquisizione delle credenziali</span><span class="sxs-lookup"><span data-stu-id="00dd5-131">Credentials Capture</span></span>  
 <span data-ttu-id="00dd5-132">Quanto segue si applica a [!INCLUDE[netfx35_long](../../../../includes/netfx35-long-md.md)] e versioni successive.</span><span class="sxs-lookup"><span data-stu-id="00dd5-132">The following applies to [!INCLUDE[netfx35_long](../../../../includes/netfx35-long-md.md)], and subsequent versions.</span></span>  
  
 <span data-ttu-id="00dd5-133">Le credenziali utilizzate dal client o dal servizio sono basate sul thread del contesto corrente.</span><span class="sxs-lookup"><span data-stu-id="00dd5-133">Credentials used by the client or the service are based on the current context thread.</span></span> <span data-ttu-id="00dd5-134">Le credenziali vengono ottenute quando si chiama il metodo `Open` (o `BeginOpen`, per le chiamate asincrone) del client o del servizio.</span><span class="sxs-lookup"><span data-stu-id="00dd5-134">The credentials are obtained when the `Open` method (or `BeginOpen`, for asynchronous calls) of the client or service is called.</span></span> <span data-ttu-id="00dd5-135">Per entrambe le classi <xref:System.ServiceModel.ServiceHost> e <xref:System.ServiceModel.ClientBase%601>, i metodi `Open` e `BeginOpen` ereditano dai metodi <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> e <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> della classe <xref:System.ServiceModel.Channels.CommunicationObject>.</span><span class="sxs-lookup"><span data-stu-id="00dd5-135">For both the <xref:System.ServiceModel.ServiceHost> and <xref:System.ServiceModel.ClientBase%601> classes, the `Open` and `BeginOpen` methods inherit from the <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> and <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> methods of the <xref:System.ServiceModel.Channels.CommunicationObject> class.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="00dd5-136">Quando si utilizza il metodo `BeginOpen`, non è possibile garantire che le credenziali acquisite siano quelle del processo che chiama il metodo.</span><span class="sxs-lookup"><span data-stu-id="00dd5-136">When using the `BeginOpen` method, the credentials captured cannot be guaranteed to be the credentials of the process that calls the method.</span></span>  
  
## <a name="token-caches-allow-replay-using-obsolete-data"></a><span data-ttu-id="00dd5-137">I token memorizzati nella cache consentono la riproduzione utilizzando dati obsoleti</span><span class="sxs-lookup"><span data-stu-id="00dd5-137">Token Caches Allow Replay Using Obsolete Data</span></span>  
 <span data-ttu-id="00dd5-138">WCF utilizza la funzione autorità di sicurezza locale ( `LogonUser` LSA) per autenticare gli utenti in base al nome utente e alla password.</span><span class="sxs-lookup"><span data-stu-id="00dd5-138">WCF uses the local security authority (LSA) `LogonUser` function to authenticate users by user name and password.</span></span> <span data-ttu-id="00dd5-139">Poiché la funzione Logon è un'operazione costosa, WCF consente di memorizzare nella cache i token che rappresentano gli utenti autenticati per migliorare le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="00dd5-139">Because the logon function is a costly operation, WCF allows you to cache tokens that represent authenticated users to increase performance.</span></span> <span data-ttu-id="00dd5-140">Il meccanismo di memorizzazione nella cache salva i risultati ottenuti da `LogonUser` per utilizzi successivi.</span><span class="sxs-lookup"><span data-stu-id="00dd5-140">The caching mechanism saves the results from `LogonUser` for subsequent uses.</span></span> <span data-ttu-id="00dd5-141">Questo meccanismo è disabilitato per impostazione predefinita. per abilitarla, impostare la <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CacheLogonTokens%2A> proprietà su `true`o `cacheLogonTokens` [ \<](../../../../docs/framework/configure-apps/file-schema/wcf/usernameauthentication.md)usare l'attributo della > UserNameAuthentication.</span><span class="sxs-lookup"><span data-stu-id="00dd5-141">This mechanism is disabled by default; to enable it, set the <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CacheLogonTokens%2A> property to `true`, or use the `cacheLogonTokens` attribute of the [\<userNameAuthentication>](../../../../docs/framework/configure-apps/file-schema/wcf/usernameauthentication.md).</span></span>  
  
 <span data-ttu-id="00dd5-142">È possibile impostare la durata (TTL) per i token memorizzati nella cache, impostando la proprietà <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CachedLogonTokenLifetime%2A> su un <xref:System.TimeSpan>, oppure utilizzare l'attributo `cachedLogonTokenLifetime` dell'elemento `userNameAuthentication`. L'impostazione predefinita è 15 minuti.</span><span class="sxs-lookup"><span data-stu-id="00dd5-142">You can set a Time to Live (TTL) for the cached tokens by setting the <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CachedLogonTokenLifetime%2A> property to a <xref:System.TimeSpan>, or use the `cachedLogonTokenLifetime` attribute of the `userNameAuthentication` element; the default is 15 minutes.</span></span> <span data-ttu-id="00dd5-143">Si noti che quando un token è memorizzato nella cache, può essere utilizzato da qualsiasi client che presenti lo stesso nome utente e la stessa password, anche se l'account utente viene eliminato da Windows o se la sua password è stata modificata.</span><span class="sxs-lookup"><span data-stu-id="00dd5-143">Note that while a token is cached, any client that presents the same user name and password can use the token, even if the user account is deleted from Windows or if its password has been changed.</span></span> <span data-ttu-id="00dd5-144">Fino alla scadenza della durata (TTL) e il token viene rimosso dalla cache, WCF consente all'utente (probabilmente dannoso) di eseguire l'autenticazione.</span><span class="sxs-lookup"><span data-stu-id="00dd5-144">Until the TTL expires and the token is removed from the cache, WCF allows the (possibly malicious) user to authenticate.</span></span>  
  
 <span data-ttu-id="00dd5-145">Per attenuare questo problema: Ridurre la finestra di attacco impostando `cachedLogonTokenLifetime` il valore sull'intervallo di tempo più breve necessario per gli utenti.</span><span class="sxs-lookup"><span data-stu-id="00dd5-145">To mitigate this: Decrease the attack window by setting the `cachedLogonTokenLifetime` value to the shortest time span your users need.</span></span>  
  
## <a name="issued-token-authorization-expiration-reset-to-large-value"></a><span data-ttu-id="00dd5-146">Autorizzazione token rilasciata: La scadenza è stata reimpostata su un valore elevato</span><span class="sxs-lookup"><span data-stu-id="00dd5-146">Issued Token Authorization: Expiration Reset to Large Value</span></span>  
 <span data-ttu-id="00dd5-147">In certe condizioni, la proprietà <xref:System.IdentityModel.Policy.AuthorizationContext.ExpirationTime%2A> di <xref:System.IdentityModel.Policy.AuthorizationContext> può essere impostata su un valore inaspettatamente superiore (il valore del campo <xref:System.DateTime.MaxValue> meno un giorno, o 20 dicembre 9999).</span><span class="sxs-lookup"><span data-stu-id="00dd5-147">Under certain conditions, the <xref:System.IdentityModel.Policy.AuthorizationContext.ExpirationTime%2A> property of the <xref:System.IdentityModel.Policy.AuthorizationContext> may be set to an unexpectedly larger value (the <xref:System.DateTime.MaxValue> field value minus one day, or December 20, 9999).</span></span>  
  
 <span data-ttu-id="00dd5-148">Ciò si verifica quando si utilizza <xref:System.ServiceModel.WSFederationHttpBinding> e una qualsiasi delle associazioni fornite dal sistema che ha un token emesso come tipo di credenziale client.</span><span class="sxs-lookup"><span data-stu-id="00dd5-148">This occurs when using the <xref:System.ServiceModel.WSFederationHttpBinding> and any of the system-provided bindings that have an issued token as the client credential type.</span></span>  
  
 <span data-ttu-id="00dd5-149">Lo stesso accade anche quando si creano associazioni personalizzate utilizzando uno dei metodi seguenti:</span><span class="sxs-lookup"><span data-stu-id="00dd5-149">This also occurs when you create custom bindings by using one of the following methods:</span></span>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForCertificateBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForSslBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenOverTransportBindingElement%2A>  
  
 <span data-ttu-id="00dd5-150">Per limitare questo problema, i criteri di autorizzazione devono controllare l'azione e la data di scadenza dei singoli criteri di autorizzazione.</span><span class="sxs-lookup"><span data-stu-id="00dd5-150">To mitigate this, the authorization policy must check the action and the expiration time of each authorization policy.</span></span>  
  
## <a name="the-service-uses-a-different-certificate-than-the-client-intended"></a><span data-ttu-id="00dd5-151">Il servizio utilizza un certificato diverso da quello previsto dal client</span><span class="sxs-lookup"><span data-stu-id="00dd5-151">The Service Uses a Different Certificate Than the Client Intended</span></span>  
 <span data-ttu-id="00dd5-152">In certe condizioni, un client può firmare digitalmente un messaggio con un certificato X.509 e far sì che il servizio recuperi un certificato diverso da quello previsto.</span><span class="sxs-lookup"><span data-stu-id="00dd5-152">Under certain conditions, a client can digitally sign a message with an X.509 certificate and have the service retrieve a different certificate than the intended one.</span></span>  
  
 <span data-ttu-id="00dd5-153">Ciò può verificarsi nelle circostanze seguenti:</span><span class="sxs-lookup"><span data-stu-id="00dd5-153">This can occur under the following circumstances:</span></span>  
  
- <span data-ttu-id="00dd5-154">Il client firma digitalmente un messaggio utilizzando un certificato X.509 e non allega il certificato X.509 al messaggio, ma fa semplicemente riferimento al certificato utilizzando il suo identificatore chiave del soggetto.</span><span class="sxs-lookup"><span data-stu-id="00dd5-154">The client digitally signs a message using an X.509 certificate and does not attach the X.509 certificate to the message, but rather just references the certificate using its subject key identifier.</span></span>  
  
- <span data-ttu-id="00dd5-155">Il computer del servizio contiene due o più certificati con la stessa chiave pubblica, ma tali certificati contengono informazioni diverse.</span><span class="sxs-lookup"><span data-stu-id="00dd5-155">The service's computer contains two or more certificates with the same public key, but they contain different information.</span></span>  
  
- <span data-ttu-id="00dd5-156">Il servizio recupera un certificato che corrisponde all'identificatore chiave del soggetto, ma non è quello che il client doveva utilizzare.</span><span class="sxs-lookup"><span data-stu-id="00dd5-156">The service retrieves a certificate that matches the subject key identifier, but it is not the one the client intended to use.</span></span> <span data-ttu-id="00dd5-157">Quando WCF riceve il messaggio e verifica la firma, WCF esegue il mapping delle informazioni del certificato X. 509 non intenzionale a un set di attestazioni che sono diverse e potenzialmente elevate rispetto a quelle previste dal client.</span><span class="sxs-lookup"><span data-stu-id="00dd5-157">When WCF receives the message and verifies the signature, WCF maps the information in the unintended X.509 certificate to a set of claims that are different and potentially elevated from what the client expected.</span></span>  
  
 <span data-ttu-id="00dd5-158">Per limitare questo problema, fare riferimento al certificato X.509 in un altro modo, ad esempio utilizzando <xref:System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType.IssuerSerial>.</span><span class="sxs-lookup"><span data-stu-id="00dd5-158">To mitigate this, reference the X.509 certificate another way, such as using <xref:System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType.IssuerSerial>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="00dd5-159">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="00dd5-159">See also</span></span>

- [<span data-ttu-id="00dd5-160">Considerazioni sulla sicurezza</span><span class="sxs-lookup"><span data-stu-id="00dd5-160">Security Considerations</span></span>](../../../../docs/framework/wcf/feature-details/security-considerations-in-wcf.md)
- [<span data-ttu-id="00dd5-161">Divulgazione di informazioni</span><span class="sxs-lookup"><span data-stu-id="00dd5-161">Information Disclosure</span></span>](../../../../docs/framework/wcf/feature-details/information-disclosure.md)
- [<span data-ttu-id="00dd5-162">Negazione del servizio</span><span class="sxs-lookup"><span data-stu-id="00dd5-162">Denial of Service</span></span>](../../../../docs/framework/wcf/feature-details/denial-of-service.md)
- [<span data-ttu-id="00dd5-163">Attacchi di tipo replay</span><span class="sxs-lookup"><span data-stu-id="00dd5-163">Replay Attacks</span></span>](../../../../docs/framework/wcf/feature-details/replay-attacks.md)
- [<span data-ttu-id="00dd5-164">Manomissioni</span><span class="sxs-lookup"><span data-stu-id="00dd5-164">Tampering</span></span>](../../../../docs/framework/wcf/feature-details/tampering.md)
- [<span data-ttu-id="00dd5-165">Scenari non supportati</span><span class="sxs-lookup"><span data-stu-id="00dd5-165">Unsupported Scenarios</span></span>](../../../../docs/framework/wcf/feature-details/unsupported-scenarios.md)
