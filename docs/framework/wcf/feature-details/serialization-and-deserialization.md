---
title: Serializzazione e deserializzazione
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 3d71814c-bda7-424b-85b7-15084ff9377a
ms.openlocfilehash: c66ca9356d1db157688349dfeea4270001513e0b
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 08/22/2019
ms.locfileid: "69949212"
---
# <a name="serialization-and-deserialization"></a><span data-ttu-id="65f14-102">Serializzazione e deserializzazione</span><span class="sxs-lookup"><span data-stu-id="65f14-102">Serialization and Deserialization</span></span>
<span data-ttu-id="65f14-103">Windows Communication Foundation (WCF) include un nuovo motore di serializzazione <xref:System.Runtime.Serialization.DataContractSerializer>, ovvero.</span><span class="sxs-lookup"><span data-stu-id="65f14-103">Windows Communication Foundation (WCF) includes a new serialization engine, the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="65f14-104">Il <xref:System.Runtime.Serialization.DataContractSerializer> viene convertito tra .NET Framework oggetti e XML in entrambe le direzioni.</span><span class="sxs-lookup"><span data-stu-id="65f14-104">The <xref:System.Runtime.Serialization.DataContractSerializer> translates between .NET Framework objects and XML, in both directions.</span></span> <span data-ttu-id="65f14-105">In questo argomento viene illustrato il funzionamento del serializzatore.</span><span class="sxs-lookup"><span data-stu-id="65f14-105">This topic explains how the serializer works.</span></span>  
  
 <span data-ttu-id="65f14-106">Quando si serializzano oggetti .NET Framework, il serializzatore riconosce una varietà di modelli di programmazione della serializzazione, incluso il nuovo modello di *contratto dati* .</span><span class="sxs-lookup"><span data-stu-id="65f14-106">When serializing .NET Framework objects, the serializer understands a variety of serialization programming models, including the new *data contract* model.</span></span> <span data-ttu-id="65f14-107">Per un elenco completo dei tipi supportati, vedere [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="65f14-107">For a full list of supported types, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="65f14-108">Per un'introduzione ai contratti dati, vedere [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="65f14-108">For an introduction to data contracts, see [Using Data Contracts](../../../../docs/framework/wcf/feature-details/using-data-contracts.md).</span></span>  
  
 <span data-ttu-id="65f14-109">Durante la deserializzazione di XML, il serializzatore utilizza le classi <xref:System.Xml.XmlReader> e <xref:System.Xml.XmlWriter> .</span><span class="sxs-lookup"><span data-stu-id="65f14-109">When deserializing XML, the serializer uses the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="65f14-110">Supporta inoltre le classi <xref:System.Xml.XmlDictionaryReader> e <xref:System.Xml.XmlDictionaryWriter> per consentire la produzione di codice XML ottimizzato in alcuni casi, ad esempio quando si utilizza il formato XML binario WCF.</span><span class="sxs-lookup"><span data-stu-id="65f14-110">It also supports the <xref:System.Xml.XmlDictionaryReader> and <xref:System.Xml.XmlDictionaryWriter> classes to enable it to produce optimized XML in some cases, such as when using the WCF binary XML format.</span></span>  
  
 <span data-ttu-id="65f14-111">WCF include anche un serializzatore complementare <xref:System.Runtime.Serialization.NetDataContractSerializer>,.</span><span class="sxs-lookup"><span data-stu-id="65f14-111">WCF also includes a companion serializer, the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="65f14-112">È simile ai serializzatori <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>eperché emette anche .NET Framework nomi di tipo come parte dei dati serializzati. <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> <xref:System.Runtime.Serialization.NetDataContractSerializer></span><span class="sxs-lookup"><span data-stu-id="65f14-112">The <xref:System.Runtime.Serialization.NetDataContractSerializer> is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> serializers because it also emits .NET Framework type names as part of the serialized data.</span></span> <span data-ttu-id="65f14-113">Viene utilizzato quando gli stessi tipi sono condivisi alle estremità di serializzazione e deserializzazione.</span><span class="sxs-lookup"><span data-stu-id="65f14-113">It is used when the same types are shared on the serializing and the deserializing ends.</span></span> <span data-ttu-id="65f14-114">Sia <xref:System.Runtime.Serialization.DataContractSerializer> che <xref:System.Runtime.Serialization.NetDataContractSerializer> derivano da una classe di base comune, <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span><span class="sxs-lookup"><span data-stu-id="65f14-114">Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Runtime.Serialization.NetDataContractSerializer> derive from a common base class, the <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="65f14-115"><xref:System.Runtime.Serialization.DataContractSerializer> serializza stringhe che contengono caratteri di controllo con un valore esadecimale inferiore a 20 come entità XML.</span><span class="sxs-lookup"><span data-stu-id="65f14-115">The <xref:System.Runtime.Serialization.DataContractSerializer> serializes strings containing control characters with a hexadecimal value below 20 as XML entities.</span></span> <span data-ttu-id="65f14-116">Questo può causare un problema con un client non WCF durante l'invio di tali dati a un servizio WCF.</span><span class="sxs-lookup"><span data-stu-id="65f14-116">This may cause a problem with a non-WCF client when sending such data to a WCF service.</span></span>  
  
## <a name="creating-a-datacontractserializer-instance"></a><span data-ttu-id="65f14-117">Creazione di un'istanza DataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="65f14-117">Creating a DataContractSerializer Instance</span></span>  
 <span data-ttu-id="65f14-118">La creazione di un'istanza di <xref:System.Runtime.Serialization.DataContractSerializer> è un passaggio importante.</span><span class="sxs-lookup"><span data-stu-id="65f14-118">Constructing an instance of the <xref:System.Runtime.Serialization.DataContractSerializer> is an important step.</span></span> <span data-ttu-id="65f14-119">Dopo la costruzione, non è possibile modificare nessuna di queste impostazioni.</span><span class="sxs-lookup"><span data-stu-id="65f14-119">After construction, you cannot change any of the settings.</span></span>  
  
### <a name="specifying-the-root-type"></a><span data-ttu-id="65f14-120">Specifica del tipo radice</span><span class="sxs-lookup"><span data-stu-id="65f14-120">Specifying the Root Type</span></span>  
 <span data-ttu-id="65f14-121">Il *tipo radice* è il tipo delle istanze che vengono serializzate o deserializzate.</span><span class="sxs-lookup"><span data-stu-id="65f14-121">The *root type* is the type of which instances are serialized or deserialized.</span></span> <span data-ttu-id="65f14-122"><xref:System.Runtime.Serialization.DataContractSerializer> ha numerosi overload del costruttore, tuttavia è necessario fornire almeno un tipo radice utilizzando il parametro `type` .</span><span class="sxs-lookup"><span data-stu-id="65f14-122">The <xref:System.Runtime.Serialization.DataContractSerializer> has many constructor overloads, but, at a minimum, a root type must be supplied using the `type` parameter.</span></span>  
  
 <span data-ttu-id="65f14-123">Un serializzatore creato per un certo tipo radice non può essere utilizzato per serializzare (o deserializzare) un altro tipo, a meno che il tipo non sia derivato dal tipo radice.</span><span class="sxs-lookup"><span data-stu-id="65f14-123">A serializer created for a certain root type cannot be used to serialize (or deserialize) another type, unless the type is derived from the root type.</span></span> <span data-ttu-id="65f14-124">Nell'esempio che segue vengono illustrate due classi.</span><span class="sxs-lookup"><span data-stu-id="65f14-124">The following example shows two classes.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#1)]
 [!code-vb[c_StandaloneDataContractSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#1)]  
  
 <span data-ttu-id="65f14-125">Questo codice costruisce un'istanza di `DataContractSerializer` che può essere utilizzata solo per serializzare o deserializzare istanze della classe `Person` .</span><span class="sxs-lookup"><span data-stu-id="65f14-125">This code constructs an instance of the `DataContractSerializer` that can be used only to serialize or deserialize instances of the `Person` class.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#2)]
 [!code-vb[c_StandaloneDataContractSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#2)]  
  
### <a name="specifying-known-types"></a><span data-ttu-id="65f14-126">Specifica di tipi noti</span><span class="sxs-lookup"><span data-stu-id="65f14-126">Specifying Known Types</span></span>  
 <span data-ttu-id="65f14-127">Se i tipi serializzati implicano un polimorfismo che non è già gestito utilizzando l'attributo <xref:System.Runtime.Serialization.KnownTypeAttribute> o un qualche altro meccanismo, è necessario passare al costruttore del serializzatore un elenco di possibili tipi noti utilizzando il parametro `knownTypes` .</span><span class="sxs-lookup"><span data-stu-id="65f14-127">If polymorphism is involved in the types being serialized that is not already handled using the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute or some other mechanism, a list of possible known types must be passed to the serializer’s constructor using the `knownTypes` parameter.</span></span> <span data-ttu-id="65f14-128">Per ulteriori informazioni sui tipi noti, vedere [tipi noti del contratto dati](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="65f14-128">For more information about known types, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>  
  
 <span data-ttu-id="65f14-129">Nell'esempio di codice seguente viene illustrata una classe, `LibraryPatron`, che comprende una raccolta di un tipo specifico `LibraryItem`.</span><span class="sxs-lookup"><span data-stu-id="65f14-129">The following example shows a class, `LibraryPatron`, that includes a collection of a specific type, the `LibraryItem`.</span></span> <span data-ttu-id="65f14-130">La seconda classe definisce il tipo `LibraryItem` .</span><span class="sxs-lookup"><span data-stu-id="65f14-130">The second class defines the `LibraryItem` type.</span></span> <span data-ttu-id="65f14-131">La terza e la quarta classe,`Book` e `Newspaper`, ereditano dalla classe `LibraryItem` .</span><span class="sxs-lookup"><span data-stu-id="65f14-131">The third and four classes (`Book` and `Newspaper`) inherit from the `LibraryItem` class.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#3)]  
 [!code-vb[c_StandaloneDataContractSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#3)]  
  
 <span data-ttu-id="65f14-132">Nel codice seguente viene creata un'istanza del serializzatore utilizzando il parametro `knownTypes` .</span><span class="sxs-lookup"><span data-stu-id="65f14-132">The following code constructs an instance of the serializer using the `knownTypes` parameter.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#4)]
 [!code-vb[c_StandaloneDataContractSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#4)]  
  
### <a name="specifying-the-default-root-name-and-namespace"></a><span data-ttu-id="65f14-133">Specifica del nome principale e dello spazio dei nomi predefiniti</span><span class="sxs-lookup"><span data-stu-id="65f14-133">Specifying the Default Root Name and Namespace</span></span>  
 <span data-ttu-id="65f14-134">In genere, quando un oggetto viene serializzato, il nome e lo spazio dei nomi predefiniti dell'elemento XML più esterno vengono determinati in base al nome del contratto dati e allo spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="65f14-134">Normally, when an object is serialized, the default name and namespace of the outermost XML element are determined according to the data contract name and namespace.</span></span> <span data-ttu-id="65f14-135">I nomi di tutti gli elementi interni vengono determinati dai nomi dei membri dati e il loro spazio dei nomi è lo spazio dei nomi del contratto dati.</span><span class="sxs-lookup"><span data-stu-id="65f14-135">The names of all inner elements are determined from data member names, and their namespace is the data contract’s namespace.</span></span> <span data-ttu-id="65f14-136">Nell'esempio seguente vengono impostati i valori `Name` e `Namespace` nei costruttori delle classi <xref:System.Runtime.Serialization.DataContractAttribute> e <xref:System.Runtime.Serialization.DataMemberAttribute> .</span><span class="sxs-lookup"><span data-stu-id="65f14-136">The following example sets `Name` and `Namespace` values in the constructors of the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute> classes.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#5)]
 [!code-vb[c_StandaloneDataContractSerializer#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#5)]  
  
 <span data-ttu-id="65f14-137">La serializzazione di un'istanza della classe `Person` produce un XML simile al seguente.</span><span class="sxs-lookup"><span data-stu-id="65f14-137">Serializing an instance of the `Person` class produces XML similar to the following.</span></span>  
  
```xml  
<PersonContract xmlns="http://schemas.contoso.com">  
  <AddressMember>  
    <StreetMember>123 Main Street</StreetMember>  
   </AddressMember>  
</PersonContract>  
```  
  
 <span data-ttu-id="65f14-138">È tuttavia possibile personalizzare il nome e lo spazio dei nomi predefiniti dell'elemento radice passando i valori dei parametri `rootName` e `rootNamespace` al costruttore <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="65f14-138">However, you can customize the default name and namespace of the root element by passing the values of the `rootName` and `rootNamespace` parameters to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor.</span></span> <span data-ttu-id="65f14-139">Si noti che `rootNamespace` non influisce sullo spazio dei nomi degli elementi contenuti che corrispondono ai membri dati.</span><span class="sxs-lookup"><span data-stu-id="65f14-139">Note that the `rootNamespace` does not affect the namespace of the contained elements that correspond to data members.</span></span> <span data-ttu-id="65f14-140">Influisce solo sullo spazio dei nomi dell'elemento più esterno.</span><span class="sxs-lookup"><span data-stu-id="65f14-140">It affects only the namespace of the outermost element.</span></span>  
  
 <span data-ttu-id="65f14-141">Questi valori possono essere passati come stringhe o come istanze della classe <xref:System.Xml.XmlDictionaryString> per consentire la loro ottimizzazione utilizzando il formato XML binario.</span><span class="sxs-lookup"><span data-stu-id="65f14-141">These values can be passed as strings or instances of the <xref:System.Xml.XmlDictionaryString> class to allow for their optimization using the binary XML format.</span></span>  
  
### <a name="setting-the-maximum-objects-quota"></a><span data-ttu-id="65f14-142">Impostazione della quota massima di oggetti</span><span class="sxs-lookup"><span data-stu-id="65f14-142">Setting the Maximum Objects Quota</span></span>  
 <span data-ttu-id="65f14-143">Alcuni overload del costruttore `DataContractSerializer` hanno un parametro `maxItemsInObjectGraph` .</span><span class="sxs-lookup"><span data-stu-id="65f14-143">Some `DataContractSerializer` constructor overloads have a `maxItemsInObjectGraph` parameter.</span></span> <span data-ttu-id="65f14-144">Tale parametro determina il numero massimo di oggetti serializzati o deserializzati dal serializzatore in una singola chiamata al metodo <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> .</span><span class="sxs-lookup"><span data-stu-id="65f14-144">This parameter determines the maximum number of objects the serializer serializes or deserializes in a single <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method call.</span></span> <span data-ttu-id="65f14-145">Questo metodo legge sempre un oggetto radice che, tuttavia, potrebbe contenere altri oggetti come membri dei propri dati.</span><span class="sxs-lookup"><span data-stu-id="65f14-145">(The method always reads one root object, but this object may have other objects in its data members.</span></span> <span data-ttu-id="65f14-146">Tali oggetti possono a loro volta contenere altri oggetti, e così via. Il valore predefinito è 65536.</span><span class="sxs-lookup"><span data-stu-id="65f14-146">Those objects may have other objects, and so on.) The default is 65536.</span></span> <span data-ttu-id="65f14-147">Si noti che, in caso di serializzazione o deserializzazione di matrici, ogni elemento della matrice viene considerato come un oggetto separato.</span><span class="sxs-lookup"><span data-stu-id="65f14-147">Note that when serializing or deserializing arrays, every array entry counts as a separate object.</span></span> <span data-ttu-id="65f14-148">Inoltre, poiché per alcuni oggetti è possibile una vasta rappresentazione in memoria, tale quota da sola potrebbe non essere sufficiente per impedire attacchi di tipo Denial of Service.</span><span class="sxs-lookup"><span data-stu-id="65f14-148">Also, note that some objects may have a large memory representation, and so this quota alone may not be sufficient to prevent a denial of service attack.</span></span> <span data-ttu-id="65f14-149">Per ulteriori informazioni, vedere [considerazioni sulla sicurezza per i dati](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md).</span><span class="sxs-lookup"><span data-stu-id="65f14-149">For more information, see [Security Considerations for Data](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md).</span></span> <span data-ttu-id="65f14-150">Se è necessario aumentare la quota oltre il valore predefinito, è importante aumentarla sia sul lato di invio (serializzazione) sia su quello di ricezione (deserializzazione) poiché si applica sia durante la lettura che durante la scrittura dei dati.</span><span class="sxs-lookup"><span data-stu-id="65f14-150">If you need to increase this quota beyond the default value, it is important to do so both on the sending (serializing) and receiving (deserializing) sides because it applies to both when reading and writing data.</span></span>  
  
### <a name="round-trips"></a><span data-ttu-id="65f14-151">Percorsi di andata e ritorno</span><span class="sxs-lookup"><span data-stu-id="65f14-151">Round Trips</span></span>  
 <span data-ttu-id="65f14-152">Si verifica un *percorso di andata e ritorno* quando un oggetto viene deserializzato e serializzato di nuovo in un'unica operazione.</span><span class="sxs-lookup"><span data-stu-id="65f14-152">A *round trip* occurs when an object is deserialized and re-serialized in one operation.</span></span> <span data-ttu-id="65f14-153">Pertanto, passa da XML a un'istanza dell'oggetto e torna indietro in un flusso XML.</span><span class="sxs-lookup"><span data-stu-id="65f14-153">Thus, it goes from XML to an object instance, and back again into an XML stream.</span></span>  
  
 <span data-ttu-id="65f14-154">Alcuni overload del costruttore `DataContractSerializer` hanno un parametro `ignoreExtensionDataObject` , la cui impostazione predefinita è `false` .</span><span class="sxs-lookup"><span data-stu-id="65f14-154">Some `DataContractSerializer` constructor overloads have an `ignoreExtensionDataObject` parameter, which is set to `false` by default.</span></span> <span data-ttu-id="65f14-155">In questa modalità predefinita, è possibile inviare i dati su un percorso di andata e ritorno da una versione più recente di un contratto dati a una versione precedente e di nuovo indietro alla versione più recente senza alcuna perdita, a condizione che il contratto dati implementi l'interfaccia <xref:System.Runtime.Serialization.IExtensibleDataObject> .</span><span class="sxs-lookup"><span data-stu-id="65f14-155">In this default mode, data can be sent on a round trip from a newer version of a data contract through an older version and back to the newer version without loss, as long as the data contract implements the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="65f14-156">Si supponga, ad esempio, che la versione 1 del contratto dati `Person` contenga i membri dati `Name` e `PhoneNumber` e che la versione 2 aggiunga un membro `Nickname` .</span><span class="sxs-lookup"><span data-stu-id="65f14-156">For example, suppose version 1 of the `Person` data contract contains the `Name` and `PhoneNumber` data members, and version 2 adds a `Nickname` member.</span></span> <span data-ttu-id="65f14-157">Se `IExtensibleDataObject` viene implementato, durante l'invio di informazioni dalla versione 2 alla versione 1 i dati `Nickname` vengono memorizzati ed emessi di nuovo alla successiva serializzazione; i dati non vengono persi nel percorso di andata e ritorno.</span><span class="sxs-lookup"><span data-stu-id="65f14-157">If `IExtensibleDataObject` is implemented, when sending information from version 2 to version 1, the `Nickname` data is stored, and then re-emitted when the data is serialized again; therefore, no data is lost in the round trip.</span></span> <span data-ttu-id="65f14-158">Per ulteriori informazioni, vedere [contratti dati compatibili con](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md) le versioni successive e [controllo delle versioni del contratto dati](../../../../docs/framework/wcf/feature-details/data-contract-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="65f14-158">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md) and [Data Contract Versioning](../../../../docs/framework/wcf/feature-details/data-contract-versioning.md).</span></span>  
  
#### <a name="security-and-schema-validity-concerns-with-round-trips"></a><span data-ttu-id="65f14-159">Problemi di sicurezza e validità dello schema in caso di percorsi di andata e ritorno</span><span class="sxs-lookup"><span data-stu-id="65f14-159">Security and Schema Validity Concerns with Round Trips</span></span>  
 <span data-ttu-id="65f14-160">I percorsi di andata e ritorno possono avere implicazioni di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="65f14-160">Round trips may have security implications.</span></span> <span data-ttu-id="65f14-161">La deserializzazione e memorizzazione di grandi quantità di dati estranei, ad esempio, possono rappresentare un rischio per la sicurezza.</span><span class="sxs-lookup"><span data-stu-id="65f14-161">For example, deserializing and storing large amounts of extraneous data may be a security risk.</span></span> <span data-ttu-id="65f14-162">Possono esservi problemi di sicurezza quando vengono emessi di nuovo dati che non è assolutamente possibile verificare, specie se implicano firme digitali.</span><span class="sxs-lookup"><span data-stu-id="65f14-162">There may be security concerns about re-emitting this data that there is no way to verify, especially if digital signatures are involved.</span></span> <span data-ttu-id="65f14-163">Nello scenario precedente, ad esempio, l'endpoint della versione 1 potrebbe firmare un valore `Nickname` che contiene dati dannosi.</span><span class="sxs-lookup"><span data-stu-id="65f14-163">For example, in the previous scenario, the version 1 endpoint could be signing a `Nickname` value that contains malicious data.</span></span> <span data-ttu-id="65f14-164">Infine, potrebbero verificarsi problemi di validità dello schema poiché un endpoint potrebbe desiderare di emettere sempre dati strettamente conformi al contratto dichiarato e nessun valore aggiuntivo.</span><span class="sxs-lookup"><span data-stu-id="65f14-164">Finally, there may be schema validity concerns: an endpoint may want to always emit data that strictly adheres to its stated contract and not any extra values.</span></span> <span data-ttu-id="65f14-165">Nell'esempio precedente, il contratto dell'endpoint della versione 1 asserisce che emette solo `Name` e `PhoneNumber`e, se viene utilizzata la convalida dello schema, l'emissione del valore `Nickname` aggiuntivo causa l'insuccesso della convalida.</span><span class="sxs-lookup"><span data-stu-id="65f14-165">In the previous example, the version 1 endpoint’s contract says that it emits only `Name` and `PhoneNumber`, and if schema validation is being used, emitting the extra `Nickname` value causes validation to fail.</span></span>  
  
#### <a name="enabling-and-disabling-round-trips"></a><span data-ttu-id="65f14-166">Attivazione e disattivazione di percorsi di andata e ritorno</span><span class="sxs-lookup"><span data-stu-id="65f14-166">Enabling and Disabling Round Trips</span></span>  
 <span data-ttu-id="65f14-167">Per disattivare i percorsi di andata e ritorno, non implementare l'interfaccia <xref:System.Runtime.Serialization.IExtensibleDataObject> .</span><span class="sxs-lookup"><span data-stu-id="65f14-167">To turn off round trips, do not implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="65f14-168">Se non si ha alcun controllo sui tipi, impostare il parametro `ignoreExtensionDataObject` su `true` per ottenere lo stesso effetto.</span><span class="sxs-lookup"><span data-stu-id="65f14-168">If you have no control over the types, set the `ignoreExtensionDataObject` parameter to `true` to achieve the same effect.</span></span>  
  
### <a name="object-graph-preservation"></a><span data-ttu-id="65f14-169">Conservazione dell'oggetto grafico</span><span class="sxs-lookup"><span data-stu-id="65f14-169">Object Graph Preservation</span></span>  
 <span data-ttu-id="65f14-170">In genere, il serializzatore non si preoccupa dell'identità dell'oggetto, come illustrato nel codice seguente.</span><span class="sxs-lookup"><span data-stu-id="65f14-170">Normally, the serializer does not care about object identity, as in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#6)]
 [!code-vb[c_StandaloneDataContractSerializer#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#6)]  
  
 <span data-ttu-id="65f14-171">Nel codice seguente viene creato un ordine di acquisto.</span><span class="sxs-lookup"><span data-stu-id="65f14-171">The following code creates a purchase order.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#7)]
 [!code-vb[c_StandaloneDataContractSerializer#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#7)]  
  
 <span data-ttu-id="65f14-172">Si noti che i campi `billTo` e `shipTo` sono impostati sulla stessa istanza dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="65f14-172">Notice that `billTo` and `shipTo` fields are set to the same object instance.</span></span> <span data-ttu-id="65f14-173">L'XML generato, tuttavia, duplica le informazioni duplicate ed è simile all'XML seguente.</span><span class="sxs-lookup"><span data-stu-id="65f14-173">However, the generated XML duplicates the information duplicated, and looks similar to the following XML.</span></span>  
  
```xml  
<PurchaseOrder>  
  <billTo><street>123 Main St.</street></billTo>  
  <shipTo><street>123 Main St.</street></shipTo>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="65f14-174">Questo approccio ha tuttavia le caratteristiche seguenti, che potrebbero essere indesiderate:</span><span class="sxs-lookup"><span data-stu-id="65f14-174">However, this approach has the following characteristics, which may be undesirable:</span></span>  
  
- <span data-ttu-id="65f14-175">Prestazioni.</span><span class="sxs-lookup"><span data-stu-id="65f14-175">Performance.</span></span> <span data-ttu-id="65f14-176">Replicare i dati non è efficiente.</span><span class="sxs-lookup"><span data-stu-id="65f14-176">Replicating data is inefficient.</span></span>  
  
- <span data-ttu-id="65f14-177">Riferimenti circolari.</span><span class="sxs-lookup"><span data-stu-id="65f14-177">Circular references.</span></span> <span data-ttu-id="65f14-178">Se gli oggetti fanno riferimento a se stessi, anche tramite altri oggetti, la serializzazione tramite la replica comporta un ciclo infinito.</span><span class="sxs-lookup"><span data-stu-id="65f14-178">If objects refer to themselves, even through other objects, serializing by replication results in an infinite loop.</span></span> <span data-ttu-id="65f14-179">In questo caso, il serializzatore genera una <xref:System.Runtime.Serialization.SerializationException> .</span><span class="sxs-lookup"><span data-stu-id="65f14-179">(The serializer throws a <xref:System.Runtime.Serialization.SerializationException> if this happens.)</span></span>  
  
- <span data-ttu-id="65f14-180">Semantica.</span><span class="sxs-lookup"><span data-stu-id="65f14-180">Semantics.</span></span> <span data-ttu-id="65f14-181">Talvolta è importante mantenere due riferimenti allo stesso oggetto e non a due oggetti identici.</span><span class="sxs-lookup"><span data-stu-id="65f14-181">Sometimes it is important to preserve the fact that two references are to the same object, and not to two identical objects.</span></span>  
  
 <span data-ttu-id="65f14-182">Per queste ragioni, alcuni overload del costruttore `DataContractSerializer` hanno un parametro `preserveObjectReferences` (l'impostazione predefinita è `false`).</span><span class="sxs-lookup"><span data-stu-id="65f14-182">For these reasons, some `DataContractSerializer` constructor overloads have a `preserveObjectReferences` parameter (the default is `false`).</span></span> <span data-ttu-id="65f14-183">Quando questo parametro è impostato su `true`, viene utilizzato un metodo speciale per codificare i riferimenti agli oggetti, che solo WCF riconosce.</span><span class="sxs-lookup"><span data-stu-id="65f14-183">When this parameter is set to `true`, a special method of encoding object references, which only WCF understands, is used.</span></span> <span data-ttu-id="65f14-184">Quando è impostato su `true`, l'esempio di codice XML è simile al seguente.</span><span class="sxs-lookup"><span data-stu-id="65f14-184">When set to `true`, the XML code example now resembles the following.</span></span>  
  
```xml  
<PurchaseOrder ser:id="1">  
  <billTo ser:id="2"><street ser:id="3">123 Main St.</street></billTo>  
  <shipTo ser:ref="2"/>  
</PurchaseOrder>  
```  
  
 <span data-ttu-id="65f14-185">Lo spazio dei nomi "ser" si riferisce allo `http://schemas.microsoft.com/2003/10/Serialization/`spazio dei nomi di serializzazione standard.</span><span class="sxs-lookup"><span data-stu-id="65f14-185">The "ser" namespace refers to the standard serialization namespace, `http://schemas.microsoft.com/2003/10/Serialization/`.</span></span> <span data-ttu-id="65f14-186">Ogni blocco di dati viene serializzato solo una volta e gli viene fornito un numero ID. Gli utilizzi successivi comportano un riferimento ai dati già serializzati.</span><span class="sxs-lookup"><span data-stu-id="65f14-186">Each piece of data is serialized only once and given an ID number, and subsequent uses result in a reference to the already serialized data.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="65f14-187">Se entrambi gli attributi "id" e "ref" sono presenti nel contratto dati `XMLElement`, l'attributo "ref" viene rispettato e l'attributo "id" viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="65f14-187">If both "id" and "ref" attributes are present in the data contract `XMLElement`, then the "ref" attribute is honored and the "id" attribute is ignored.</span></span>  
  
 <span data-ttu-id="65f14-188">È importante capire le limitazioni di questa modalità:</span><span class="sxs-lookup"><span data-stu-id="65f14-188">It is important to understand the limitations of this mode:</span></span>  
  
- <span data-ttu-id="65f14-189">L'XML prodotto da `DataContractSerializer` con `preserveObjectReferences` impostato su `true` non è interoperativo con nessun'altra tecnologia ed è possibile accedervi solo da un'altra istanza `DataContractSerializer` , anche con `preserveObjectReferences` impostato su `true`.</span><span class="sxs-lookup"><span data-stu-id="65f14-189">The XML the `DataContractSerializer` produces with `preserveObjectReferences` set to `true` is not interoperable with any other technologies, and can be accessed only by another `DataContractSerializer` instance, also with `preserveObjectReferences` set to `true`.</span></span>  
  
- <span data-ttu-id="65f14-190">Non esiste supporto di metadati (schema) per questa funzionalità.</span><span class="sxs-lookup"><span data-stu-id="65f14-190">There is no metadata (schema) support for this feature.</span></span> <span data-ttu-id="65f14-191">Lo schema prodotto è valido solo quando `preserveObjectReferences` è impostato su `false`.</span><span class="sxs-lookup"><span data-stu-id="65f14-191">The schema that is produced is valid only for the case when `preserveObjectReferences` is set to `false`.</span></span>  
  
- <span data-ttu-id="65f14-192">Questa funzionalità può rallentare il processo di serializzazione e di deserializzazione.</span><span class="sxs-lookup"><span data-stu-id="65f14-192">This feature may cause the serialization and deserialization process to run slower.</span></span> <span data-ttu-id="65f14-193">Anche se i dati non devono essere replicati, i confronti degli oggetti aggiuntivi devono essere eseguiti in questa modalità.</span><span class="sxs-lookup"><span data-stu-id="65f14-193">Although data does not have to be replicated, extra object comparisons must be performed in this mode.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="65f14-194">Quando la modalità `preserveObjectReferences` è attivata, è particolarmente importante impostare il valore `maxItemsInObjectGraph` sulla quota corretta.</span><span class="sxs-lookup"><span data-stu-id="65f14-194">When the `preserveObjectReferences` mode is enabled, it is especially important to set the `maxItemsInObjectGraph` value to the correct quota.</span></span> <span data-ttu-id="65f14-195">A causa del modo in cui le matrici sono gestite in questa modalità, è facile per l'autore di un attacco costruire un piccolo messaggio dannoso che comporta un grande consumo di memoria limitato solo dalla quota `maxItemsInObjectGraph` .</span><span class="sxs-lookup"><span data-stu-id="65f14-195">Due to the way arrays are handled in this mode, it is easy for an attacker to construct a small malicious message that results in large memory consumption limited only by the `maxItemsInObjectGraph` quota.</span></span>  
  
### <a name="specifying-a-data-contract-surrogate"></a><span data-ttu-id="65f14-196">Specifica di un surrogato del contratto dati</span><span class="sxs-lookup"><span data-stu-id="65f14-196">Specifying a Data Contract Surrogate</span></span>  
 <span data-ttu-id="65f14-197">Alcuni overload del costruttore `DataContractSerializer` hanno un parametro `dataContractSurrogate` che può essere impostato su `null`.</span><span class="sxs-lookup"><span data-stu-id="65f14-197">Some `DataContractSerializer` constructor overloads have a `dataContractSurrogate` parameter, which may be set to `null`.</span></span> <span data-ttu-id="65f14-198">In caso contrario, è possibile utilizzarlo per specificare un *surrogato del contratto dati*che è un tipo che implementa l'interfaccia <xref:System.Runtime.Serialization.IDataContractSurrogate> .</span><span class="sxs-lookup"><span data-stu-id="65f14-198">Otherwise, you can use it to specify a *data contract surrogate*, which is a type that implements the <xref:System.Runtime.Serialization.IDataContractSurrogate> interface.</span></span> <span data-ttu-id="65f14-199">È quindi possibile utilizzare l'interfaccia per personalizzare il processo di serializzazione e di deserializzazione.</span><span class="sxs-lookup"><span data-stu-id="65f14-199">You can then use the interface to customize the serialization and deserialization process.</span></span> <span data-ttu-id="65f14-200">Per ulteriori informazioni, vedere [surrogati del contratto dati](../../../../docs/framework/wcf/extending/data-contract-surrogates.md).</span><span class="sxs-lookup"><span data-stu-id="65f14-200">For more information, see [Data Contract Surrogates](../../../../docs/framework/wcf/extending/data-contract-surrogates.md).</span></span>  
  
## <a name="serialization"></a><span data-ttu-id="65f14-201">Serializzazione</span><span class="sxs-lookup"><span data-stu-id="65f14-201">Serialization</span></span>  
 <span data-ttu-id="65f14-202">Le informazioni seguenti si applicano a qualsiasi classe che eredita da <xref:System.Runtime.Serialization.XmlObjectSerializer>, incluse le classi <xref:System.Runtime.Serialization.DataContractSerializer> e <xref:System.Runtime.Serialization.NetDataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="65f14-202">The following information applies to any class that inherits from the <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> classes.</span></span>  
  
### <a name="simple-serialization"></a><span data-ttu-id="65f14-203">Serializzazione semplice</span><span class="sxs-lookup"><span data-stu-id="65f14-203">Simple Serialization</span></span>  
 <span data-ttu-id="65f14-204">La modalità più elementare per serializzare un oggetto consiste nel passarlo al metodo <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> .</span><span class="sxs-lookup"><span data-stu-id="65f14-204">The most basic way to serialize an object is to pass it to the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> method.</span></span> <span data-ttu-id="65f14-205">Esistono tre overload, per scrivere rispettivamente in un <xref:System.IO.Stream>, in un <xref:System.Xml.XmlWriter>o in un <xref:System.Xml.XmlDictionaryWriter>.</span><span class="sxs-lookup"><span data-stu-id="65f14-205">There are three overloads, one each for writing to a <xref:System.IO.Stream>, an <xref:System.Xml.XmlWriter>, or an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="65f14-206">Con l'overload <xref:System.IO.Stream> , l'output è XML nella codifica UTF-8.</span><span class="sxs-lookup"><span data-stu-id="65f14-206">With the <xref:System.IO.Stream> overload, the output is XML in the UTF-8 encoding.</span></span> <span data-ttu-id="65f14-207">Con l'overload <xref:System.Xml.XmlDictionaryWriter> , il serializzatore ottimizza l'output per XML binario.</span><span class="sxs-lookup"><span data-stu-id="65f14-207">With the <xref:System.Xml.XmlDictionaryWriter> overload, the serializer optimizes its output for binary XML.</span></span>  
  
 <span data-ttu-id="65f14-208">Quando si usa <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> il metodo, il serializzatore usa il nome e lo spazio dei nomi predefiniti per l'elemento wrapper e lo scrive insieme al contenuto (vedere la sezione precedente "specifica del nome e dello spazio dei nomi radice predefiniti").</span><span class="sxs-lookup"><span data-stu-id="65f14-208">When using the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> method, the serializer uses the default name and namespace for the wrapper element and writes it out along with the contents (see the previous "Specifying the Default Root Name and Namespace" section).</span></span>  
  
 <span data-ttu-id="65f14-209">Nell'esempio seguente viene illustrato come scrivere con <xref:System.Xml.XmlDictionaryWriter>.</span><span class="sxs-lookup"><span data-stu-id="65f14-209">The following example demonstrates writing with an <xref:System.Xml.XmlDictionaryWriter>.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#8)]
 [!code-vb[c_StandaloneDataContractSerializer#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#8)]  
  
 <span data-ttu-id="65f14-210">Viene prodotto un XML simile al seguente.</span><span class="sxs-lookup"><span data-stu-id="65f14-210">This produces XML similar to the following.</span></span>  
  
```xml  
<Person>  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</Person>  
```  
  
### <a name="step-by-step-serialization"></a><span data-ttu-id="65f14-211">Serializzazione dettagliata</span><span class="sxs-lookup"><span data-stu-id="65f14-211">Step-By-Step Serialization</span></span>  
 <span data-ttu-id="65f14-212">Utilizzare i metodi <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A>e <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> rispettivamente per scrivere l'elemento finale, scrivere il contenuto dell'oggetto e chiudere l'elemento wrapper.</span><span class="sxs-lookup"><span data-stu-id="65f14-212">Use the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A>, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A>, and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> methods to write the end element, write the object contents, and close the wrapper element, respectively.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="65f14-213">Non esistono overload <xref:System.IO.Stream> di questi metodi.</span><span class="sxs-lookup"><span data-stu-id="65f14-213">There are no <xref:System.IO.Stream> overloads of these methods.</span></span>  
  
 <span data-ttu-id="65f14-214">Questa serializzazione dettagliata ha due utilizzi comuni.</span><span class="sxs-lookup"><span data-stu-id="65f14-214">This step-by-step serialization has two common uses.</span></span> <span data-ttu-id="65f14-215">Nel primo caso, viene utilizzata per inserire contenuto, ad esempio attributi o commenti tra `WriteStartObject` e `WriteObjectContent`, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="65f14-215">One is to insert contents such as attributes or comments between `WriteStartObject` and `WriteObjectContent`,  as shown in the following example.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#9)]
 [!code-vb[c_StandaloneDataContractSerializer#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#9)]  
  
 <span data-ttu-id="65f14-216">Viene prodotto un XML simile al seguente.</span><span class="sxs-lookup"><span data-stu-id="65f14-216">This produces XML similar to the following.</span></span>  
  
```xml  
<Person serializedBy="myCode">  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</Person>  
```  
  
 <span data-ttu-id="65f14-217">Nel secondo caso, viene utilizzata per evitare di utilizzare <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> e <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> e scrivere l'elemento wrapper personalizzato (o per evitare di scrivere un wrapper), come illustrato nel codice seguente.</span><span class="sxs-lookup"><span data-stu-id="65f14-217">Another common use is to avoid using <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> entirely, and to write your own custom wrapper element (or even skip writing a wrapper altogether), as shown in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#10)]
 [!code-vb[c_StandaloneDataContractSerializer#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#10)]  
  
 <span data-ttu-id="65f14-218">Viene prodotto un XML simile al seguente.</span><span class="sxs-lookup"><span data-stu-id="65f14-218">This produces XML similar to the following.</span></span>  
  
```xml  
<MyCustomWrapper>  
  <Name>Jay Hamlin</Name>  
  <Address>123 Main St.</Address>  
</MyCustomWrapper>  
```  
  
> [!NOTE]
> <span data-ttu-id="65f14-219">L'utilizzo della serializzazione dettagliata può comportare un XML di schema non valido.</span><span class="sxs-lookup"><span data-stu-id="65f14-219">Using step-by-step serialization may result in schema-invalid XML.</span></span>  
  
## <a name="deserialization"></a><span data-ttu-id="65f14-220">Deserializzazione</span><span class="sxs-lookup"><span data-stu-id="65f14-220">Deserialization</span></span>  
 <span data-ttu-id="65f14-221">Le informazioni seguenti si applicano a qualsiasi classe che eredita da <xref:System.Runtime.Serialization.XmlObjectSerializer>, incluse le classi <xref:System.Runtime.Serialization.DataContractSerializer> e <xref:System.Runtime.Serialization.NetDataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="65f14-221">The following information applies to any class that inherits from the <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer> classes.</span></span>  
  
 <span data-ttu-id="65f14-222">La modalità più elementare per deserializzare un oggetto consiste nel chiamare uno degli overload del metodo <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> .</span><span class="sxs-lookup"><span data-stu-id="65f14-222">The most basic way to deserialize an object is to call one of the <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method overloads.</span></span> <span data-ttu-id="65f14-223">Esistono tre overload, rispettivamente per la lettura con un <xref:System.Xml.XmlDictionaryReader>, un `XmlReader`o un `Stream`.</span><span class="sxs-lookup"><span data-stu-id="65f14-223">There are three overloads, one each for reading with a <xref:System.Xml.XmlDictionaryReader>, an `XmlReader`, or a `Stream`.</span></span> <span data-ttu-id="65f14-224">Si noti che l'overload `Stream` crea un <xref:System.Xml.XmlDictionaryReader> testuale che non è protetto da nessuna quota e deve essere utilizzato solo per leggere dati attendibili.</span><span class="sxs-lookup"><span data-stu-id="65f14-224">Note that the `Stream` overload creates a textual <xref:System.Xml.XmlDictionaryReader> that is not protected by any quotas, and should be used only to read trusted data.</span></span>  
  
 <span data-ttu-id="65f14-225">Si noti inoltre che è necessario eseguire il cast dell'oggetto restituito dal metodo `ReadObject` sul tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="65f14-225">Also note that the object the `ReadObject` method returns must be cast to the appropriate type.</span></span>  
  
 <span data-ttu-id="65f14-226">Nel codice seguente viene creata un'istanza di <xref:System.Runtime.Serialization.DataContractSerializer> e di <xref:System.Xml.XmlDictionaryReader>, quindi viene deserializzata un'istanza `Person` .</span><span class="sxs-lookup"><span data-stu-id="65f14-226">The following code constructs an instance of the <xref:System.Runtime.Serialization.DataContractSerializer> and an <xref:System.Xml.XmlDictionaryReader>, then deserializes a `Person` instance.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#11)]
 [!code-vb[c_StandaloneDataContractSerializer#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#11)]  
  
 <span data-ttu-id="65f14-227">Prima di chiamare il metodo <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> , posizionare il lettore XML sull'elemento wrapper o su un nodo non di contenuto che precede l'elemento wrapper.</span><span class="sxs-lookup"><span data-stu-id="65f14-227">Before calling the <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> method, position the XML reader on the wrapper element or on a non-content node that precedes the wrapper element.</span></span> <span data-ttu-id="65f14-228">A tale fine, chiamare il metodo <xref:System.Xml.XmlReader.Read%2A> di <xref:System.Xml.XmlReader> o la sua derivazione e testare <xref:System.Xml.XmlReader.NodeType%2A>, come illustrato nel codice seguente.</span><span class="sxs-lookup"><span data-stu-id="65f14-228">You can do this by calling the <xref:System.Xml.XmlReader.Read%2A> method of the <xref:System.Xml.XmlReader> or its derivation, and testing the <xref:System.Xml.XmlReader.NodeType%2A>, as shown in the following code.</span></span>  
  
 [!code-csharp[c_StandaloneDataContractSerializer#12](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_standalonedatacontractserializer/cs/source.cs#12)]
 [!code-vb[c_StandaloneDataContractSerializer#12](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_standalonedatacontractserializer/vb/source.vb#12)]  
  
 <span data-ttu-id="65f14-229">Si noti che è possibile leggere gli attributi in questo elemento wrapper prima di passare il lettore a `ReadObject`.</span><span class="sxs-lookup"><span data-stu-id="65f14-229">Note that you can read attributes on this wrapper element before handing the reader to `ReadObject`.</span></span>  
  
 <span data-ttu-id="65f14-230">Quando si usa uno degli overload `ReadObject` semplici, il deserializzatore cerca il nome e lo spazio dei nomi predefiniti nell'elemento wrapper (vedere la sezione precedente, "specificando il nome e lo spazio dei nomi radice predefiniti") e genera un'eccezione se trova un oggetto sconosciuto elemento.</span><span class="sxs-lookup"><span data-stu-id="65f14-230">When using one of the simple `ReadObject` overloads, the deserializer looks for the default name and namespace on the wrapper element (see the preceding section, "Specifying the Default Root Name and Namespace") and throws an exception if it finds an unknown element.</span></span> <span data-ttu-id="65f14-231">Nell'esempio precedente è previsto l'elemento wrapper `<Person>` .</span><span class="sxs-lookup"><span data-stu-id="65f14-231">In the preceding example, the `<Person>` wrapper element is expected.</span></span> <span data-ttu-id="65f14-232">Per verificare che il lettore sia posizionato su un elemento denominato come previsto, viene chiamato il metodo <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> .</span><span class="sxs-lookup"><span data-stu-id="65f14-232">The <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> method is called to verify that the reader is positioned on an element that is named as expected.</span></span>  
  
 <span data-ttu-id="65f14-233">Il controllo del nome di un elemento wrapper può essere disattivato. Alcuni overload del metodo `ReadObject` prendono il parametro booleano `verifyObjectName`, la cui impostazione predefinita è `true` .</span><span class="sxs-lookup"><span data-stu-id="65f14-233">There is a way to disable this wrapper element name check; some overloads of the `ReadObject` method take the Boolean parameter `verifyObjectName`, which is set to `true` by default.</span></span> <span data-ttu-id="65f14-234">Quando è impostato su `false`, il nome e lo spazio dei nomi dell'elemento wrapper vengono ignorati.</span><span class="sxs-lookup"><span data-stu-id="65f14-234">When set to `false`, the name and namespace of the wrapper element is ignored.</span></span> <span data-ttu-id="65f14-235">Ciò è utile per leggere l'XML scritto utilizzando il meccanismo di serializzazione dettagliata descritto in precedenza.</span><span class="sxs-lookup"><span data-stu-id="65f14-235">This is useful for reading XML that was written using the step-by-step serialization mechanism described previously.</span></span>  
  
## <a name="using-the-netdatacontractserializer"></a><span data-ttu-id="65f14-236">Utilizzo di NetDataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="65f14-236">Using the NetDataContractSerializer</span></span>  
 <span data-ttu-id="65f14-237">`DataContractSerializer` La differenza principale tra <xref:System.Runtime.Serialization.NetDataContractSerializer> e è che `DataContractSerializer` usa i nomi di contratto dati, mentre `NetDataContractSerializer` restituisce i nomi di assembly e di tipo completi .NET Framework nel codice XML serializzato.</span><span class="sxs-lookup"><span data-stu-id="65f14-237">The primary difference between the `DataContractSerializer` and the <xref:System.Runtime.Serialization.NetDataContractSerializer> is that the `DataContractSerializer` uses data contract names, whereas the `NetDataContractSerializer` outputs full .NET Framework assembly and type names in the serialized XML.</span></span> <span data-ttu-id="65f14-238">Ciò significa che devono essere condivisi esattamente gli stessi tipi tra gli endpoint di serializzazione e di deserializzazione.</span><span class="sxs-lookup"><span data-stu-id="65f14-238">This means that the exact same types must be shared between the serialization and deserialization endpoints.</span></span> <span data-ttu-id="65f14-239">Il meccanismo dei tipi noti non è pertanto richiesto con `NetDataContractSerializer` perché i tipi esatti da deserializzare sono sempre conosciuti.</span><span class="sxs-lookup"><span data-stu-id="65f14-239">This means that the known types mechanism is not required with the `NetDataContractSerializer` because the exact types to be deserialized are always known.</span></span>  
  
 <span data-ttu-id="65f14-240">Possono tuttavia verificarsi numerosi problemi:</span><span class="sxs-lookup"><span data-stu-id="65f14-240">However, several problems can occur:</span></span>  
  
- <span data-ttu-id="65f14-241">Sicurezza:</span><span class="sxs-lookup"><span data-stu-id="65f14-241">Security.</span></span> <span data-ttu-id="65f14-242">Viene caricato qualsiasi tipo trovato nell'XML che viene deserializzato.</span><span class="sxs-lookup"><span data-stu-id="65f14-242">Any type found in the XML being deserialized is loaded.</span></span> <span data-ttu-id="65f14-243">Questo comportamento può essere sfruttato per forzare il caricamento di tipi dannosi.</span><span class="sxs-lookup"><span data-stu-id="65f14-243">This can be exploited to force the loading of malicious types.</span></span> <span data-ttu-id="65f14-244">È consigliabile utilizzare `NetDataContractSerializer` con dati non attendibili solo se viene utilizzato un *gestore di associazione della serializzazione* (tramite la proprietà <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> o il parametro del costruttore).</span><span class="sxs-lookup"><span data-stu-id="65f14-244">Using the `NetDataContractSerializer` with untrusted data should be done only if a *Serialization Binder* is used (using the <xref:System.Runtime.Serialization.NetDataContractSerializer.Binder%2A> property or constructor parameter).</span></span> <span data-ttu-id="65f14-245">Il gestore di associazione consente che vengano caricati solo i tipi sicuri.</span><span class="sxs-lookup"><span data-stu-id="65f14-245">The binder permits only safe types to be loaded.</span></span> <span data-ttu-id="65f14-246">Il meccanismo del gestore di associazione è identico a quello utilizzato dai tipi nello spazio dei nomi <xref:System.Runtime.Serialization> .</span><span class="sxs-lookup"><span data-stu-id="65f14-246">The Binder mechanism is identical to the one that types in the <xref:System.Runtime.Serialization> namespace use.</span></span>  
  
- <span data-ttu-id="65f14-247">Controllo delle versioni.</span><span class="sxs-lookup"><span data-stu-id="65f14-247">Versioning.</span></span> <span data-ttu-id="65f14-248">L'utilizzo di nomi di assembly e di tipo completi nell'XML limita rigidamente il modo in cui è possibile controllare le versioni dei tipi.</span><span class="sxs-lookup"><span data-stu-id="65f14-248">Using full type and assembly names in the XML severely restricts how types can be versioned.</span></span> <span data-ttu-id="65f14-249">Non è possibile modificare gli elementi seguenti: nomi dei tipi, spazi dei nomi, nomi degli assembly e versioni degli assembly.</span><span class="sxs-lookup"><span data-stu-id="65f14-249">The following cannot be changed: type names, namespaces, assembly names, and assembly versions.</span></span> <span data-ttu-id="65f14-250">L'impostazione della proprietà <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> o del parametro del costruttore su <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> anziché sul valore predefinito di <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> consente di modificare la versione dell'assembly, fatta eccezione per i tipi di parametro generici.</span><span class="sxs-lookup"><span data-stu-id="65f14-250">Setting the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property or constructor parameter to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> instead of the default value of <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Full> allows for assembly version changes, but not for generic parameter types.</span></span>  
  
- <span data-ttu-id="65f14-251">Interoperabilità.</span><span class="sxs-lookup"><span data-stu-id="65f14-251">Interoperability.</span></span> <span data-ttu-id="65f14-252">Poiché i nomi dei tipi e degli assembly .NET Framework sono inclusi nel codice XML, le piattaforme diverse da .NET Framework non possono accedere ai dati risultanti.</span><span class="sxs-lookup"><span data-stu-id="65f14-252">Because .NET Framework type and assembly names are included in the XML, platforms other than the .NET Framework cannot access the resulting data.</span></span>  
  
- <span data-ttu-id="65f14-253">Prestazioni.</span><span class="sxs-lookup"><span data-stu-id="65f14-253">Performance.</span></span> <span data-ttu-id="65f14-254">La scrittura dei nomi di tipi e assembly aumenta notevolmente le dimensioni dell'XML risultante.</span><span class="sxs-lookup"><span data-stu-id="65f14-254">Writing out the type and assembly names significantly increases the size of the resulting XML.</span></span>  
  
 <span data-ttu-id="65f14-255">Questo meccanismo è simile alla serializzazione SOAP o binaria utilizzata da .NET Framework comunicazione remota ( <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> in particolare <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>, e).</span><span class="sxs-lookup"><span data-stu-id="65f14-255">This mechanism is similar to binary or SOAP serialization used by .NET Framework remoting (specifically, the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>).</span></span>  
  
 <span data-ttu-id="65f14-256">L'utilizzo di `NetDataContractSerializer` è simile a quello di `DataContractSerializer`, tranne che per le differenze seguenti:</span><span class="sxs-lookup"><span data-stu-id="65f14-256">Using the `NetDataContractSerializer` is similar to using the `DataContractSerializer`, with the following differences:</span></span>  
  
- <span data-ttu-id="65f14-257">I costruttori non richiedono che venga specificato un tipo radice.</span><span class="sxs-lookup"><span data-stu-id="65f14-257">The constructors do not require you to specify a root type.</span></span> <span data-ttu-id="65f14-258">È possibile serializzare qualsiasi tipo con la stessa istanza di `NetDataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="65f14-258">You can serialize any type with the same instance of the `NetDataContractSerializer`.</span></span>  
  
- <span data-ttu-id="65f14-259">I costruttori non accettano un elenco di tipi noti.</span><span class="sxs-lookup"><span data-stu-id="65f14-259">The constructors do not accept a list of known types.</span></span> <span data-ttu-id="65f14-260">Il meccanismo dei tipi noti è non necessario se i nomi dei tipi sono serializzati nell'XML.</span><span class="sxs-lookup"><span data-stu-id="65f14-260">The known types mechanism is unnecessary if type names are serialized into the XML.</span></span>  
  
- <span data-ttu-id="65f14-261">I costruttori non accettano un surrogato del contratto dati.</span><span class="sxs-lookup"><span data-stu-id="65f14-261">The constructors do not accept a data contract surrogate.</span></span> <span data-ttu-id="65f14-262">Accettano invece un parametro <xref:System.Runtime.Serialization.ISurrogateSelector> chiamato `surrogateSelector` (che esegue il mapping alla proprietà <xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A> ).</span><span class="sxs-lookup"><span data-stu-id="65f14-262">Instead, they accept an <xref:System.Runtime.Serialization.ISurrogateSelector> parameter called `surrogateSelector` (which maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.SurrogateSelector%2A> property).</span></span> <span data-ttu-id="65f14-263">Si tratta di un meccanismo surrogato legacy.</span><span class="sxs-lookup"><span data-stu-id="65f14-263">This is a legacy surrogate mechanism.</span></span>  
  
- <span data-ttu-id="65f14-264">Il costruttore accetta un parametro chiamato `assemblyFormat` di <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> che esegue il mapping alla proprietà <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> .</span><span class="sxs-lookup"><span data-stu-id="65f14-264">The constructors accept a parameter called `assemblyFormat` of the <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> that maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property.</span></span> <span data-ttu-id="65f14-265">Come illustrato in precedenza, ciò può essere utilizzato per migliorare le funzionalità di controllo delle versioni del serializzatore.</span><span class="sxs-lookup"><span data-stu-id="65f14-265">As discussed previously, this can be used to enhance the versioning capabilities of the serializer.</span></span> <span data-ttu-id="65f14-266">È identico al meccanismo <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> nella serializzazione SOAP o binaria.</span><span class="sxs-lookup"><span data-stu-id="65f14-266">This is identical to the <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle> mechanism in binary or SOAP serialization.</span></span>  
  
- <span data-ttu-id="65f14-267">Il costruttore accetta un parametro <xref:System.Runtime.Serialization.StreamingContext> chiamato `context` che esegue il mapping alla proprietà <xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A> .</span><span class="sxs-lookup"><span data-stu-id="65f14-267">The constructors accept a <xref:System.Runtime.Serialization.StreamingContext> parameter called `context` that maps to the <xref:System.Runtime.Serialization.NetDataContractSerializer.Context%2A> property.</span></span> <span data-ttu-id="65f14-268">È possibile utilizzare questa funzionalità per passare informazioni nei tipi serializzati.</span><span class="sxs-lookup"><span data-stu-id="65f14-268">You can use this to pass information into types being serialized.</span></span> <span data-ttu-id="65f14-269">Questo utilizzo è identico a quello del meccanismo <xref:System.Runtime.Serialization.StreamingContext> utilizzato in altre classi <xref:System.Runtime.Serialization> .</span><span class="sxs-lookup"><span data-stu-id="65f14-269">This usage is identical to that of the <xref:System.Runtime.Serialization.StreamingContext> mechanism used in other <xref:System.Runtime.Serialization> classes.</span></span>  
  
- <span data-ttu-id="65f14-270">I metodi <xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A> e <xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A> sono alias per i metodi <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> e <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> .</span><span class="sxs-lookup"><span data-stu-id="65f14-270">The <xref:System.Runtime.Serialization.NetDataContractSerializer.Serialize%2A> and <xref:System.Runtime.Serialization.NetDataContractSerializer.Deserialize%2A> methods are aliases for the <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> methods.</span></span> <span data-ttu-id="65f14-271">Hanno la funzione di fornire un modello di programmazione più coerente con la serializzazione SOAP o binaria.</span><span class="sxs-lookup"><span data-stu-id="65f14-271">These exist to provide a more consistent programming model with binary or SOAP serialization.</span></span>  
  
 <span data-ttu-id="65f14-272">Per ulteriori informazioni su queste funzionalità, vedere [serializzazione binaria](../../../standard/serialization/binary-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="65f14-272">For more information about these features, see [Binary Serialization](../../../standard/serialization/binary-serialization.md).</span></span>  
  
 <span data-ttu-id="65f14-273">I formati XML utilizzati da `NetDataContractSerializer` e `DataContractSerializer` in genere non sono compatibili.</span><span class="sxs-lookup"><span data-stu-id="65f14-273">The XML formats that the `NetDataContractSerializer` and the `DataContractSerializer` use are normally not compatible.</span></span> <span data-ttu-id="65f14-274">Ciò significa che non è consentito eseguire la serializzazione con uno di questi serializzatori e la deserializzazione con l'altro.</span><span class="sxs-lookup"><span data-stu-id="65f14-274">That is, attempting to serialize with one of these serializers and deserialize with the other is not a supported scenario.</span></span>  
  
 <span data-ttu-id="65f14-275">Si noti inoltre che `NetDataContractSerializer` non viene restituito il tipo di .NET Framework completo e il nome dell'assembly per ogni nodo nell'oggetto grafico.</span><span class="sxs-lookup"><span data-stu-id="65f14-275">Also, note that the `NetDataContractSerializer` does not output the full .NET Framework type and assembly name for each node in the object graph.</span></span> <span data-ttu-id="65f14-276">Restituisce queste informazioni solo in caso di ambiguità.</span><span class="sxs-lookup"><span data-stu-id="65f14-276">It outputs that information only where it is ambiguous.</span></span> <span data-ttu-id="65f14-277">Ovvero, a livello dell'oggetto radice e per il qualsiasi caso polimorfico.</span><span class="sxs-lookup"><span data-stu-id="65f14-277">That is, it outputs at the root object level and for any polymorphic cases.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="65f14-278">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="65f14-278">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.NetDataContractSerializer>
- <xref:System.Runtime.Serialization.XmlObjectSerializer>
- [<span data-ttu-id="65f14-279">Serializzazione binaria</span><span class="sxs-lookup"><span data-stu-id="65f14-279">Binary Serialization</span></span>](../../../standard/serialization/binary-serialization.md)
- [<span data-ttu-id="65f14-280">Tipi supportati dal serializzatore dei contratti di dati</span><span class="sxs-lookup"><span data-stu-id="65f14-280">Types Supported by the Data Contract Serializer</span></span>](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)
