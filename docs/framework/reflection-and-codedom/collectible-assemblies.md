---
title: Assembly ritirabili per la generazione di tipi dinamici
description: ''
ms.date: 08/29/2017
helpviewer_keywords:
- reflection, dynamic assembly
- assemblies, collectible
- collectible assemblies, retrieving
ms.openlocfilehash: 85eacff22cf2e1c0b8c3d74a4971de035dfafbe4
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 10/30/2019
ms.locfileid: "73130285"
---
# <a name="collectible-assemblies-for-dynamic-type-generation"></a><span data-ttu-id="4288f-102">Assembly ritirabili per la generazione di tipi dinamici</span><span class="sxs-lookup"><span data-stu-id="4288f-102">Collectible assemblies for dynamic type generation</span></span>

<span data-ttu-id="4288f-103">Gli *assembly ritirabili* sono assembly dinamici che possono essere scaricati senza scaricare il dominio dell'applicazione in cui sono stati creati.</span><span class="sxs-lookup"><span data-stu-id="4288f-103">*Collectible assemblies* are dynamic assemblies that can be unloaded without unloading the application domain in which they were created.</span></span> <span data-ttu-id="4288f-104">È possibile recuperare tutta la memoria gestita e non gestita usata da un assembly ritirabile e dai tipi che contiene.</span><span class="sxs-lookup"><span data-stu-id="4288f-104">All managed and unmanaged memory used by a collectible assembly and the types it contains can be reclaimed.</span></span> <span data-ttu-id="4288f-105">Le informazioni quali il nome dell'assembly vengono rimosse dalle tabelle interne.</span><span class="sxs-lookup"><span data-stu-id="4288f-105">Information such as the assembly name is removed from internal tables.</span></span>

<span data-ttu-id="4288f-106">Per abilitare lo scaricamento, usare il flag <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndCollect?displayProperty=nameWithType> quando si crea un assembly dinamico.</span><span class="sxs-lookup"><span data-stu-id="4288f-106">To enable unloading, use the <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndCollect?displayProperty=nameWithType> flag when you create a dynamic assembly.</span></span> <span data-ttu-id="4288f-107">L'assembly è temporaneo (ovvero, non è possibile salvarlo) ed è soggetto alle limitazioni descritte nella sezione [Limitazioni per gli assembly ritirabili](#restrictions-on-collectible-assemblies).</span><span class="sxs-lookup"><span data-stu-id="4288f-107">The assembly is transient (that is, it cannot be saved) and is subject to limitations described in the [Restrictions on Collectible Assemblies](#restrictions-on-collectible-assemblies) section.</span></span> <span data-ttu-id="4288f-108">Quando si rilasciano tutti gli oggetti associati a un assembly ritirabile, Common Language Runtime (CLR) scarica automaticamente l'assembly.</span><span class="sxs-lookup"><span data-stu-id="4288f-108">The common language runtime (CLR) unloads a collectible assembly automatically when you release all objects associated with the assembly.</span></span> <span data-ttu-id="4288f-109">Da tutti gli altri punti di vista, gli assembly ritirabili vengono creati e usati nello stesso modo degli altri assembly dinamici.</span><span class="sxs-lookup"><span data-stu-id="4288f-109">In all other respects, collectible assemblies are created and used in the same way as other dynamic assemblies.</span></span>

## <a name="lifetime-of-collectible-assemblies"></a><span data-ttu-id="4288f-110">Durata degli assembly ritirabili</span><span class="sxs-lookup"><span data-stu-id="4288f-110">Lifetime of collectible assemblies</span></span>

<span data-ttu-id="4288f-111">La durata di un assembly ritirabile è determinata dall'esistenza di riferimenti ai tipi che contiene e agli oggetti creati da tali tipi.</span><span class="sxs-lookup"><span data-stu-id="4288f-111">The lifetime of a collectible assembly is controlled by the existence of references to the types it contains and the objects that are created from those types.</span></span> <span data-ttu-id="4288f-112">Common Language Runtime non scarica un assembly fino a quando esistono uno o più degli elementi seguenti (`T` è qualsiasi tipo definito nell'assembly):</span><span class="sxs-lookup"><span data-stu-id="4288f-112">The common language runtime does not unload an assembly as long as one or more of the following exist (`T` is any type that is defined in the assembly):</span></span> 

- <span data-ttu-id="4288f-113">Istanza di `T`.</span><span class="sxs-lookup"><span data-stu-id="4288f-113">An instance of `T`.</span></span>

- <span data-ttu-id="4288f-114">Un'istanza di una matrice di `T`.</span><span class="sxs-lookup"><span data-stu-id="4288f-114">An instance of an array of `T`.</span></span>
 
- <span data-ttu-id="4288f-115">Un'istanza di un tipo generico con `T` come uno dei relativi argomenti di tipo.</span><span class="sxs-lookup"><span data-stu-id="4288f-115">An instance of a generic type that has `T` as one of its type arguments.</span></span> <span data-ttu-id="4288f-116">Sono incluse le raccolte generiche di `T`, anche se la raccolta è vuota.</span><span class="sxs-lookup"><span data-stu-id="4288f-116">This includes generic collections of `T`, even if that collection is empty.</span></span>

- <span data-ttu-id="4288f-117">Un'istanza di <xref:System.Type> o di <xref:System.Reflection.Emit.TypeBuilder> che rappresenta `T`.</span><span class="sxs-lookup"><span data-stu-id="4288f-117">An instance of <xref:System.Type> or <xref:System.Reflection.Emit.TypeBuilder> that represents `T`.</span></span> 

   > [!IMPORTANT]
   > <span data-ttu-id="4288f-118">È necessario rilasciare tutti gli oggetti che rappresentano parti dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4288f-118">You must release all objects that represent parts of the assembly.</span></span> <span data-ttu-id="4288f-119">Il <xref:System.Reflection.Emit.ModuleBuilder> che definisce `T` mantiene un riferimento a <xref:System.Reflection.Emit.TypeBuilder> e l'oggetto <xref:System.Reflection.Emit.AssemblyBuilder> mantiene un riferimento a <xref:System.Reflection.Emit.ModuleBuilder>, pertanto è necessario rilasciare i riferimenti a questi oggetti.</span><span class="sxs-lookup"><span data-stu-id="4288f-119">The <xref:System.Reflection.Emit.ModuleBuilder> that defines `T` keeps a reference to the <xref:System.Reflection.Emit.TypeBuilder>, and the <xref:System.Reflection.Emit.AssemblyBuilder> object keeps a reference to the <xref:System.Reflection.Emit.ModuleBuilder>, so references to these objects must be released.</span></span> <span data-ttu-id="4288f-120">Anche l'esistenza di un <xref:System.Reflection.Emit.LocalBuilder> o <xref:System.Reflection.Emit.ILGenerator> usato nella costruzione di `T` impedisce lo scaricamento.</span><span class="sxs-lookup"><span data-stu-id="4288f-120">Even the existence of a <xref:System.Reflection.Emit.LocalBuilder> or an <xref:System.Reflection.Emit.ILGenerator> used in the construction of `T` prevents unloading.</span></span>

- <span data-ttu-id="4288f-121">Un riferimento statico a `T` da un altro tipo definito in modo dinamico `T1` che è ancora raggiungibile mediante l'esecuzione del codice.</span><span class="sxs-lookup"><span data-stu-id="4288f-121">A static reference to `T` by another dynamically defined type `T1` that is still reachable by executing code.</span></span> <span data-ttu-id="4288f-122">Ad esempio, `T1` potrebbe derivare da `T` o `T` potrebbe essere il tipo di un parametro in un metodo di `T1`.</span><span class="sxs-lookup"><span data-stu-id="4288f-122">For example, `T1` might derive from `T`, or `T` might be the type of a parameter in a method of `T1`.</span></span>
 
- <span data-ttu-id="4288f-123">**ByRef** a un campo statico appartenente a `T`.</span><span class="sxs-lookup"><span data-stu-id="4288f-123">A **ByRef** to a static field that belongs to `T`.</span></span>

- <span data-ttu-id="4288f-124"><xref:System.RuntimeTypeHandle>, <xref:System.RuntimeFieldHandle> o <xref:System.RuntimeMethodHandle> che fa riferimento a `T` o a un componente di `T`.</span><span class="sxs-lookup"><span data-stu-id="4288f-124">A <xref:System.RuntimeTypeHandle>, <xref:System.RuntimeFieldHandle>, or <xref:System.RuntimeMethodHandle> that refers to `T` or to a component of `T`.</span></span>

- <span data-ttu-id="4288f-125">Un'istanza di qualsiasi oggetto di reflection che può essere usato indirettamente o direttamente per accedere all'oggetto <xref:System.Type> che rappresenta `T`.</span><span class="sxs-lookup"><span data-stu-id="4288f-125">An instance of any reflection object that could be used indirectly or directly to access the <xref:System.Type> object that represents `T`.</span></span> <span data-ttu-id="4288f-126">Ad esempio, l'oggetto <xref:System.Type> per `T` può essere ottenuto da un tipo di matrice il cui tipo di elemento è `T` o da un tipo generico che ha `T` come argomento di tipo.</span><span class="sxs-lookup"><span data-stu-id="4288f-126">For example, the <xref:System.Type> object for `T` can be obtained from an array type whose element type is `T`, or from a generic type that has `T` as a type argument.</span></span> 

- <span data-ttu-id="4288f-127">Un metodo `M` nello stack di chiamate di qualsiasi thread, in cui `M` è un metodo di `T` o un metodo a livello di modulo che viene definito nell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4288f-127">A method `M` on the call stack of any thread, where `M` is a method of `T` or a module-level method that is defined in the assembly.</span></span>

- <span data-ttu-id="4288f-128">Un delegato a un metodo statico definito in un modulo dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4288f-128">A delegate to a static method that is defined in a module of the assembly.</span></span>

<span data-ttu-id="4288f-129">Se esiste un solo elemento in questo elenco per un solo tipo o metodo nell'assembly, il runtime non è in grado di scaricare l'assembly.</span><span class="sxs-lookup"><span data-stu-id="4288f-129">If only one item from this list exists for only one type or one method in the assembly, the runtime cannot unload the assembly.</span></span>

> [!NOTE]
> <span data-ttu-id="4288f-130">Il runtime non scarica effettivamente l'assembly fino a quando non vengono eseguiti i finalizzatori per tutti gli elementi nell'elenco.</span><span class="sxs-lookup"><span data-stu-id="4288f-130">The runtime does not actually unload the assembly until finalizers have run for all items in the list.</span></span>

<span data-ttu-id="4288f-131">Per tener traccia della durata, si suppone che un tipo generico costruito, ad esempio `List<int>` (in C#) o `List(Of Integer)` (in Visual Basic), creato e usato nella generazione di un assembly ritirabile sia stato definito nell'assembly che contiene la definizione del tipo generico o in un assembly che contiene la definizione di uno dei relativi argomenti di tipo.</span><span class="sxs-lookup"><span data-stu-id="4288f-131">For purposes of tracking lifetime, a constructed generic type such as `List<int>` (in C#) or `List(Of Integer)` (in Visual Basic) that is created and used in the generation of a collectible assembly is considered to have been defined either in the assembly that contains the generic type definition or in an assembly that contains the definition of one of its type arguments.</span></span> <span data-ttu-id="4288f-132">L'assembly esatto usato è un dettaglio di implementazione e soggetto a modifiche.</span><span class="sxs-lookup"><span data-stu-id="4288f-132">The exact assembly that is used is an implementation detail and subject to change.</span></span>
 
## <a name="restrictions-on-collectible-assemblies"></a><span data-ttu-id="4288f-133">Limitazioni degli assembly ritirabili</span><span class="sxs-lookup"><span data-stu-id="4288f-133">Restrictions on collectible assemblies</span></span>

<span data-ttu-id="4288f-134">Agli assembly ritirabili si applicano le seguenti restrizioni:</span><span class="sxs-lookup"><span data-stu-id="4288f-134">The following restrictions apply to collectible assemblies:</span></span> 

- <span data-ttu-id="4288f-135">**Riferimenti statici** </span><span class="sxs-lookup"><span data-stu-id="4288f-135">**Static references** </span></span>  
  <span data-ttu-id="4288f-136">I tipi in un assembly dinamico comune non possono avere riferimenti statici a tipi definiti in un assembly ritirabile.</span><span class="sxs-lookup"><span data-stu-id="4288f-136">Types in an ordinary dynamic assembly cannot have static references to types that are defined in a collectible assembly.</span></span> <span data-ttu-id="4288f-137">Ad esempio, se si definisce un tipo comune che eredita da un tipo in un assembly ritirabile, viene generata un'eccezione <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="4288f-137">For example, if you define an ordinary type that inherits from a type in a collectible assembly, a <xref:System.NotSupportedException> exception is thrown.</span></span> <span data-ttu-id="4288f-138">Un tipo in un assembly ritirabile può avere riferimenti statici a un tipo in un altro assembly ritirabile, ma estende la durata dell'assembly di destinazione del riferimento alla durata dell'assembly di origine del riferimento.</span><span class="sxs-lookup"><span data-stu-id="4288f-138">A type in a collectible assembly can have static references to a type in another collectible assembly, but this extends the lifetime of the referenced assembly to the lifetime of the referencing assembly.</span></span>

- <span data-ttu-id="4288f-139">**Interoperabilità COM** </span><span class="sxs-lookup"><span data-stu-id="4288f-139">**COM interop** </span></span>  
   <span data-ttu-id="4288f-140">Nessuna interfaccia COM può essere definita all'interno di un assembly ritirabile e nessuna istanza di tipi all'interno di un assembly ritirabile può essere convertita in oggetti COM.</span><span class="sxs-lookup"><span data-stu-id="4288f-140">No COM interfaces can be defined within a collectible assembly, and no instances of types within a collectible assembly can be converted into COM objects.</span></span> <span data-ttu-id="4288f-141">Un tipo in un assembly ritirabile non può fungere da COM Callable Wrapper (CCW) o da Runtime Callable Wrapper (RCW).</span><span class="sxs-lookup"><span data-stu-id="4288f-141">A type in a collectible assembly cannot serve as a COM callable wrapper (CCW) or runtime callable wrapper (RCW).</span></span> <span data-ttu-id="4288f-142">Tuttavia, i tipi negli assembly ritirabili possono usare oggetti che implementano interfacce COM.</span><span class="sxs-lookup"><span data-stu-id="4288f-142">However, types in collectible assemblies can use objects that implement COM interfaces.</span></span>

- <span data-ttu-id="4288f-143">**Platform invoke** </span><span class="sxs-lookup"><span data-stu-id="4288f-143">**Platform invoke** </span></span>  
   <span data-ttu-id="4288f-144">I metodi con l'attributo <xref:System.Runtime.InteropServices.DllImportAttribute> non verranno compilati quando vengono dichiarati in un assembly ritirabile.</span><span class="sxs-lookup"><span data-stu-id="4288f-144">Methods that have the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute will not compile when they are declared in a collectible assembly.</span></span> <span data-ttu-id="4288f-145">Non è possibile usare l'istruzione <xref:System.Reflection.Emit.OpCodes.Calli?displayProperty=nameWithType> nell'implementazione di un tipo in un assembly ritirabile e non è possibile eseguire il marshalling di tali tipi in codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="4288f-145">The <xref:System.Reflection.Emit.OpCodes.Calli?displayProperty=nameWithType> instruction cannot be used in the implementation of a type in a collectible assembly, and such types cannot be marshaled to unmanaged code.</span></span> <span data-ttu-id="4288f-146">È comunque possibile effettuare chiamate nel codice nativo tramite un punto di ingresso dichiarato in un assembly non ritirabile.</span><span class="sxs-lookup"><span data-stu-id="4288f-146">However, you can call into native code by using an entry point that is declared in a non-collectible assembly.</span></span>
 
- <span data-ttu-id="4288f-147">**Marshalling** </span><span class="sxs-lookup"><span data-stu-id="4288f-147">**Marshaling** </span></span>  
   <span data-ttu-id="4288f-148">Gli oggetti, in particolare i delegati, definiti in assembly ritirabili non possono essere sottoposti a marshalling.</span><span class="sxs-lookup"><span data-stu-id="4288f-148">Objects (in particular, delegates) that are defined in collectible assemblies cannot be marshaled.</span></span> <span data-ttu-id="4288f-149">Si tratta di una restrizione per tutti i tipi creati temporanei.</span><span class="sxs-lookup"><span data-stu-id="4288f-149">This is a restriction on all transient emitted types.</span></span>

- <span data-ttu-id="4288f-150">**Caricamento degli assembly** </span><span class="sxs-lookup"><span data-stu-id="4288f-150">**Assembly loading** </span></span>  
   <span data-ttu-id="4288f-151">La reflection emit è l'unico meccanismo supportato per il caricamento degli assembly ritirabili.</span><span class="sxs-lookup"><span data-stu-id="4288f-151">Reflection emit is the only mechanism that is supported for loading collectible assemblies.</span></span> <span data-ttu-id="4288f-152">Gli assembly caricati con qualsiasi altra forma di caricamento non possono essere scaricati.</span><span class="sxs-lookup"><span data-stu-id="4288f-152">Assemblies that are loaded by using any other form of assembly loading cannot be unloaded.</span></span>
 
- <span data-ttu-id="4288f-153">**Oggetti legati al contesto**  </span><span class="sxs-lookup"><span data-stu-id="4288f-153">**Context-bound objects**  </span></span>  
   <span data-ttu-id="4288f-154">Le variabili statiche a livello di contesto non sono supportate.</span><span class="sxs-lookup"><span data-stu-id="4288f-154">Context-static variables are not supported.</span></span> <span data-ttu-id="4288f-155">Non è possibile estendere i tipi in un assembly ritirabile <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="4288f-155">Types in a collectible assembly cannot extend <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="4288f-156">Tuttavia, il codice negli assembly ritirabili può usare oggetti associati al contesto definiti altrove.</span><span class="sxs-lookup"><span data-stu-id="4288f-156">However, code in collectible assemblies can use context-bound objects that are defined elsewhere.</span></span>

- <span data-ttu-id="4288f-157">**Dati statici a livello di thread**     </span><span class="sxs-lookup"><span data-stu-id="4288f-157">**Thread-static data**     </span></span>  
   <span data-ttu-id="4288f-158">Le variabili statiche a livello di thread non sono supportate.</span><span class="sxs-lookup"><span data-stu-id="4288f-158">Thread-static variables are not supported.</span></span>

## <a name="see-also"></a><span data-ttu-id="4288f-159">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="4288f-159">See also</span></span>

- [<span data-ttu-id="4288f-160">Creazione di assembly e metodi dinamici</span><span class="sxs-lookup"><span data-stu-id="4288f-160">Emitting Dynamic Methods and Assemblies</span></span>](emitting-dynamic-methods-and-assemblies.md)
