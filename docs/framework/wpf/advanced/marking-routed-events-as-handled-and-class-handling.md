---
title: Impostazione degli eventi indirizzati come gestiti e gestione delle classi
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: a1004ce10baf6293c4c93efc61b91b3b6361377f
ms.sourcegitcommit: eaa6d5cd0f4e7189dbe0bd756e9f53508b01989e
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/07/2019
ms.locfileid: "67610376"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a>Impostazione degli eventi indirizzati come gestiti e gestione delle classi
I gestori per un evento indirizzato possono contrassegnare l'evento come gestito all'interno dei dati dell'evento. La gestione dell'evento abbrevia efficacemente la route. La gestione delle classi è un concetto di programmazione supportato dagli eventi indirizzati. Un gestore classi ha l'opportunità di gestire un evento indirizzato specifico a livello di classe con un gestore richiamato prima di qualsiasi gestore istanze in qualsiasi istanza di classe.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Prerequisiti  
 Questo argomento elabora i concetti introdotti in [Cenni preliminari sugli eventi indirizzati](routed-events-overview.md).  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a>Quando contrassegnare eventi come gestiti  
 Quando si imposta il valore della <xref:System.Windows.RoutedEventArgs.Handled%2A> proprietà `true` nell'evento dati per un evento indirizzato, ciò è detto "contrassegnare l'evento come gestito". Non esiste una regola assoluta riguardo a quando contrassegnare gli eventi indirizzati come gestiti, né per un autore di applicazioni né per un autore di controlli che risponde a eventi indirizzati esistenti o implementa nuovi eventi indirizzati. Per la maggior parte dei casi, il concetto di "gestito" se applicato ai dati dell'evento indirizzato deve essere usato come protocollo limitato per le risposte dell'applicazione a diversi eventi indirizzati esposti nelle [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], nonché per tutti gli eventi indirizzati personalizzati. Un altro modo di considerare il concetto di "gestito" è che in genere è necessario contrassegnare un evento indirizzato come gestito se il codice ha risposto all'evento indirizzato in modo significativo e relativamente completo. In genere, deve essere presente una sola risposta significativa che richiede implementazioni del gestore separate per qualsiasi singola occorrenza di un evento indirizzato. Se sono necessarie più risposte, il codice richiesto deve essere implementato tramite logica dell'applicazione concatenata a un singolo gestore, anziché usare il sistema degli eventi indirizzati per l'inoltro. Anche il concetto di "significativo" è soggettivo e dipende dall'applicazione o dal codice. Come indicazione generale, ecco alcuni esempi di "risposta significativa": impostazione dello stato attivo, modifica dello stato pubblico, impostazione delle proprietà che influiscono sulla rappresentazione visiva e generazione di altri nuovi eventi. Ecco inoltre alcuni esempi di risposte non significative: modifica dello stato privato (senza alcun impatto visivo o sulla rappresentazione programmatica), registrazione di eventi o esame degli argomenti di un evento e scelta di non rispondervi.  
  
 Il comportamento del sistema eventi indirizzati rafforza questo modello di "risposta significativa" per l'uso dello stato gestito di un evento indirizzato, perché i gestori aggiunti in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] o la firma comune di <xref:System.Windows.UIElement.AddHandler%2A> non vengono richiamati in risposta a un evento indirizzato in cui l'evento i dati sono già contrassegnato come gestiti. È necessario eseguire un'ulteriore operazione di aggiunta di un gestore con la `handledEventsToo` versione del parametro (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) per gestire gli eventi indirizzati contrassegnati come gestiti da partecipanti precedenti nella route dell'evento.  
  
 In alcuni casi, i controlli stessi contrassegnano determinati eventi indirizzati come gestiti. Un evento indirizzato gestito rappresenta una decisione da parte degli autori di controlli [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] in base alla quale le azioni del controllo in risposta all'evento indirizzato sono significative o complete come parte dell'implementazione del controllo e che l'evento non richiede gestione aggiuntiva. Questo avviene in genere aggiungendo un gestore classi per un evento oppure eseguendo l'override di uno dei metodi virtuali del gestore classi presenti in una classe base. Se necessario, è comunque possibile trovare soluzioni alternative per questa gestione degli eventi. Vedere [Soluzioni alternative all'eliminazione di eventi da parte dei controlli](#WorkingAroundEventSuppressionByControls) più avanti in questo argomento.  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a>Confronto tra eventi (di tunneling) "di anteprima" ed eventi di bubbling e gestione degli eventi  
 Gli eventi indirizzati di anteprima sono eventi che seguono una route di tunneling attraverso l'albero degli elementi. Il termine "anteprima" usato nella convenzione di denominazione è indicativo del principio generale per gli eventi di input in base al quale gli eventi indirizzati (di tunneling) di anteprima vengono generati prima dell'evento indirizzato di bubbling equivalente. Inoltre, gli eventi indirizzati di input dotati di una coppia di tunneling e bubbling hanno una logica di gestione distinta. Se l'evento indirizzato di tunneling/anteprima viene contrassegnato come gestito da un listener di eventi, l'evento indirizzato di bubbling verrà contrassegnato come gestito anche prima che qualsiasi listener dell'evento indirizzato di bubbling lo riceva. Gli eventi indirizzati di tunneling e bubbling sono tecnicamente eventi separati, ma condividono intenzionalmente la stessa istanza dei dati degli eventi per permettere questo comportamento.  
  
 La connessione tra gli eventi indirizzati di tunneling e bubbling viene eseguita tramite l'implementazione interna del modo in cui ogni classe [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifica genera i propri eventi indirizzati dichiarati e questo avviene per gli eventi indirizzati di input associati. Tuttavia, se questa implementazione a livello di classe non esiste, non vi è alcuna connessione tra un evento indirizzato di tunneling e un evento indirizzato di bubbling che condividono lo schema di denominazione: senza questa implementazione, i due eventi indirizzati sono completamente separati e non vengono generati in sequenza né condividono i dati degli eventi.  
  
 Per altre informazioni su come implementare coppie di eventi indirizzati di input di tunneling/bubbling in una classe personalizzata, vedere [Creare un evento indirizzato personalizzato](how-to-create-a-custom-routed-event.md).  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a>Gestori classi e gestori istanze  
 Gli eventi indirizzati considerano due tipi diversi di listener per l'evento: listener di classi e listener di istanze. I listener di classe esistano perché i tipi hanno chiamato un determinato <xref:System.Windows.EventManager> API,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, nel proprio costruttore statico o hanno eseguito l'override di un metodo virtuale del gestore della classe dalla classe di base di un elemento. Listener di istanze sono istanze/elementi di classe specifico in cui sono stati associati uno o più gestori per l'evento indirizzato da una chiamata a <xref:System.Windows.UIElement.AddHandler%2A>. Esistente [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] gli eventi indirizzati di effettuano chiamate a <xref:System.Windows.UIElement.AddHandler%2A> come parte delle [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] wrapper di eventi aggiungere{} e rimuovere{} implementazioni dell'evento, vale a dire anche come il semplice [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] meccanismo di collegamento i gestori di eventi tramite una sintassi per attributi è abilitata. Pertanto, anche il semplice [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] utilizzo equivale in definitiva a una <xref:System.Windows.UIElement.AddHandler%2A> chiamare.  
  
 Gli elementi all'interno dell'albero visuale vengono controllati per individuare le eventuali implementazioni di gestori registrati. I gestori vengono potenzialmente richiamati lungo la route, nell'ordine ereditato nel tipo della strategia di routing per l'evento indirizzato specifico. Ad esempio, gli eventi indirizzati di bubbling richiameranno prima di tutto i gestori collegati allo stesso elemento che ha generato l'evento indirizzato. L'evento indirizzato viene propagato al successivo elemento padre e così via fino a raggiungere l'elemento radice dell'applicazione.  
  
 Dal punto di vista dell'elemento radice in una route di bubbling, se la gestione delle classi o qualsiasi elemento più vicino all'origine dell'evento indirizzato richiama gestori che contrassegnano gli argomenti dell'evento come gestiti, i gestori negli elementi radice non vengono richiamati e la route dell'evento viene abbreviata in modo efficace prima di raggiungere l'elemento radice. Tuttavia, la route non viene completamente interrotta, perché è possibile aggiungere gestori con una speciale condizione in base alla quale devono comunque essere richiamati, anche se un gestore classi o un gestore istanze ha contrassegnato l'evento indirizzato come gestito. Questo comportamento viene descritto in [Aggiunta di gestori istanze generati anche se gli eventi sono contrassegnati come gestiti](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled) più avanti in questo argomento.  
  
 A un livello più profondo rispetto a quello della route degli eventi esistono potenzialmente anche più gestori classi che agiscono su qualsiasi istanza specifica di una classe. Questo avviene perché il modello di gestione delle classi per eventi indirizzati permette a tutte le possibili classi in una gerarchia di classi di registrare ciascuna il proprio gestore classi per ogni evento indirizzato. Ogni gestore classi viene aggiunto a un archivio interno e quando viene creata la route degli eventi per un'applicazione, i gestori classi vengono tutti aggiunti alla route. I gestori classi vengono aggiunti alla route in modo che venga richiamato per primo il gestore della classe più derivata, richiamando quindi i gestori classi da ogni classe base successiva. In genere i gestori classi non sono registrati in modo da rispondere anche a eventi indirizzati già contrassegnati come gestiti. Di conseguenza, questo meccanismo di gestione delle classi permette di scegliere tra due opzioni:  
  
- Le classi derivate possono completare la gestione delle classi ereditata dalla classe base aggiungendo un gestore che non contrassegna l'evento indirizzato come gestito, perché il gestore della classe base verrà richiamato in un momento successivo al gestore delle classi derivate.  
  
- Le classi derivate possono sostituire la gestione delle classi dalla classe base tramite l'aggiunta di un gestore classi che contrassegna l'evento indirizzato come gestito. È necessario usare questo approccio con cautela, perché potrebbe modificare la progettazione dei controlli di base desiderata, ad esempio in aree come l'aspetto visivo, la logica di stato, la gestione degli input e la gestione dei comandi.  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a>Gestione delle classi degli eventi indirizzati tramite classi di base dei controlli  
 Nel nodo di ogni elemento specifico in una route di eventi i listener di classi possono rispondere all'evento indirizzato prima di qualsiasi listener di istanze per l'elemento. Per questo motivo, i gestori classi vengono usati talvolta per eliminare gli eventi indirizzati che l'implementazione di una determinata classe di controlli non desidera propagare ulteriormente oppure per fornire una gestione speciale dell'evento indirizzato che è una caratteristica della classe. Ad esempio, una classe potrebbe generare il proprio evento specifico della classe che contiene più specifiche sul significato di una certa condizione di input utente nel contesto di una determinata classe. L'implementazione della classe potrebbe quindi contrassegnare come gestito l'evento indirizzato più generale. I gestori classi vengono generalmente aggiunti in modo che non vengano richiamati per instradati gli eventi in cui i dati degli eventi condivisi sono già stati contrassegnati come gestiti, ma per alcuni casi è inoltre disponibile un <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> firma che registra i gestori classi per richiamare anche se non sono eventi indirizzati contrassegnato come gestito.  
  
### <a name="class-handler-virtuals"></a>Metodi virtuali dei gestori classi  
 Alcuni elementi, in particolare gli elementi di base, ad esempio <xref:System.Windows.UIElement>, espongono vuoto "in * evento" e "OnPreview\*evento" metodi virtuali che corrispondono al rispettivo elenco degli eventi indirizzati pubblici. È possibile eseguire l'override di questi metodi virtuali per implementare un gestore classi per l'evento indirizzato. Le classi di elementi di base registrano questi metodi virtuali come gestori classi per ognuno di tali basata sul routing di eventi utilizzando <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> come descritto in precedenza. I metodi virtuali On\*Event semplificano notevolmente l'implementazione della gestione delle classi per gli eventi indirizzati pertinenti, senza richiedere attività di inizializzazione speciali nei costruttori statici per ogni tipo. Ad esempio, è possibile aggiungere la gestione delle classi il <xref:System.Windows.UIElement.DragEnter> eventi in uno <xref:System.Windows.UIElement> classe derivata eseguendo l'override di <xref:System.Windows.UIElement.OnDragEnter%2A> metodo virtuale. All'interno dell'override è possibile gestire l'evento indirizzato, generare altri eventi, avviare una logica specifica della classe che può modificare le proprietà degli elementi nelle istanze o scegliere qualsiasi combinazione di queste azioni. È in genere consigliabile chiamare l'implementazione base in questi override, anche se si contrassegna l'evento come gestito. La chiamata dell'implementazione base è fortemente consigliata perché il metodo virtuale è incluso nella classe base. Il modello virtuale protetto standard costituito dalla chiamata delle implementazioni base da ogni metodo virtuale essenzialmente sostituisce ed eguaglia un meccanismo simile che è nativo per la gestione delle classi degli eventi indirizzati, in cui i gestori classi per tutte le classi in una gerarchia di classi vengono chiamati in qualsiasi istanza specifica, a partire dal gestore della classe più derivata e continuando fino al gestore della classe base. È necessario omettere la chiamata dell'implementazione base solo se la classe prevede un requisito intenzionale relativo alla modifica della logica di gestione delle classi base. Se si chiamerà l'implementazione base prima o dopo l'override del codice dipende dalla natura dell'implementazione.  
  
#### <a name="input-event-class-handling"></a>Gestione delle classi degli eventi di input  
 I metodi virtuali dei gestori classi vengono tutti registrati in modo da essere richiamati solo in presenza di dati degli eventi condivisi che non sono già stati contrassegnati come gestiti. Inoltre, solo per gli eventi di input, le versioni di tunneling e bubbling vengono normalmente generate in sequenza e condividono i dati degli eventi. Di conseguenza, per una specifica coppia di gestori classi di eventi di input in cui uno corrisponde alla versione di tunneling e l'altro alla versione di bubbling, si potrebbe non voler contrassegnare immediatamente l'evento come gestito. Se si implementa il metodo virtuale della gestione delle classi di tunneling per contrassegnare l'evento come gestito, si impedirà al gestore classi di bubbling di essere richiamato, oltre a impedire la chiamata dei gestori istanze normalmente registrati per l'evento di tunneling o di bubbling.  
  
 Quando la gestione delle classi in un nodo è completa, vengono presi in considerazione i listener di istanze.  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a>Aggiunta di gestori istanze generati anche se gli eventi sono contrassegnati come gestiti  
 Il <xref:System.Windows.UIElement.AddHandler%2A> metodo fornisce un overload specifico che consente di aggiungere gestori che verranno richiamati dal sistema degli eventi ogni volta che un evento raggiunge l'elemento di gestione nella route, anche se un altro gestore ha già modificato i dati dell'evento per contrassegnare che evento come gestito. Questo non è il comportamento più comune. In genere, i gestori possono essere scritti in modo da modificare tutte le aree del codice dell'applicazione che potrebbero essere influenzate da un evento, indipendentemente dal punto in cui questo è stato gestito nell'albero degli elementi, anche nei casi in cui si desiderano più risultati finali. Inoltre, in genere, un solo elemento deve rispondere all'evento e la logica dell'applicazione appropriata è già stata applicata. Tuttavia, è disponibile l'overload `handledEventsToo` per i casi eccezionali in cui un altro elemento in un albero di elementi o in una composizione di controlli ha già contrassegnato un evento come gestito, ma altri elementi in posizione superiore o inferiore nell'albero degli elementi (a seconda della route) vogliono comunque che i rispettivi gestori vengano richiamati.  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a>Quando contrassegnare eventi gestiti come non gestiti  
 In generale, gli eventi indirizzati contrassegnati come gestiti non devono essere contrassegnati come non gestiti (<xref:System.Windows.RoutedEventArgs.Handled%2A> reimpostato `false`) anche da gestori che agiscono su `handledEventsToo`. Tuttavia, alcuni eventi di input hanno rappresentazioni di eventi di alto livello e di livello inferiore che possono sovrapporsi quando l'evento di alto livello viene visualizzato in una posizione nell'albero e quello di basso livello viene visualizzato in un'altra posizione. Ad esempio, si consideri il caso in cui un elemento figlio è in attesa di un evento di tasto ad alto livello, ad esempio <xref:System.Windows.UIElement.TextInput> mentre un elemento padre è in ascolto, ad esempio a un evento di basso livello <xref:System.Windows.UIElement.KeyDown>. Se l'elemento padre gestisce l'evento di basso livello, l'evento di livello superiore può essere eliminato anche nell'elemento figlio che dovrebbe avere la prima opportunità di gestire l'evento.  
  
 In queste situazioni può essere necessario aggiungere gestori sia agli elementi padre sia agli elementi figlio per l'evento di basso livello. L'implementazione del gestore dell'elemento figlio può contrassegnare l'evento di basso livello come gestito, ma l'implementazione del gestore dell'elemento padre lo imposterebbe di nuovo come non gestito per permettere ad altri elementi di livello superiore nell'albero (nonché all'evento di alto livello) di rispondere. Questa situazione dovrebbe essere piuttosto rara.  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a>Eliminazione intenzionale di eventi di input per la composizione dei controlli  
 Lo scenario principale in cui viene usata la gestione delle classi per eventi indirizzati riguarda gli eventi di input e i controlli compositi. Un controllo composito è per definizione composto da più controlli pratici o classi base di controlli. Spesso l'autore del controllo desidera comporre in modo uniforme tutti i possibili eventi di input che possono essere generati da ognuno dei sottocomponenti, per segnalare l'intero controllo come singola origine evento. In alcuni casi, l'autore del controllo potrebbe desiderare di eliminare interamente gli eventi dai componenti oppure sostituire un evento definito da un componente che contiene più informazioni o implica un comportamento più specifico. L'esempio classico immediatamente evidente a qualsiasi autore di componenti è come una [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> gestisce qualsiasi evento del mouse che verrà risolto nell'evento intuitivo tutti i pulsanti: un <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento.  
  
 Il <xref:System.Windows.Controls.Button> classe di base (<xref:System.Windows.Controls.Primitives.ButtonBase>) deriva da <xref:System.Windows.Controls.Control> che a sua volta deriva da <xref:System.Windows.FrameworkElement> e <xref:System.Windows.UIElement>e gran parte dell'infrastruttura di evento necessaria per l'elaborazione dell'input del controllo è disponibile all'indirizzo il <xref:System.Windows.UIElement> livello. In particolare <xref:System.Windows.UIElement> elabora generali <xref:System.Windows.Input.Mouse> eventi che gestiscono gli hit test per il cursore del mouse all'interno dei limiti e fornisce eventi distinti per i più comuni sul pulsante azioni, ad esempio <xref:System.Windows.UIElement.MouseLeftButtonDown>. <xref:System.Windows.UIElement> fornisce inoltre un oggetto virtuale vuoto <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> come il gestore classi preregistrato <xref:System.Windows.UIElement.MouseLeftButtonDown>, e <xref:System.Windows.Controls.Primitives.ButtonBase> ne esegue l'override. Analogamente, <xref:System.Windows.Controls.Primitives.ButtonBase> Usa gestori di classi per <xref:System.Windows.UIElement.MouseLeftButtonUp>. Nell'override, a cui vengono passati i dati dell'evento, le implementazioni contrassegnano che <xref:System.Windows.RoutedEventArgs> dell'istanza come gestita impostando <xref:System.Windows.RoutedEventArgs.Handled%2A> a `true`, e che i dati dell'evento stesso sono continuano lungo il resto della route da altri gestori di classi e anche a gestori istanze o setter di eventi. Inoltre, il <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> override successivamente genererà il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento. Il risultato finale per la maggior parte dei listener sarà che il <xref:System.Windows.UIElement.MouseLeftButtonDown> e <xref:System.Windows.UIElement.MouseLeftButtonUp> eventi "scompaiono" e la relativa sostituzione con <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, un evento più significativo poiché è noto che questo evento ha avuto origine da un pulsante true e non solo alcuni composito di parti del pulsante o da un altro elemento interamente.  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a>Soluzioni alternative all'eliminazione di eventi da parte dei controlli  
 A volte questo comportamento di eliminazione di eventi all'interno di singoli controlli può interferire con alcune intenzioni più generali della logica di gestione degli eventi per l'applicazione. Ad esempio, se per qualche motivo l'applicazione include un gestore per <xref:System.Windows.UIElement.MouseLeftButtonDown> si trova in corrispondenza dell'elemento radice dell'applicazione, è possibile notare che qualsiasi clic del mouse su un pulsante non richiama <xref:System.Windows.UIElement.MouseLeftButtonDown> o <xref:System.Windows.UIElement.MouseLeftButtonUp> gestori eventi a livello di radice. L'evento stesso è stato effettivamente propagato. Come già detto, le route degli eventi non vengono davvero completate, ma il sistema degli eventi indirizzati ne modifica il comportamento di chiamata del gestore dopo che gli eventi sono stati contrassegnati come gestiti. Quando l'evento indirizzato raggiunge il pulsante, il <xref:System.Windows.Controls.Primitives.ButtonBase> la gestione delle classi contrassegnato il <xref:System.Windows.UIElement.MouseLeftButtonDown> gestito perché per sostituire il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventi con maggiore significato. Pertanto, qualsiasi standard <xref:System.Windows.UIElement.MouseLeftButtonDown> gestore più avanzato le route non viene richiamato. Esistono due tecniche che è possibile usare per garantire che i gestori vengano richiamati in questo caso.  
  
 La prima tecnica consiste nell'aggiungere intenzionalmente il gestore usando il `handledEventsToo` firma dei <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>. Una limitazione di questo approccio è che la tecnica di collegamento di un gestore eventi è possibile solo dal codice, non dal markup. La semplice sintassi per specificare il nome del gestore eventi come valore di attributo dell'evento tramite [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] non permette questo comportamento.  
  
 La seconda tecnica può essere usata solo per gli eventi di input, le cui versioni di tunneling e bubbling dell'evento indirizzato sono associate. Per questi eventi indirizzati, è invece possibile aggiungere gestori all'evento indirizzato di anteprima/tunneling equivalente. Poiché l'evento indirizzato percorre tramite tunneling la route a partire dalla radice, il codice di gestione delle classi del pulsante non lo intercetta, presumendo che il gestore di anteprima sia stato collegato a livello di un elemento predecessore nell'albero degli elementi dell'applicazione. Se si usa questo approccio, contrassegnare con cautela qualsiasi evento di anteprima come gestito. Per l'esempio fornito con <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> gestito nell'elemento radice, se è stata contrassegnata come dell'evento <xref:System.Windows.RoutedEventArgs.Handled%2A> nell'implementazione del gestore, verrà in realtà eliminato il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento. Questo non è un comportamento consigliato.  
  
## <a name="see-also"></a>Vedere anche

- <xref:System.Windows.EventManager>
- [Eventi di anteprima](preview-events.md)
- [Creare un evento indirizzato personalizzato](how-to-create-a-custom-routed-event.md)
- [Cenni preliminari sugli eventi indirizzati](routed-events-overview.md)
