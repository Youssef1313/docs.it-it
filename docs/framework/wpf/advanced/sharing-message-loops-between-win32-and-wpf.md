---
title: Condivisione dei cicli di messaggi tra Win32 e WPF
ms.date: 03/30/2017
helpviewer_keywords:
- Win32 code [WPF], sharing message loops
- message loops [WPF]
- sharing message loops [WPF]
- interoperability [WPF], Win32
ms.assetid: 39ee888c-e5ec-41c8-b11f-7b851a554442
ms.openlocfilehash: 31efc6e514682502e91487565869285dad22cab0
ms.sourcegitcommit: 83ecdf731dc1920bca31f017b1556c917aafd7a0
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/12/2019
ms.locfileid: "67860014"
---
# <a name="sharing-message-loops-between-win32-and-wpf"></a><span data-ttu-id="5f1d1-102">Condivisione dei cicli di messaggi tra Win32 e WPF</span><span class="sxs-lookup"><span data-stu-id="5f1d1-102">Sharing Message Loops Between Win32 and WPF</span></span>
<span data-ttu-id="5f1d1-103">In questo argomento descrive come implementare un ciclo di messaggi per essere interoperabile con i [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], tramite l'utilizzo esistente del messaggio l'esposizione di ciclo in <xref:System.Windows.Threading.Dispatcher> o tramite la creazione di un ciclo di messaggi separate nel [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] lato del codice di interoperabilità.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-103">This topic describes how to implement a message loop for interoperation with [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], either by using existing message loop exposure in <xref:System.Windows.Threading.Dispatcher> or by creating a separate message loop on the [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] side of your interoperation code.</span></span>  
  
## <a name="componentdispatcher-and-the-message-loop"></a><span data-ttu-id="5f1d1-104">ComponentDispatcher e il ciclo di messaggi</span><span class="sxs-lookup"><span data-stu-id="5f1d1-104">ComponentDispatcher and the Message Loop</span></span>  
 <span data-ttu-id="5f1d1-105">Uno scenario comune di supporto per gli eventi della tastiera e interoperabilità consiste nell'implementare <xref:System.Windows.Interop.IKeyboardInputSink>, o di sottoclassi da classi che implementano già <xref:System.Windows.Interop.IKeyboardInputSink>, ad esempio <xref:System.Windows.Interop.HwndSource> o <xref:System.Windows.Interop.HwndHost>.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-105">A normal scenario for interoperation and keyboard event support is to implement <xref:System.Windows.Interop.IKeyboardInputSink>, or to subclass from classes that already implement <xref:System.Windows.Interop.IKeyboardInputSink>, such as <xref:System.Windows.Interop.HwndSource> or <xref:System.Windows.Interop.HwndHost>.</span></span> <span data-ttu-id="5f1d1-106">Tuttavia, il supporto di sink della tastiera non si applica tutte le esigenze di ciclo di messaggi possibili che possono verificarsi quando l'invio e ricezione dei messaggi attraverso i limiti di interoperatività.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-106">However, keyboard sink support does not address all possible message loop needs you might have when sending and receiving messages across your interoperation boundaries.</span></span> <span data-ttu-id="5f1d1-107">Per formalizzare un'architettura di ciclo di messaggi dell'applicazione, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] fornisce il <xref:System.Windows.Interop.ComponentDispatcher> (classe), che definisce un protocollo semplice per un ciclo di messaggi da seguire.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-107">To help formalize an application message loop architecture, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] provides the <xref:System.Windows.Interop.ComponentDispatcher> class, which defines a simple protocol for a message loop to follow.</span></span>  
  
 <span data-ttu-id="5f1d1-108"><xref:System.Windows.Interop.ComponentDispatcher> è una classe statica che espone vari membri.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-108"><xref:System.Windows.Interop.ComponentDispatcher> is a static class that exposes several members.</span></span> <span data-ttu-id="5f1d1-109">L'ambito di ogni metodo in modo implicito è associato al thread chiamante.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-109">The scope of each method is implicitly tied to the calling thread.</span></span> <span data-ttu-id="5f1d1-110">Un ciclo di messaggi è necessario chiamare alcuni di tali API nei momenti critici (come definito nella sezione successiva).</span><span class="sxs-lookup"><span data-stu-id="5f1d1-110">A message loop must call some of those APIs at critical times (as defined in the next section).</span></span>  
  
 <span data-ttu-id="5f1d1-111"><xref:System.Windows.Interop.ComponentDispatcher> fornisce gli eventi che possono essere in ascolto altri componenti (ad esempio, il sink della tastiera).</span><span class="sxs-lookup"><span data-stu-id="5f1d1-111"><xref:System.Windows.Interop.ComponentDispatcher> provides events that other components (such as the keyboard sink) can listen for.</span></span> <span data-ttu-id="5f1d1-112">Il <xref:System.Windows.Threading.Dispatcher> classe chiamate tutte appropriate <xref:System.Windows.Interop.ComponentDispatcher> metodi in una sequenza appropriata.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-112">The <xref:System.Windows.Threading.Dispatcher> class calls all the appropriate <xref:System.Windows.Interop.ComponentDispatcher> methods in an appropriate sequence.</span></span> <span data-ttu-id="5f1d1-113">Se si implementa il proprio ciclo di messaggi, il codice è responsabile della chiamata <xref:System.Windows.Interop.ComponentDispatcher> metodi in modo analogo.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-113">If you are implementing your own message loop, your code is responsible for calling <xref:System.Windows.Interop.ComponentDispatcher> methods in a similar fashion.</span></span>  
  
 <span data-ttu-id="5f1d1-114">La chiamata a <xref:System.Windows.Interop.ComponentDispatcher> metodi su un thread solo richiama gestori di eventi che sono stati registrati in tale thread.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-114">Calling <xref:System.Windows.Interop.ComponentDispatcher> methods on a thread will only invoke event handlers that were registered on that thread.</span></span>  
  
## <a name="writing-message-loops"></a><span data-ttu-id="5f1d1-115">Cicli di messaggi di scrittura</span><span class="sxs-lookup"><span data-stu-id="5f1d1-115">Writing Message Loops</span></span>  
 <span data-ttu-id="5f1d1-116">Di seguito è riportato un elenco di controllo <xref:System.Windows.Interop.ComponentDispatcher> membri che è necessario utilizzare per scrivere il proprio ciclo di messaggi:</span><span class="sxs-lookup"><span data-stu-id="5f1d1-116">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you write your own message loop:</span></span>  
  
- <span data-ttu-id="5f1d1-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: il ciclo di messaggi deve chiamare questo metodo per indicare che il thread è modale.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: your message loop should call this to indicate that the thread is modal.</span></span>  
  
- <span data-ttu-id="5f1d1-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>: il ciclo di messaggi deve chiamare questo metodo per indicare che il thread è stato ripristinato allo stato non modale.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>:your message loop should call this to indicate that the thread has reverted to nonmodal.</span></span>  
  
- <span data-ttu-id="5f1d1-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: deve chiamare questo metodo per indicare che il ciclo di messaggi <xref:System.Windows.Interop.ComponentDispatcher> deve generare il <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> evento.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: your message loop should call this to indicate that <xref:System.Windows.Interop.ComponentDispatcher> should raise the <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> event.</span></span> <span data-ttu-id="5f1d1-120"><xref:System.Windows.Interop.ComponentDispatcher> non genererà <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> se <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> viene `true`, ma i cicli di messaggi possono scegliere di chiamare <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> anche se <xref:System.Windows.Interop.ComponentDispatcher> non può rispondere se si trova nello stato modale.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-120"><xref:System.Windows.Interop.ComponentDispatcher> will not raise <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> if <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> is `true`, but message loops may choose to call <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> even if <xref:System.Windows.Interop.ComponentDispatcher> cannot respond to it while in modal state.</span></span>  
  
- <span data-ttu-id="5f1d1-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: il ciclo di messaggi deve chiamare questo metodo per indicare che è disponibile un nuovo messaggio.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: your message loop should call this to indicate that a new message is available.</span></span> <span data-ttu-id="5f1d1-122">Il valore restituito indica se un listener per un <xref:System.Windows.Interop.ComponentDispatcher> il messaggio di evento gestito.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-122">The return value indicates whether a listener to a <xref:System.Windows.Interop.ComponentDispatcher> event handled the message.</span></span> <span data-ttu-id="5f1d1-123">Se <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> restituisce `true` (gestito), il dispatcher deve eseguire altre operazioni con il messaggio.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-123">If <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> returns `true` (handled), the dispatcher should do nothing further with the message.</span></span> <span data-ttu-id="5f1d1-124">Se il valore restituito sarà `false`, il dispatcher per chiamare il [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] funzione `TranslateMessage`, quindi chiamare `DispatchMessage`.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-124">If the return value is `false`, the dispatcher is expected to call the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] function `TranslateMessage`, then call `DispatchMessage`.</span></span>  
  
## <a name="using-componentdispatcher-and-existing-message-handling"></a><span data-ttu-id="5f1d1-125">Usando ComponentDispatcher e con la gestione dei messaggi</span><span class="sxs-lookup"><span data-stu-id="5f1d1-125">Using ComponentDispatcher and Existing Message Handling</span></span>  
 <span data-ttu-id="5f1d1-126">Di seguito è riportato un elenco di controllo <xref:System.Windows.Interop.ComponentDispatcher> membri utilizzerà se ci si affida l'intrinseca [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] loop di messaggi.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-126">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you rely on the inherent [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] message loop.</span></span>  
  
- <span data-ttu-id="5f1d1-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: restituisce se l'applicazione è diventato modale (ad esempio, un ciclo modale di messaggio è stato eseguito il push).</span><span class="sxs-lookup"><span data-stu-id="5f1d1-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: returns whether the application has gone modal (e.g., a modal message loop has been pushed).</span></span> <span data-ttu-id="5f1d1-128"><xref:System.Windows.Interop.ComponentDispatcher> può rilevare questo stato perché la classe gestisce un conteggio dei <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> e <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> chiamate dal ciclo di messaggi.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-128"><xref:System.Windows.Interop.ComponentDispatcher> can track this state because the class maintains a count of <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> and <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> calls from the message loop.</span></span>  
  
- <span data-ttu-id="5f1d1-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> e <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> eventi conformi alle regole standard per le chiamate del delegato.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> and <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> events follow the standard rules for delegate invocations.</span></span> <span data-ttu-id="5f1d1-130">I delegati vengono richiamati in un ordine non specificato e tutti i delegati vengono richiamati anche se il primo contrassegna il messaggio come gestito.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-130">Delegates are invoked in an unspecified order, and all delegates are invoked even if the first one marks the message as handled.</span></span>  
  
- <span data-ttu-id="5f1d1-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: indica un tempo appropriato ed efficiente per l'elaborazione inattiva (non sono presenti altri messaggi in sospeso per il thread).</span><span class="sxs-lookup"><span data-stu-id="5f1d1-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: indicates an appropriate and efficient time to do idle processing (there are no other pending messages for the thread).</span></span> <span data-ttu-id="5f1d1-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> non essere generato se il thread è modale.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> will not be raised if the thread is modal.</span></span>  
  
- <span data-ttu-id="5f1d1-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: generati per tutti i messaggi che elabora il message pump.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: raised for all messages that the message pump processes.</span></span>  
  
- <span data-ttu-id="5f1d1-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: generati per tutti i messaggi che non sono stati gestiti durante <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: raised for all messages that were not handled during <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span></span>  
  
 <span data-ttu-id="5f1d1-135">Un messaggio viene considerato gestito se dopo il <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> evento o <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> evento, il `handled` parametro passato per riferimento nei dati dell'evento è `true`.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-135">A message is considered handled if after the <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> event or <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> event, the `handled` parameter passed by reference in event data is `true`.</span></span> <span data-ttu-id="5f1d1-136">I gestori eventi devono ignorare il messaggio se `handled` è `true`, perché ciò significa che il messaggio è stato gestito prima di tutto il gestore diverso.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-136">Event handlers should ignore the message if `handled` is `true`, because that means the different handler handled the message first.</span></span> <span data-ttu-id="5f1d1-137">I gestori di eventi sia per gli eventi possono modificare il messaggio.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-137">Event handlers to both events may modify the message.</span></span> <span data-ttu-id="5f1d1-138">Il dispatcher deve inviare il messaggio modificato e non il messaggio non modificato originale.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-138">The dispatcher should dispatch the modified message and not the original unchanged message.</span></span> <span data-ttu-id="5f1d1-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> viene recapitato a tutti i listener, ma l'intenzione dell'architettura solo la finestra di primo livello che contiene l'oggetto HWND in corrispondenza del quale i messaggi di destinazione devono richiamare il codice in risposta al messaggio.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is delivered to all listeners, but the architectural intention is that only the top-level window containing the HWND at which the messages targeted should invoke code in response to the message.</span></span>  
  
## <a name="how-hwndsource-treats-componentdispatcher-events"></a><span data-ttu-id="5f1d1-140">Gli eventi ComponentDispatcher di HwndSource</span><span class="sxs-lookup"><span data-stu-id="5f1d1-140">How HwndSource Treats ComponentDispatcher Events</span></span>  
 <span data-ttu-id="5f1d1-141">Se il <xref:System.Windows.Interop.HwndSource> è una finestra di primo livello (nessun valore HWND padre), verrà registrato con <xref:System.Windows.Interop.ComponentDispatcher>.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-141">If the <xref:System.Windows.Interop.HwndSource> is a top-level window (no parent HWND), it will register with <xref:System.Windows.Interop.ComponentDispatcher>.</span></span> <span data-ttu-id="5f1d1-142">Se <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> viene generato, e se il messaggio è destinato il <xref:System.Windows.Interop.HwndSource> finestre figlio, o <xref:System.Windows.Interop.HwndSource> chiamate relativo <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> sequenza di sink di tastiera.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-142">If <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is raised, and if the message is intended for the <xref:System.Windows.Interop.HwndSource> or child windows, <xref:System.Windows.Interop.HwndSource> calls its <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> keyboard sink sequence.</span></span>  
  
 <span data-ttu-id="5f1d1-143">Se il <xref:System.Windows.Interop.HwndSource> non è una finestra di primo livello (ha un valore HWND padre), non sarà presente alcuna gestione.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-143">If the <xref:System.Windows.Interop.HwndSource> is not a top-level window (has a parent HWND), there will be no handling.</span></span> <span data-ttu-id="5f1d1-144">È previsto solo la finestra di primo livello per eseguire la gestione e vi deve essere una finestra di primo livello con il supporto di sink della tastiera come parte di tutti gli scenari di interoperatività.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-144">Only the top level window is expected to do the handling, and there is expected to be a top level window with keyboard sink support as part of any interoperation scenario.</span></span>  
  
 <span data-ttu-id="5f1d1-145">Se <xref:System.Windows.Interop.HwndHost.WndProc%2A> in un <xref:System.Windows.Interop.HwndSource> viene chiamato senza un metodo di sink della tastiera appropriato viene chiamato per primo, l'applicazione riceverà gli eventi di tastiera di livello superiore, ad esempio <xref:System.Windows.UIElement.KeyDown>.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-145">If <xref:System.Windows.Interop.HwndHost.WndProc%2A> on an <xref:System.Windows.Interop.HwndSource> is called without an appropriate keyboard sink method being called first, your application will receive the higher level keyboard events such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="5f1d1-146">Tuttavia, nessun metodo sink della tastiera verrà chiamato, che consente di evitare funzionalità di modello di input da tastiera utile ad esempio il supporto di chiavi di accesso.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-146">However, no keyboard sink methods will be called, which circumvents desirable keyboard input model features such as access key support.</span></span> <span data-ttu-id="5f1d1-147">Questa situazione può verificarsi perché il ciclo di messaggi non ha notificato correttamente i thread rilevanti nel <xref:System.Windows.Interop.ComponentDispatcher>, oppure perché il valore HWND padre non ha richiamato le risposte di sink della tastiera appropriate.</span><span class="sxs-lookup"><span data-stu-id="5f1d1-147">This might happen because the message loop did not properly notify the relevant thread on the <xref:System.Windows.Interop.ComponentDispatcher>, or because the parent HWND did not invoke the proper keyboard sink responses.</span></span>  
  
 <span data-ttu-id="5f1d1-148">Inviato un messaggio che va per il sink della tastiera potrebbe non essere per l'oggetto HWND se hook per il messaggio è stato aggiunto usando il <xref:System.Windows.Interop.HwndSource.AddHook%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="5f1d1-148">A message that goes to the keyboard sink might not be sent to the HWND if you added hooks for that message by using the <xref:System.Windows.Interop.HwndSource.AddHook%2A> method.</span></span> <span data-ttu-id="5f1d1-149">Il messaggio potrebbe essere stato gestito a livello del message pump direttamente e non inviato al `DispatchMessage` (funzione).</span><span class="sxs-lookup"><span data-stu-id="5f1d1-149">The message might have been handled at the message pump level directly and not submitted to the `DispatchMessage` function.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5f1d1-150">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="5f1d1-150">See also</span></span>

- <xref:System.Windows.Interop.ComponentDispatcher>
- <xref:System.Windows.Interop.IKeyboardInputSink>
- [<span data-ttu-id="5f1d1-151">Interoperatività di WPF e Win32</span><span class="sxs-lookup"><span data-stu-id="5f1d1-151">WPF and Win32 Interoperation</span></span>](wpf-and-win32-interoperation.md)
- [<span data-ttu-id="5f1d1-152">Modello di threading</span><span class="sxs-lookup"><span data-stu-id="5f1d1-152">Threading Model</span></span>](threading-model.md)
- [<span data-ttu-id="5f1d1-153">Cenni preliminari sull'input</span><span class="sxs-lookup"><span data-stu-id="5f1d1-153">Input Overview</span></span>](input-overview.md)
