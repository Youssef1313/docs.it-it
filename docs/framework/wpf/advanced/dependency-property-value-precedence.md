---
title: Precedenza del valore della proprietà di dipendenza
ms.date: 03/30/2017
helpviewer_keywords:
- dependency properties [WPF], classes as owners
- dependency properties [WPF], metadata
- classes [WPF], owners of dependency properties
- metadata [WPF], dependency properties
ms.assetid: 1fbada8e-4867-4ed1-8d97-62c07dad7ebc
ms.openlocfilehash: 7d5ff09bb9cc8da45f44cf6fe952411e7cd3f4c4
ms.sourcegitcommit: 4d8efe00f2e5ab42e598aff298d13b8c052d9593
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/16/2019
ms.locfileid: "68238534"
---
# <a name="dependency-property-value-precedence"></a>Precedenza del valore della proprietà di dipendenza
<a name="introduction"></a> Questo argomento illustra il modo in cui i meccanismi del sistema di proprietà [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] possono influire sul valore di una proprietà di dipendenza e descrive la precedenza in base alla quale gli aspetti del sistema di proprietà si applicano al valore effettivo di una proprietà.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Prerequisiti  
 Questo argomento presuppone la conoscenza delle proprietà di dipendenza dal punto di vista di un consumer delle proprietà di dipendenza esistenti nelle classi di [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], nonché la lettura dell'argomento [Panoramica sulle proprietà di dipendenza](dependency-properties-overview.md). Per seguire gli esempi illustrati in questo argomento, è anche necessario conoscere [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] e saper scrivere applicazioni [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
<a name="intro"></a>   
## <a name="the-wpf-property-system"></a>Il sistema di proprietà WPF  
 Il sistema di proprietà [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] offre un potente strumento per consentire la determinazione del valore delle proprietà di dipendenza in base a numerosi fattori, abilitando funzionalità quali la convalida delle proprietà in tempo reale, l'associazione tardiva e la notifica alle proprietà correlate delle modifiche ai valori di altre proprietà. L'ordine e logica precisi usati per determinare i valori delle proprietà di dipendenza sono piuttosto complessi. La conoscenza di questo ordine consentirà di evitare l'impostazione dì proprietà non necessarie e potrebbe anche eliminare i dubbi sui motivi precisi per i quali alcuni tentativi di influenzare o anticipare un valore delle proprietà di dipendenza non hanno determinato il valore atteso.  
  
<a name="multiple_sets"></a>   
## <a name="dependency-properties-might-be-set-in-multiple-places"></a>Le proprietà di dipendenza possono essere impostate in più punti  
 Di seguito è riportato [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] in cui la stessa proprietà (<xref:System.Windows.Controls.Control.Background%2A>) dispone di tre diversi "set" operazioni che potrebbero influenzare il valore.  
  
 [!code-xaml[PropertiesOvwSupport#DPPrecedence](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#dpprecedence)]  
  
 In questo caso, quale colore ci si aspetta che verrà applicato, rosso, verde o blu?  
  
 Ad eccezione dei valori animati e della coercizione, i set di proprietà locali vengono impostati con la precedenza più elevata. Se si imposta localmente un valore, è possibile prevedere che il valore venga accettato, anche al di là degli stili o dei modelli di controllo. In questo esempio, <xref:System.Windows.Controls.Control.Background%2A> è impostato su rosso in locale. Pertanto, lo stile definito in questo ambito, anche se è uno stile implicito che diversamente si applicherebbe a tutti gli elementi di quel tipo in quell'ambito, non è la precedenza più alta per dare il <xref:System.Windows.Controls.Control.Background%2A> proprietà relativo valore.  Se è stato rimosso il valore locale Red dall'istanza specifica del controllo Button, lo stile avrà la precedenza e il pulsante otterrà il valore di Background dallo stile.  All'interno dello stile, i trigger hanno la precedenza, pertanto il pulsante sarà blu se il mouse è posizionato su di esso e verde in caso contrario.  
  
<a name="listing"></a>   
## <a name="dependency-property-setting-precedence-list"></a>Elenco delle precedenze per l'impostazione delle proprietà di dipendenza  
 Di seguito viene riportato l'ordine definitivo usato dal sistema di proprietà per l'assegnazione dei valori di runtime delle proprietà di dipendenza. La precedenza più elevata viene elencata per prima. Questo elenco si basa su alcuni dei concetti generali espressi in [Panoramica sulle proprietà di dipendenza](dependency-properties-overview.md).  
  
1. **Coercizione del sistema di proprietà.** Per informazioni dettagliate sulla coercizione, vedere [Coercizione, animazione e valore di base](#animations) più avanti in questo argomento.  
  
2. **Animazioni attive o animazioni con un comportamento di attesa.** Per ottenere qualsiasi effetto pratico, l'animazione di una proprietà deve essere in grado di avere la precedenza sul valore di base (inanimato), anche se quel valore è stato impostato localmente. Per informazioni dettagliate, vedere [Coercizione, animazione e valore di base](#animations) più avanti in questo argomento.  
  
3. **Valore locale.** Un valore locale potrebbe essere impostato tramite la praticità della proprietà "wrapper", che equivale anche all'impostazione come elemento di un attributo o una proprietà [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], o da una chiamata al <xref:System.Windows.DependencyObject.SetValue%2A> API usando una proprietà di un'istanza specifica. Se si imposta un valore locale usando un'associazione o una risorsa, ciascuno di questi elementi dispone della precedenza come se fosse stato impostato un valore diretto.  
  
4. **Proprietà del modello TemplatedParent.** L'elemento dispone di un <xref:System.Windows.FrameworkElement.TemplatedParent%2A> se è stato creato come parte di un modello (un <xref:System.Windows.Controls.ControlTemplate> o <xref:System.Windows.DataTemplate>). Per informazioni dettagliate sulle situazioni in cui viene applicato, vedere [TemplatedParent](#templatedparent) più avanti in questo argomento. All'interno del modello, viene applicata la seguente precedenza:  
  
    1. Attiva dal <xref:System.Windows.FrameworkElement.TemplatedParent%2A> modello.  
  
    2. Set di proprietà (in genere tramite [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] attributi) nel <xref:System.Windows.FrameworkElement.TemplatedParent%2A> modello.  
  
5. **Stile implicito.** Si applica solo alla proprietà `Style`. La proprietà `Style` viene riempita da qualsiasi risorsa di stile con una chiave che corrisponde al tipo di quell'elemento. Quella risorsa di stile deve essere presente nella pagina o nell'applicazione. La ricerca per una risorsa di stile implicita non viene eseguita nei temi.  
  
6. **Trigger degli stili.** I trigger all'interno di stili da una pagina o un'applicazione (questi stili potrebbero essere stili espliciti o impliciti, ma non derivati dagli stili predefiniti, che hanno una precedenza inferiore).  
  
7. **Trigger dei modelli.** Qualsiasi trigger da un modello all'interno di uno stile oppure un modello applicato direttamente.  
  
8. **Setter di stili.** I valori da un <xref:System.Windows.Setter> all'interno di stili da pagine o applicazioni.  
  
9. **Stile (tema) predefinito.** Per informazioni dettagliate sui casi in cui viene applicato e sul modo in cui gli stili del tema si riferiscono ai modelli all'interno degli stili del tema, vedere [Stili (tema) predefiniti](#themestyles) più avanti in questo argomento. All'interno di uno stile predefinito, viene applicato il seguente ordine di precedenza:  
  
    1. Trigger attivi nello stile del tema.  
  
    2. Setter nello stile del tema.  
  
10. **Ereditarietà.** Alcune proprietà di dipendenza ereditano i propri valori dall'elemento padre agli elementi figlio, in modo che non sia necessario impostarli in modo specifico per ogni elemento in tutta l'applicazione. Per informazioni dettagliate, vedere [Ereditarietà del valore della proprietà](property-value-inheritance.md).  
  
11. **Valore predefinito dai metadati delle proprietà di dipendenza.** Qualsiasi proprietà di dipendenza specificata può avere un valore predefinito come stabilito dalla registrazione del sistema di proprietà di quella particolare proprietà. Inoltre, le classi derivate che ereditano una proprietà di dipendenza hanno la possibilità di eseguire l'override di tali metadati (incluso il valore predefinito) in base al tipo. Per altre informazioni, vedere [Metadati delle proprietà di dipendenza](dependency-property-metadata.md). Dato che l'ereditarietà viene controllata prima del valore predefinito, per una proprietà ereditata un valore predefinito dell'elemento padre ha la precedenza su un elemento figlio.  Di conseguenza, se una proprietà ereditabile non viene impostata ovunque, viene usato il valore predefinito come specificato nella radice o nell'elemento padre invece del valore predefinito dell'elemento figlio.  
  
<a name="templatedparent"></a>   
## <a name="templatedparent"></a>TemplatedParent  
 TemplatedParent come un elemento di precedenza non si applica a qualsiasi proprietà di un elemento che viene dichiarata direttamente nel markup dell'applicazione standard. Il concetto di TemplatedParent esiste solo per elementi figlio all'interno di una struttura ad albero visuale che vengono creati tramite l'applicazione del modello. Quando il sistema di proprietà cerca il <xref:System.Windows.FrameworkElement.TemplatedParent%2A> modello per un valore, sta cercando il modello che ha creato quell'elemento. I valori delle proprietà dal <xref:System.Windows.FrameworkElement.TemplatedParent%2A> modello generalmente agiscono come se fossero stati impostati come valore locale nell'elemento figlio, ma questa precedenza inferiore rispetto al valore locale esiste perché i modelli sono potenzialmente condivisi. Per informazioni dettagliate, vedere <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.  
  
<a name="style_property"></a>   
## <a name="the-style-property"></a>Proprietà Style  
 L'ordine di ricerca descritto in precedenza si applica a tutte le possibili proprietà di dipendenza tranne una: il <xref:System.Windows.FrameworkElement.Style%2A> proprietà. Il <xref:System.Windows.FrameworkElement.Style%2A> proprietà è univoca in quanto non è possibile può essere applicato uno stile, in modo che non si applicano gli elementi di precedenza da 5 a 8. Inoltre, l'animazione o la coercizione <xref:System.Windows.FrameworkElement.Style%2A> non è consigliabile (e l'animazione <xref:System.Windows.FrameworkElement.Style%2A> richiederebbe una classe di animazione personalizzata). Rimangono così tre modalità che il <xref:System.Windows.FrameworkElement.Style%2A> proprietà può essere impostata:  
  
- **Stile esplicito.** Il <xref:System.Windows.FrameworkElement.Style%2A> viene impostata direttamente. Nella maggior parte degli scenari, lo stile non viene definito inline, ma viene invece indicato come una risorsa, tramite una chiave esplicita. In questo caso la stessa proprietà Style agisce come se fosse un valore locale, elemento di precedenza 3.  
  
- **Stile implicito.** Il <xref:System.Windows.FrameworkElement.Style%2A> proprietà non viene impostata direttamente. Tuttavia, il <xref:System.Windows.FrameworkElement.Style%2A> presente a qualche livello nella sequenza di ricerca di risorse (pagina, applicazione) e viene aggiunta usando una chiave di risorsa che corrisponde al tipo è lo stile da applicare a. In questo caso, il <xref:System.Windows.FrameworkElement.Style%2A> stessa proprietà agisce in base a una precedenza identificata nella sequenza come elemento 5. Questa condizione può essere rilevata tramite <xref:System.Windows.DependencyPropertyHelper> contro il <xref:System.Windows.FrameworkElement.Style%2A> proprietà e cercando <xref:System.Windows.BaseValueSource.ImplicitStyleReference> nei risultati.  
  
- **Stile predefinito**, noto anche come **stile del tema.** Il <xref:System.Windows.FrameworkElement.Style%2A> proprietà non viene impostata direttamente e infatti verrà letta come `null` fino alla fase di esecuzione. In questo caso, lo stile deriva dalla valutazione del tema di runtime che fa parte del motore di presentazione [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
 Per gli stili impliciti non inclusi nei temi, il tipo deve corrispondere esattamente: una `MyButton` `Button`-classe derivata non utilizzerà in modo implicito uno stile per `Button`.  
  
<a name="themestyles"></a>   
## <a name="default-theme-styles"></a>Stili (tema) predefiniti  
 Ogni controllo fornito con [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dispone di uno stile predefinito. Potenzialmente, lo stile predefinito varia in base al tema, motivo per il quale questo stile predefinito viene indicato in alcuni casi come uno stile del tema.  
  
 Le informazioni più importanti che si trova all'interno di uno stile predefinito per un controllo è il modello di controllo, presente nello stile del tema come setter per relativo <xref:System.Windows.Controls.Control.Template%2A> proprietà. Se non esistesse un modello derivato dagli stili predefiniti, un controllo senza un modello personalizzato come parte di uno stile personalizzato non presenterebbe alcun aspetto visivo. Il modello derivato dallo stile predefinito fornisce all'aspetto visivo di ciascun controllo una struttura di base e definisce anche le connessioni tra proprietà definite nella struttura ad albero visuale del modello e la classe di controlli corrispondente. Ogni controllo espone un set di proprietà che può influenzare l'aspetto visivo del controllo senza sostituire completamente il modello. Ad esempio, si consideri l'aspetto visivo predefinito di un <xref:System.Windows.Controls.Primitives.Thumb> controllo, ossia un componente di un <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Oggetto <xref:System.Windows.Controls.Primitives.Thumb> dispone di determinate proprietà personalizzabili. Il modello predefinito di un <xref:System.Windows.Controls.Primitives.Thumb> crea una struttura di base / struttura ad albero visuale con molti annidati <xref:System.Windows.Controls.Border> componenti per la creazione di un aspetto smussato. Se una proprietà che fa parte del modello è destinata a essere esposto per la personalizzazione per la <xref:System.Windows.Controls.Primitives.Thumb> classe, quindi tale proprietà deve essere esposta da un [TemplateBinding](templatebinding-markup-extension.md), all'interno del modello. Nel caso del <xref:System.Windows.Controls.Primitives.Thumb>, le varie proprietà di questi bordi condividono un'associazione di modelli per le proprietà, ad esempio <xref:System.Windows.Controls.Border.Background%2A> o <xref:System.Windows.Controls.Border.BorderThickness%2A>. Ma certe altre proprietà o disposizioni visive sono hardcoded nel modello di controllo o sono associate a valori che derivano direttamente dal tema e non possono essere modificate senza sostituire l'intero modello. Generalmente, se una proprietà deriva da un elemento padre basato su modelli e non viene esposta da un'associazione di modelli, non può essere regolata dagli stili poiché non esiste un modo semplice per fare riferimento ad essa. Ma tale proprietà potrebbe essere ancora influenzata dall'ereditarietà dei valori della proprietà nel modello applicato oppure dal valore predefinito.  
  
 Gli stili del tema usano un tipo come chiave nelle definizioni. Tuttavia, quando vengono applicati i temi per un'istanza dell'elemento specificato, la ricerca dei temi per questo tipo viene eseguita controllando la <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> proprietà su un controllo. Questa operazione è in contrasto con l'uso del tipo letterale, adottato dagli stili impliciti. Il valore di <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> verrebbe ereditato dalle classi derivate anche se l'implementatore non lo modificasse (la modalità desiderata per la modifica della proprietà è non eseguirne l'override a livello di proprietà, ma invece modificare il valore predefinito nei metadati della proprietà). Questo riferimento indiretto consente alle classi di base di definire gli stili del tema per gli elementi derivati che non dispongono di un altro stile oppure, in un caso più importante, che non dispongono di un modello all'interno di quello stile e che di conseguenza non avrebbero alcun aspetto visivo predefinito. Di conseguenza, è possibile derivare `MyButton` dal <xref:System.Windows.Controls.Button> e ottenere ancora di <xref:System.Windows.Controls.Button> modello predefinito. Se fosse l'autore dei controlli `MyButton` e si desiderasse un comportamento diverso, è possibile eseguire l'override di metadati della proprietà di dipendenza per <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> sul `MyButton` per restituire una chiave diversa e quindi definire gli stili del tema attinenti incluso il modello per la `MyButton` che è necessario creare un pacchetto con il `MyButton` controllo. Per altri dettagli su temi, stili e creazione di controlli, vedere [Cenni preliminari sulla modifica di controlli](../controls/control-authoring-overview.md).  
  
<a name="resources"></a>   
## <a name="dynamic-resource-references-and-binding"></a>Riferimenti e associazione di risorse dinamiche  
 I riferimenti alle risorse dinamiche e le operazioni di associazione rispettano la precedenza della posizione su cui sono impostati. Ad esempio, una risorsa dinamica applicata a un valore locale agisce in base all'elemento di precedenza 3, a un'associazione per un setter di proprietà all'interno di un stile del tema viene applicato un elemento di precedenza 9 e così via. Dato che i riferimenti e l'associazione per le risorse dinamiche devono essere in grado di ottenere valori dallo stato della fase di esecuzione dell'applicazione, ciò comporta che anche il processo effettivo di determinazione della precedenza del valore di proprietà per qualsiasi proprietà specificata si estende nella fase di esecuzione.  
  
 I riferimenti alle risorse dinamiche non fanno parte in senso stretto del sistema di proprietà, ma hanno un proprio ordine di ricerca che interagisce con la sequenza elencata in precedenza. Tale precedenza è documentata più approfonditamente in [Risorse XAML](xaml-resources.md). La somma di base di tale precedenza è: elemento alla radice della pagina, applicazione, tema, sistema.  
  
 Le risorse dinamiche e le associazioni hanno la precedenza relativamente a dove sono state impostate, ma il valore viene rinviato. Una conseguenza di ciò è che, se si imposta una risorsa dinamica o un'associazione su un valore locale, qualsiasi modifica al valore locale sostituisce completamente la risorsa dinamica o l'associazione. Anche se si chiama il <xref:System.Windows.DependencyObject.ClearValue%2A> metodo cancellare impostata localmente valore, le risorse dinamiche o binding non verrà ripristinato. In effetti, se si chiama <xref:System.Windows.DependencyObject.ClearValue%2A> su una proprietà che dispone di una risorsa dinamica o associazione (con nessun valore locale letterale), queste vengono cancellate dal <xref:System.Windows.DependencyObject.ClearValue%2A> chiamare troppo.  
  
<a name="setcurrentvalue"></a>   
## <a name="setcurrentvalue"></a>SetCurrentValue  
 Il <xref:System.Windows.DependencyObject.SetCurrentValue%2A> metodo è un altro modo per impostare una proprietà, ma non in ordine di precedenza. Al contrario, <xref:System.Windows.DependencyObject.SetCurrentValue%2A> consente di modificare il valore di una proprietà senza sovrascrivere l'origine di un valore precedente. È possibile usare <xref:System.Windows.DependencyObject.SetCurrentValue%2A> ogni volta che si desidera impostare un valore senza assegnare a tale valore la precedenza del valore locale. Ad esempio, se una proprietà viene impostata da un trigger e quindi assegnata un altro valore tramite <xref:System.Windows.DependencyObject.SetCurrentValue%2A>, il sistema di proprietà rispetta comunque il trigger e la proprietà verrà modificato se si verifica l'azione del trigger. <xref:System.Windows.DependencyObject.SetCurrentValue%2A> Consente di modificare il valore della proprietà senza assegnarle un'origine con una precedenza più alta. Analogamente, è possibile utilizzare <xref:System.Windows.DependencyObject.SetCurrentValue%2A> per modificare il valore di una proprietà senza sovrascrivere un'associazione.  
  
<a name="animations"></a>   
## <a name="coercion-animations-and-base-value"></a>Coercizione, animazioni e valore di base  
 La coercizione e l'animazione agiscono entrambe su un valore indicato come "valore di base" in tutto l'[!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)]. Di conseguenza, il valore di base è un qualsiasi valore determinato tramite la valutazione verso l'alto negli elementi fino a raggiungere l'elemento 2.  
  
 Per un'animazione, il valore di base può avere un effetto sul valore animato, se quell'animazione non specifica le impostazioni "From" e "To" per determinati comportamenti o se l'animazione ripristina intenzionalmente il valore di base quando viene completata. Per osservare questo comportamento nella pratica, eseguire l'[Esempio valori di destinazione dell'animazione From/To/By](https://go.microsoft.com/fwlink/?LinkID=159988). Tentare di impostare i valori locali dell'altezza del rettangolo nell'esempio, in modo che il valore locale iniziale sia diverso da qualsiasi impostazione "From" nell'animazione. Si noterà che le animazioni iniziano immediatamente usando i valori "From" valori e sostituiscono il valore di base una volta avviate. L'animazione potrebbe indicare di ritornare al valore trovato prima dell'animazione, una volta completata, specificando l'arresto <xref:System.Windows.Media.Animation.FillBehavior>. In seguito, verrà usata la precedenza normale per la determinazione del valore di base.  
  
 Possono essere applicate più animazioni a una sola proprietà, ognuna delle quali definita da punti diversi nella precedenza dei valori. Tuttavia, queste animazioni comporranno i relativi valori, piuttosto che applicare semplicemente l'animazione dalla precedenza più elevata. Ciò dipende dal modo preciso in cui sono definite le animazioni e dal tipo del valore che viene animato. Per altre informazioni sull'animazione di proprietà, vedere [Cenni preliminari sull'animazione](../graphics-multimedia/animation-overview.md).  
  
 La coercizione si applica al livello più elevato in assoluto. Anche un'animazione già in esecuzione è soggetta alla coercizione del valore. Alcune proprietà di dipendenza esistenti in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dispongono di una coercizione incorporata. Per una proprietà di dipendenza personalizzate, si definisce il comportamento di coercizione per una proprietà di dipendenza personalizzate scrivendo un <xref:System.Windows.CoerceValueCallback> e passando il callback come parte dei metadati quando si crea la proprietà. È anche possibile eseguire l'override del comportamento di coercizione di proprietà esistenti eseguendo l'override dei metadati di quella proprietà in una classe derivata. La coercizione interagisce con il valore di base in modo tale che i vincoli di coercizione vengano applicati come i vincoli esistenti in quel momento, mantenendo tuttavia il valore di base. Pertanto, se i vincoli nella coercizione vengono rimossi in un secondo momento, la coercizione restituirà il valore più vicino possibile a quel valore di base e l'influenza della coercizione su una proprietà cesserà potenzialmente appena vengono rimossi tutti i vincoli. Per altre informazioni sul comportamento di coercizione, vedere [Callback e convalida delle proprietà di dipendenza](dependency-property-callbacks-and-validation.md).  
  
<a name="triggers"></a>   
## <a name="trigger-behaviors"></a>Comportamenti dei trigger  
 I controlli spesso definiscono i comportamenti dei trigger come parte dello stile predefinito nei temi. L'impostazione di proprietà locali sui controlli può impedire ai trigger di essere in grado di rispondere agli eventi generati dagli utenti sia da un punto di vista visivo sia da un punto di vista di comportamento. L'uso più comune di un trigger di proprietà sia per le proprietà di controllo o di stato, ad esempio <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A>. Ad esempio, per impostazione predefinita quando un <xref:System.Windows.Controls.Button> è disabilitato (trigger per <xref:System.Windows.UIElement.IsEnabled%2A> viene `false`) il <xref:System.Windows.Controls.Control.Foreground%2A> valore nello stile del tema è quello che determina il controllo venga visualizzato "grigio". Tuttavia, se è stata impostata una variabile locale <xref:System.Windows.Controls.Control.Foreground%2A> valore, che normale colore viene ignorato in precedenza dal set di proprietà locali, anche in questo scenario attivate da proprietà. Prestare attenzione nell'impostazione di valori per proprietà che presentano comportamenti di trigger a livello di tema e accertarsi di non interferire impropriamente con l'esperienza utente prevista per quel controllo.  
  
<a name="clearvalue"></a>   
## <a name="clearvalue-and-value-precedence"></a>ClearValue e precedenza dei valori  
 Il <xref:System.Windows.DependencyObject.ClearValue%2A> metodo fornisce un modo efficace cancellare eventuali valori applicati localmente da una proprietà di dipendenza che è impostato su un elemento. Tuttavia, la chiamata <xref:System.Windows.DependencyObject.ClearValue%2A> non garantisce che il valore predefinito come stabilito nei metadati durante la registrazione della proprietà è il nuovo valore. Tutti gli altri partecipanti nella precedenza dei valori sono ancora attivi. Solo il valore impostato localmente è stato rimosso dalla sequenza di precedenza. Ad esempio, se si chiama <xref:System.Windows.DependencyObject.ClearValue%2A> su una proprietà in cui tale proprietà viene impostata anche da uno stile del tema, quindi il valore del tema viene applicato come nuovo valore anziché l'impostazione predefinita basata sui metadati. Se vuoi sfruttare tutti i partecipanti dei valori di proprietà insito nel processo e impostare il valore per l'impostazione predefinita i metadati registrati, è possibile ottenere che il valore predefinito definitivamente eseguendo una query di metadati della proprietà di dipendenza, quindi è possibile usare il valore predefinito da localmente impostare la proprietà con una chiamata a <xref:System.Windows.DependencyObject.SetValue%2A>.  
  
## <a name="see-also"></a>Vedere anche

- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- [Panoramica sulle proprietà di dipendenza](dependency-properties-overview.md)
- [Proprietà di dipendenza personalizzate](custom-dependency-properties.md)
- [Callback e convalida delle proprietà di dipendenza](dependency-property-callbacks-and-validation.md)
