---
title: Strutture ad albero in WPF
ms.date: 03/30/2017
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
ms.openlocfilehash: 14ab9b5b36eee607679ee95423c2af912ed02310
ms.sourcegitcommit: 83ecdf731dc1920bca31f017b1556c917aafd7a0
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/12/2019
ms.locfileid: "67860007"
---
# <a name="trees-in-wpf"></a>Strutture ad albero in WPF
In molte tecnologie gli elementi e i componenti sono organizzati in una struttura ad albero in cui gli sviluppatori modificano direttamente i nodi degli oggetti nell'albero per influire sul rendering o sul comportamento di un'applicazione. [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] usa anche molte metafore correlate alla struttura ad albero per definire le relazioni tra gli elementi del programma. In genere gli sviluppatori WPF possono creare un'applicazione nel codice o definire parti dell'applicazione in XAML usando come riferimento concettuale la metafora della struttura ad albero di oggetti, ma chiameranno un'API specifica o useranno un markup specifico a tale scopo anziché un'API di modifica della struttura ad albero di oggetti generica simile a quella usata nel modello DOM XML. WPF espone due classi di helper che forniscono una visualizzazione albero metafora <xref:System.Windows.LogicalTreeHelper> e <xref:System.Windows.Media.VisualTreeHelper>. Nella documentazione di WPF vengono inoltre usati i termini struttura ad albero visuale e albero logico, in quanto tali strutture ad albero sono utili per la comprensione del comportamento di alcune funzionalità chiave di WPF. In questo argomento definisce ciò che rappresentano la struttura ad albero visuale e albero logico, vengono illustrate tali strutture ad albero correlazione tra un concetto di albero di oggetti complessiva e introduce <xref:System.Windows.LogicalTreeHelper> e <xref:System.Windows.Media.VisualTreeHelper>s.  

<a name="element_tree"></a>   
## <a name="trees-in-wpf"></a>Strutture ad albero in WPF  
 La struttura ad albero più completa in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] è la struttura ad albero di oggetti. Se si definisce la pagina di un'applicazione in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] e quindi si carica il codice [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], la struttura ad albero viene creata in base alle relazioni di annidamento degli elementi nel markup. Se si definisce un'applicazione o una parte dell'applicazione nel codice, la struttura ad albero viene creata in base a come si assegnano i valori per le proprietà che implementano il modello di contenuto per un determinato oggetto. In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] la struttura ad albero di oggetti completa viene concettualizzata e può essere segnalata alla relativa API pubblica in due modi diversi: come albero logico e come struttura ad albero visuale. Le distinzioni tra albero logico e struttura ad albero visuale non sono sempre necessariamente importanti, ma possono talvolta causare problemi con alcuni sottosistemi [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] e influire sulle scelte fatte nel markup o nel codice.  
  
 Anche se non sempre si modifica direttamente l'albero logico o la struttura ad albero visuale, la corretta comprensione dei concetti correlati all'interazione delle strutture ad albero è utile per comprendere WPF in quanto tecnologia. Il concetto di WPF come metafora della struttura ad albero è anche essenziale per comprendere il funzionamento dell'ereditarietà delle proprietà e del routing degli eventi in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
> [!NOTE]
>  Poiché la struttura ad albero di oggetti è più un concetto che un'API effettiva, è possibile pensare a tale concetto anche come a un oggetto grafico. In pratica, in fase di esecuzione ci sono relazioni tra gli oggetti per cui la metafora di struttura ad albero non è valida. Ciononostante, in particolare con l'interfaccia utente definita in XAML, la metafora della struttura ad albero è sufficientemente pertinente da far sì che nella maggior parte della documentazione di WPF venga usato il termine struttura ad albero di oggetti per fare riferimento a tale concetto generale.  
  
<a name="logical_tree"></a>   
## <a name="the-logical-tree"></a>Albero logico  
 In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] è possibile aggiungere contenuto agli elementi dell'interfaccia utente impostando proprietà degli oggetti di supporto per tali elementi. Ad esempio, aggiungere elementi a un <xref:System.Windows.Controls.ListBox> controllo mediante la modifica relativa <xref:System.Windows.Controls.ItemsControl.Items%2A> proprietà. In questo modo, si inseriscono elementi nel <xref:System.Windows.Controls.ItemCollection> vale a dire il <xref:System.Windows.Controls.ItemsControl.Items%2A> valore della proprietà. Analogamente, per aggiungere oggetti a un <xref:System.Windows.Controls.DockPanel>, modificano relativo <xref:System.Windows.Controls.Panel.Children%2A> valore della proprietà. In questo caso, si aggiungono oggetti per il <xref:System.Windows.Controls.UIElementCollection>. Per un esempio di codice, vedere [come: Aggiungere un elemento in modo dinamico](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100)).  
  
 Nella [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]quando si inseriscono voci di elenco in un <xref:System.Windows.Controls.ListBox> oppure controlli o altri elementi dell'interfaccia utente in un <xref:System.Windows.Controls.DockPanel>, è anche possibile usare i <xref:System.Windows.Controls.ItemsControl.Items%2A> e <xref:System.Windows.Controls.Panel.Children%2A> proprietà, in modo esplicito o implicito, come nell'esempio seguente.  
  
 [!code-xaml[TreeOvwsSupport#AllCode](~/samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 Se si elaborasse questo codice XAML come XML in un modello DOM (Document Object Model) e fossero stati inclusi tag impostati come commenti impliciti (operazione consentita), la struttura ad albero DOM XML risultante includerebbe elementi per `<ListBox.Items>` e altri elementi impliciti. Poiché tuttavia XAML non elabora in questo modo durante la lettura del markup e la scrittura negli oggetti, l'oggetto grafico risultante non includerà letteralmente `ListBox.Items`. Includerà però una <xref:System.Windows.Controls.ListBox> proprietà denominata `Items` che contiene un <xref:System.Windows.Controls.ItemCollection>e che <xref:System.Windows.Controls.ItemCollection> viene inizializzato ma vuoto quando il <xref:System.Windows.Controls.ListBox> XAML vengono elaborati. Quindi, ogni elemento oggetto figlio presente come contenuto per il <xref:System.Windows.Controls.ListBox> viene aggiunto per il <xref:System.Windows.Controls.ItemCollection> da chiamate del parser per `ItemCollection.Add`. Fino a questo punto, in questo esempio di elaborazione di XAML in una struttura ad albero di oggetti la struttura ad albero di oggetti creata sembra fondamentalmente essere un albero logico.  
  
 L'albero logico, tuttavia, non è l'intero oggetto grafico presente per l'interfaccia utente dell'applicazione in fase di esecuzione, anche se si considerano gli elementi della sintassi implicita XAML. Ciò è dovuto principalmente agli oggetti visivi e ai modelli. Ad esempio, prendere in considerazione il <xref:System.Windows.Controls.Button>. I report dell'albero logico il <xref:System.Windows.Controls.Button> oggetto e la relativa stringa `Content`. Nella struttura ad albero di oggetti di runtime, tuttavia, questo pulsante è molto più complesso. In particolare, il pulsante viene visualizzato solo nella schermata come perché una determinata <xref:System.Windows.Controls.Button> è stato applicato il modello di controllo. Gli oggetti visivi provenienti da un modello applicato (ad esempio il modello definito dal <xref:System.Windows.Controls.Border> grigio scuro intorno al pulsante visivo) non vengono segnalati nell'albero logico, anche se si sta esaminando l'albero logico durante la fase di esecuzione (ad esempio la gestione di un evento di input dal interfaccia utente visibile e quindi legge l'albero logico). Per trovare gli oggetti visivi del modello, è invece necessario esaminare la struttura ad albero visuale.  
  
 Per altre informazioni sul mapping tra la sintassi [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] e l'oggetto grafico creato e sulla sintassi implicita in XAML, vedere [Descrizione dettagliata della sintassi XAML](xaml-syntax-in-detail.md) o [Cenni preliminari su XAML (WPF)](xaml-overview-wpf.md).  
  
<a name="tree_property_inheritance_event_routing"></a>   
### <a name="the-purpose-of-the-logical-tree"></a>Scopo dell'albero logico  
 L'albero logico consente ai modelli di contenuto di scorrere rapidamente i relativi oggetti figlio possibili e rende i modelli di contenuto estendibili. L'albero logico fornisce inoltre un framework per determinate notifiche, ad esempio relative al caricamento di tutti gli oggetti nell'albero logico stesso. Fondamentalmente l'albero logico è un'approssimazione di un oggetto grafico di runtime a livello di framework, che esclude gli oggetti visivi, ma è efficace per molte operazioni di query sulla composizione dell'applicazione di runtime.  
  
 Inoltre, entrambi i riferimenti a risorse statiche e dinamiche vengono risolti cercando verso l'alto attraverso l'albero logico per <xref:System.Windows.FrameworkElement.Resources%2A> raccolte nell'oggetto richiedente iniziale, quindi continuare nell'albero logico e controllo della ognuno <xref:System.Windows.FrameworkElement> (o <xref:System.Windows.FrameworkContentElement>) per un'altra `Resources` valore che contiene un <xref:System.Windows.ResourceDictionary>, possibilmente contenente tale chiave. L'albero logico viene usato per la ricerca delle risorse, quando sono presenti sia l'albero logico, sia la struttura ad albero visuale. Per altre informazioni sui dizionari risorse e sulla ricerca, vedere [Risorse XAML](xaml-resources.md).  
  
<a name="composition"></a>   
### <a name="composition-of-the-logical-tree"></a>Composizione dell'albero logico  
 L'albero logico è definito nel livello di framework WPF, il che significa che è l'elemento di base WPF più rilevante per le operazioni dell'albero logico <xref:System.Windows.FrameworkElement> o <xref:System.Windows.FrameworkContentElement>. Tuttavia, come è possibile vedere se si usa la <xref:System.Windows.LogicalTreeHelper> API, l'albero logico a volte contiene nodi che non si escludono <xref:System.Windows.FrameworkElement> o <xref:System.Windows.FrameworkContentElement>. Ad esempio, l'albero logico segnala il <xref:System.Windows.Controls.TextBlock.Text%2A> valore di un <xref:System.Windows.Controls.TextBlock>, che è una stringa.  
  
<a name="override_logical_tree"></a>   
### <a name="overriding-the-logical-tree"></a>Override dell'albero logico  
 Gli autori di controlli avanzati è possono eseguire l'override dell'albero logico eseguendo l'override delle varie API che definiscono come modello di contenuto o un oggetto generale aggiunge o rimuove gli oggetti all'interno dell'albero logico. Per un esempio relativo all'override dell'albero logico, vedere [Eseguire l'override dell'albero logico](how-to-override-the-logical-tree.md).  
  
<a name="pvi"></a>   
### <a name="property-value-inheritance"></a>Ereditarietà del valore della proprietà  
 L'ereditarietà dei valori delle proprietà funziona tramite un albero ibrido. I metadati effettivi che contengono il <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> è di proprietà che consente l'ereditarietà della proprietà a livello di framework WPF <xref:System.Windows.FrameworkPropertyMetadata> classe. Pertanto, l'elemento padre che contiene il valore originale sia l'oggetto figlio che eredita tale valore devono essere entrambi <xref:System.Windows.FrameworkElement> o <xref:System.Windows.FrameworkContentElement>, e devono entrambi far parte dello stesso albero logico. Per le proprietà WPF esistenti che supportano l'ereditarietà delle proprietà, tuttavia, l'ereditarietà dei valori delle proprietà può essere mantenuta tramite un nuovo oggetto non incluso nell'albero logico. Questa caratteristica è pertinente per lo più se si vuole fare in modo che gli elementi del modello usino valori di proprietà ereditati impostati sull'istanza basata sul modello o a livelli ancora superiori di composizione a livello di pagina e quindi più in alto nell'albero logico. Per garantire un funzionamento coerente dell'ereditarietà dei valori delle proprietà oltre tale limite, la proprietà che eredita deve essere registrata come proprietà associata. È consigliabile seguire questo modello anche se si vuole definire una proprietà di dipendenza personalizzata con un comportamento di ereditarietà della proprietà. L'albero esatto usato per l'ereditarietà delle proprietà non può essere completamente previsto da un metodo di utilità di una classe helper, nemmeno in fase di esecuzione. Per altre informazioni, vedere [Ereditarietà del valore della proprietà](property-value-inheritance.md).  
  
<a name="two_trees"></a>   
## <a name="the-visual-tree"></a>Struttura ad albero visuale  
 In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] oltre al concetto di albero logico c'è anche il concetto di struttura ad albero visuale. La struttura ad albero visuale descrive la struttura degli oggetti visivi, come rappresentate dal <xref:System.Windows.Media.Visual> classe di base. Quando si scrive un modello per un controllo, si definisce o ridefinisce la struttura ad albero visuale relativa a quel controllo. La struttura ad albero visuale è di interesse anche per gli sviluppatori che vogliono un controllo di livello inferiore sul disegno per ragioni di prestazioni e ottimizzazione. Un'esposizione della struttura ad albero visuale come parte della programmazione di applicazioni [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] convenzionale è rappresentata dal fatto che le route degli eventi indirizzati percorrono per lo più la struttura ad albero visuale e non l'albero logico. Questa sottigliezza del comportamento degli eventi indirizzati potrebbe non essere immediatamente visibile, a meno che l'utente non sia un autore di controlli. Il routing di eventi nella struttura ad albero visuale consente ai controlli che implementano la composizione a livello visivo di gestire eventi o creare setter di eventi.  
  
<a name="trees_content"></a>   
## <a name="trees-content-elements-and-content-hosts"></a>Alberi, elementi di contenuto e host di contenuto  
 Gli elementi di contenuto (classi che derivano da <xref:System.Windows.ContentElement>) non fanno parte della struttura visiva, mentre non ereditano da <xref:System.Windows.Media.Visual> e non è una rappresentazione visiva. Per poter essere visualizzato in un'interfaccia utente, un <xref:System.Windows.ContentElement> deve essere ospitato in un host di contenuto che è sia un <xref:System.Windows.Media.Visual> e un partecipante dell'albero logico. In genere un oggetto di questo tipo è un <xref:System.Windows.FrameworkElement>. È possibile pensare all'host di contenuto come a un "browser" per il contenuto, che sceglie come visualizzare tale contenuto all'interno dell'area dello schermo controllata dall'host. Quando il contenuto è ospitato, può partecipare ad alcuni processi dell'albero che normalmente sono associati alla struttura ad albero visuale. In genere, il <xref:System.Windows.FrameworkElement> classe host include codice di implementazione che aggiunge uno ospitato <xref:System.Windows.ContentElement> alla route dell'evento tramite sottonodi dell'albero logico del contenuto, anche se il contenuto ospitato non fa parte della struttura visiva true. Questa operazione è necessaria in modo che un <xref:System.Windows.ContentElement> possa originare un evento che venga indirizzato a qualsiasi elemento diverso da se stesso.  
  
<a name="tree_traversal"></a>   
## <a name="tree-traversal"></a>Attraversamento dell'albero  
 Il <xref:System.Windows.LogicalTreeHelper> classe fornisce il <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A>, e <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> metodi per l'attraversamento dell'albero logico. Nella maggior parte dei casi, non è necessario attraversare l'albero logico dei controlli esistenti, perché i controlli espongono quasi sempre i relativi elementi figlio logici come proprietà di raccolta dedicata che supporta l'accesso alla raccolta, ad esempio `Add`, un indicizzatore e così via. Attraversamento dell'albero è principalmente uno scenario che viene usato dagli autori di controlli che scelgono di non derivare da pattern di controllo desiderata, ad esempio <xref:System.Windows.Controls.ItemsControl> o <xref:System.Windows.Controls.Panel> in cui le proprietà della raccolta sono già definite e che vogliono fornire i propri raccolta supporto della proprietà.  
  
 La struttura ad albero visuale supporta anche una classe helper per l'attraversamento di struttura ad albero visuale, <xref:System.Windows.Media.VisualTreeHelper>. La struttura ad albero visuale non viene esposto in modo appropriato tramite le proprietà specifiche del controllo, in modo che il <xref:System.Windows.Media.VisualTreeHelper> classe è il modo consigliato per attraversare la struttura ad albero visuale, se necessario per lo scenario di programmazione. Per altre informazioni, vedere [Cenni preliminari sul rendering della grafica WPF](../graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
> [!NOTE]
>  A volte è necessario esaminare la struttura ad albero visuale di un modello applicato. Quando si usa questa tecnica, è necessario procedere con attenzione. Anche quando si attraversa un struttura ad albero visuale per un controllo in cui viene definito il modello, i consumer del controllo possono sempre modificare il modello impostando il <xref:System.Windows.Controls.Control.Template%2A> proprietà su istanze e anche l'utente finale può influire sul modello applicato modificando il tema del sistema.  
  
<a name="routes"></a>   
## <a name="routes-for-routed-events-as-a-tree"></a>Route per eventi indirizzati come "albero"  
 Come indicato in precedenza, la route di qualsiasi evento indirizzato percorre un singolo percorso predeterminato di un albero che consiste in una forma ibrida delle rappresentazioni di struttura ad albero visuale e albero logico. La route degli eventi può percorrere l'albero procedendo verso l'alto o verso il basso, a seconda che si tratti di un evento indirizzato di bubbling o di tunneling. Il concetto di route dell'evento non prevede una classe helper di supporto diretto, che potrebbe essere usata per "percorrere" la route dell'evento indipendentemente dalla generazione di un evento che effettivamente percorre una route. È disponibile una classe che rappresenta la route, <xref:System.Windows.EventRoute>, ma i metodi di tale classe sono in genere solo per uso interno.  
  
<a name="resourcesandtrees"></a>   
## <a name="resource-dictionaries-and-trees"></a>Dizionari risorse e alberi  
 La ricerca nei dizionari risorse di tutti gli oggetti `Resources` definiti in una pagina attraversa fondamentalmente l'albero logico. Gli oggetti non inclusi nell'albero logico possono fare riferimento a risorse con chiave, ma la sequenza di ricerca delle risorse inizia nel punto in cui l'oggetto è connesso all'albero logico. In WPF, solo i nodi dell'albero logico possono avere una `Resources` proprietà contenente un <xref:System.Windows.ResourceDictionary>, pertanto non offre alcun vantaggio in attraversa la struttura ad albero visuale alla ricerca di risorse con chiave da un <xref:System.Windows.ResourceDictionary>.  
  
 La ricerca delle risorse può però estendersi anche oltre l'albero logico diretto. Per il markup dell'applicazione, la ricerca delle risorse può proseguire verso l'altro nei dizionari risorse a livello di applicazione e quindi verso il supporto dei temi e i valori di sistema a cui viene fatto riferimento come chiavi o proprietà statiche. Se i riferimenti alle risorse sono dinamici, i temi stessi possono fare riferimento anche ai valori di sistema esterni all'albero logico del tema. Per altre informazioni sui dizionari risorse e sulla logica di ricerca, vedere [Risorse XAML](xaml-resources.md).  
  
## <a name="see-also"></a>Vedere anche

- [Cenni preliminari sull'input](input-overview.md)
- [Cenni preliminari sul rendering della grafica WPF](../graphics-multimedia/wpf-graphics-rendering-overview.md)
- [Cenni preliminari sugli eventi indirizzati](routed-events-overview.md)
- [Inizializzazione di elementi oggetto non presenti in una struttura ad albero di oggetti](initialization-for-object-elements-not-in-an-object-tree.md)
- [Architettura WPF](wpf-architecture.md)
