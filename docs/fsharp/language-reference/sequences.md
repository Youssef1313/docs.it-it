---
title: Sequenze
description: Informazioni su come utilizzare F# le sequenze, quando si dispone di una raccolta di dati di grandi dimensioni ordinata, ma non si prevede necessariamente di utilizzare tutti gli elementi.
ms.date: 11/04/2019
ms.openlocfilehash: 34e03f1cead0a9f678f637afcb6c8397ef7572bc
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 11/12/2019
ms.locfileid: "73971437"
---
# <a name="sequences"></a><span data-ttu-id="e46ce-103">Sequenze</span><span class="sxs-lookup"><span data-stu-id="e46ce-103">Sequences</span></span>

> [!NOTE]
> <span data-ttu-id="e46ce-104">I collegamenti di riferimento all'API in questo articolo portano a MSDN.</span><span class="sxs-lookup"><span data-stu-id="e46ce-104">The API reference links in this article will take you to MSDN.</span></span>  <span data-ttu-id="e46ce-105">Il riferimento all'API in Microsoft Docs (docs.microsoft.com) non è completo.</span><span class="sxs-lookup"><span data-stu-id="e46ce-105">The docs.microsoft.com API reference is not complete.</span></span>

<span data-ttu-id="e46ce-106">Una *sequenza* è una serie logica di elementi di un solo tipo.</span><span class="sxs-lookup"><span data-stu-id="e46ce-106">A *sequence* is a logical series of elements all of one type.</span></span> <span data-ttu-id="e46ce-107">Le sequenze sono particolarmente utili quando si dispone di una raccolta di dati grande e ordinata, ma non necessariamente si prevede di usare tutti gli elementi.</span><span class="sxs-lookup"><span data-stu-id="e46ce-107">Sequences are particularly useful when you have a large, ordered collection of data but do not necessarily expect to use all of the elements.</span></span> <span data-ttu-id="e46ce-108">I singoli elementi di sequenza vengono calcolati solo se necessario, pertanto una sequenza può offrire prestazioni migliori rispetto a un elenco in situazioni in cui non vengono utilizzati tutti gli elementi.</span><span class="sxs-lookup"><span data-stu-id="e46ce-108">Individual sequence elements are computed only as required, so a sequence can provide better performance than a list in situations in which not all the elements are used.</span></span> <span data-ttu-id="e46ce-109">Le sequenze sono rappresentate dal tipo di `seq<'T>`, che è un alias per <xref:System.Collections.Generic.IEnumerable%601>.</span><span class="sxs-lookup"><span data-stu-id="e46ce-109">Sequences are represented by the `seq<'T>` type, which is an alias for <xref:System.Collections.Generic.IEnumerable%601>.</span></span> <span data-ttu-id="e46ce-110">Pertanto, qualsiasi tipo .NET che implementa <xref:System.Collections.Generic.IEnumerable%601> interfaccia può essere utilizzato come sequenza.</span><span class="sxs-lookup"><span data-stu-id="e46ce-110">Therefore, any .NET type that implements <xref:System.Collections.Generic.IEnumerable%601> interface can be used as a sequence.</span></span> <span data-ttu-id="e46ce-111">Il [modulo Seq](https://msdn.microsoft.com/library/54e8f059-ca52-4632-9ae9-49685ee9b684) fornisce supporto per le modifiche che coinvolgono sequenze.</span><span class="sxs-lookup"><span data-stu-id="e46ce-111">The [Seq module](https://msdn.microsoft.com/library/54e8f059-ca52-4632-9ae9-49685ee9b684) provides support for manipulations involving sequences.</span></span>

## <a name="sequence-expressions"></a><span data-ttu-id="e46ce-112">Espressioni di sequenza</span><span class="sxs-lookup"><span data-stu-id="e46ce-112">Sequence Expressions</span></span>

<span data-ttu-id="e46ce-113">Un' *espressione di sequenza* è un'espressione che restituisce una sequenza.</span><span class="sxs-lookup"><span data-stu-id="e46ce-113">A *sequence expression* is an expression that evaluates to a sequence.</span></span> <span data-ttu-id="e46ce-114">Le espressioni di sequenza possono assumere un certo numero di form.</span><span class="sxs-lookup"><span data-stu-id="e46ce-114">Sequence expressions can take a number of forms.</span></span> <span data-ttu-id="e46ce-115">Il formato più semplice specifica un intervallo.</span><span class="sxs-lookup"><span data-stu-id="e46ce-115">The simplest form specifies a range.</span></span> <span data-ttu-id="e46ce-116">Ad esempio, `seq { 1 .. 5 }` crea una sequenza che contiene cinque elementi, inclusi gli endpoint 1 e 5.</span><span class="sxs-lookup"><span data-stu-id="e46ce-116">For example, `seq { 1 .. 5 }` creates a sequence that contains five elements, including the endpoints 1 and 5.</span></span> <span data-ttu-id="e46ce-117">È anche possibile specificare un incremento (o decremento) tra due punti doppi.</span><span class="sxs-lookup"><span data-stu-id="e46ce-117">You can also specify an increment (or decrement) between two double periods.</span></span> <span data-ttu-id="e46ce-118">Il codice seguente, ad esempio, crea la sequenza di multipli di 10.</span><span class="sxs-lookup"><span data-stu-id="e46ce-118">For example, the following code creates the sequence of multiples of 10.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1502.fs)]

<span data-ttu-id="e46ce-119">Le espressioni di sequenza sono costituite da F# espressioni che producono valori della sequenza.</span><span class="sxs-lookup"><span data-stu-id="e46ce-119">Sequence expressions are made up of F# expressions that produce values of the sequence.</span></span> <span data-ttu-id="e46ce-120">È anche possibile generare valori a livello di codice:</span><span class="sxs-lookup"><span data-stu-id="e46ce-120">You can also generate values programmatically:</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1503.fs)]

<span data-ttu-id="e46ce-121">Nell'esempio precedente viene usato l'operatore `->`, che consente di specificare un'espressione il cui valore diventerà parte della sequenza.</span><span class="sxs-lookup"><span data-stu-id="e46ce-121">The previous sample uses the `->` operator, which allows you to specify an expression whose value will become a part of the sequence.</span></span> <span data-ttu-id="e46ce-122">È possibile usare solo `->` se ogni parte del codice che segue restituisce un valore.</span><span class="sxs-lookup"><span data-stu-id="e46ce-122">You can only use `->` if every part of the code that follows it returns a value.</span></span>

<span data-ttu-id="e46ce-123">In alternativa, è possibile specificare la parola chiave `do` con un `yield` facoltativo che segue:</span><span class="sxs-lookup"><span data-stu-id="e46ce-123">Alternatively, you can specify the `do` keyword, with an optional `yield` that follows:</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1504.fs)]

<span data-ttu-id="e46ce-124">Il codice seguente genera un elenco di coppie di coordinate insieme a un indice in una matrice che rappresenta la griglia.</span><span class="sxs-lookup"><span data-stu-id="e46ce-124">The following code generates a list of coordinate pairs along with an index into an array that represents the grid.</span></span> <span data-ttu-id="e46ce-125">Si noti che la prima espressione `for` richiede la specifica di un `do`.</span><span class="sxs-lookup"><span data-stu-id="e46ce-125">Note that the first `for` expression requires a `do` to be specified.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1505.fs)]

<span data-ttu-id="e46ce-126">Un'espressione `if` utilizzata in una sequenza è un filtro.</span><span class="sxs-lookup"><span data-stu-id="e46ce-126">An `if` expression used in a sequence is a filter.</span></span> <span data-ttu-id="e46ce-127">Ad esempio, per generare una sequenza di soli numeri primi, supponendo di avere una funzione `isprime` di tipo `int -> bool`, costruire la sequenza come indicato di seguito.</span><span class="sxs-lookup"><span data-stu-id="e46ce-127">For example, to generate a sequence of only prime numbers, assuming that you have a function `isprime` of type `int -> bool`, construct the sequence as follows.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1506.fs)]

<span data-ttu-id="e46ce-128">Come indicato in precedenza, `do` è necessario in questo caso, perché non esiste un ramo `else` che viene utilizzato con il `if`.</span><span class="sxs-lookup"><span data-stu-id="e46ce-128">As mentioned previously, `do` is required here because there is no `else` branch that goes with the `if`.</span></span> <span data-ttu-id="e46ce-129">Se si tenta di usare `->`, viene restituito un errore che informa che non tutti i rami restituiscono un valore.</span><span class="sxs-lookup"><span data-stu-id="e46ce-129">If you try to use `->`, you'll get an error saying that not all branches return a value.</span></span>

## <a name="the-yield-keyword"></a><span data-ttu-id="e46ce-130">Parola chiave `yield!`</span><span class="sxs-lookup"><span data-stu-id="e46ce-130">The `yield!` keyword</span></span>

<span data-ttu-id="e46ce-131">In alcuni casi può essere utile includere una sequenza di elementi in un'altra sequenza.</span><span class="sxs-lookup"><span data-stu-id="e46ce-131">Sometimes, you may wish to include a sequence of elements into another sequence.</span></span> <span data-ttu-id="e46ce-132">Per includere una sequenza in un'altra sequenza, è necessario usare la parola chiave `yield!`:</span><span class="sxs-lookup"><span data-stu-id="e46ce-132">To include a sequence within another sequence, you'll need to use the `yield!` keyword:</span></span>

```fsharp
// Repeats '1 2 3 4 5' ten times
seq {
    for _ in 1..10 do
        yield! seq { 1; 2; 3; 4; 5}
}
```

<span data-ttu-id="e46ce-133">Un altro modo per considerare `yield!` è che rende flat una sequenza interna e quindi lo include nella sequenza che lo contiene.</span><span class="sxs-lookup"><span data-stu-id="e46ce-133">Another way of thinking of `yield!` is that it flattens an inner sequence and then includes that in the containing sequence.</span></span>

<span data-ttu-id="e46ce-134">Quando si usa `yield!` in un'espressione, tutti gli altri valori singoli devono usare la parola chiave `yield`:</span><span class="sxs-lookup"><span data-stu-id="e46ce-134">When `yield!` is used in an expression, all other single values must use the `yield` keyword:</span></span>

```fsharp
// Combine repeated values with their values
seq {
    for x in 1..10 do
        yield x
        yield! seq { for i in 1..x -> i}
}
```

<span data-ttu-id="e46ce-135">Se si specifica solo `x` nell'esempio precedente, la sequenza non genera alcun valore.</span><span class="sxs-lookup"><span data-stu-id="e46ce-135">Specifying only `x` in the previous example will result in the sequence generating no values.</span></span>

## <a name="examples"></a><span data-ttu-id="e46ce-136">Esempi</span><span class="sxs-lookup"><span data-stu-id="e46ce-136">Examples</span></span>

<span data-ttu-id="e46ce-137">Nel primo esempio viene utilizzata un'espressione di sequenza contenente un'iterazione, un filtro e un yield per generare una matrice.</span><span class="sxs-lookup"><span data-stu-id="e46ce-137">The first example uses a sequence expression that contains an iteration, a filter, and a yield to generate an array.</span></span> <span data-ttu-id="e46ce-138">Questo codice stampa una sequenza di numeri primi compresi tra 1 e 100 nella console.</span><span class="sxs-lookup"><span data-stu-id="e46ce-138">This code prints a sequence of prime numbers between 1 and 100 to the console.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1507.fs)]

<span data-ttu-id="e46ce-139">Nell'esempio seguente viene creata una tabella di moltiplicazione costituita da tuple di tre elementi, ognuno costituito da due fattori e dal prodotto:</span><span class="sxs-lookup"><span data-stu-id="e46ce-139">The following example creates a multiplication table that consists of tuples of three elements, each consisting of two factors and the product:</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1508.fs)]

<span data-ttu-id="e46ce-140">Nell'esempio seguente viene illustrato l'utilizzo di `yield!` per combinare singole sequenze in un'unica sequenza finale.</span><span class="sxs-lookup"><span data-stu-id="e46ce-140">The following example demonstrates the use of `yield!` to combine individual sequences into a single final sequence.</span></span> <span data-ttu-id="e46ce-141">In questo caso, le sequenze per ogni sottoalbero in un albero binario vengono concatenate in una funzione ricorsiva per produrre la sequenza finale.</span><span class="sxs-lookup"><span data-stu-id="e46ce-141">In this case, the sequences for each subtree in a binary tree are concatenated in a recursive function to produce the final sequence.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1509.fs)]

## <a name="using-sequences"></a><span data-ttu-id="e46ce-142">Utilizzo di sequenze</span><span class="sxs-lookup"><span data-stu-id="e46ce-142">Using Sequences</span></span>

<span data-ttu-id="e46ce-143">Le sequenze supportano molte delle stesse funzioni degli [elenchi](lists.md).</span><span class="sxs-lookup"><span data-stu-id="e46ce-143">Sequences support many of the same functions as [lists](lists.md).</span></span> <span data-ttu-id="e46ce-144">Le sequenze supportano anche operazioni quali il raggruppamento e il conteggio tramite funzioni di generazione di chiavi.</span><span class="sxs-lookup"><span data-stu-id="e46ce-144">Sequences also support operations such as grouping and counting by using key-generating functions.</span></span> <span data-ttu-id="e46ce-145">Le sequenze supportano anche funzioni più diverse per l'estrazione di sottosequenze.</span><span class="sxs-lookup"><span data-stu-id="e46ce-145">Sequences also support more diverse functions for extracting subsequences.</span></span>

<span data-ttu-id="e46ce-146">Molti tipi di dati, ad esempio elenchi, matrici, set e mappe, sono sequenze implicite perché sono raccolte enumerabili.</span><span class="sxs-lookup"><span data-stu-id="e46ce-146">Many data types, such as lists, arrays, sets, and maps are implicitly sequences because they are enumerable collections.</span></span> <span data-ttu-id="e46ce-147">Una funzione che accetta una sequenza come argomento funziona con uno qualsiasi dei tipi di F# dati comuni, oltre a qualsiasi tipo di dati .NET che implementa `System.Collections.Generic.IEnumerable<'T>`.</span><span class="sxs-lookup"><span data-stu-id="e46ce-147">A function that takes a sequence as an argument works with any of the common F# data types, in addition to any .NET data type that implements `System.Collections.Generic.IEnumerable<'T>`.</span></span> <span data-ttu-id="e46ce-148">A differenza di una funzione che accetta un elenco come argomento, che può solo prendere elenchi.</span><span class="sxs-lookup"><span data-stu-id="e46ce-148">Contrast this to a function that takes a list as an argument, which can only take lists.</span></span> <span data-ttu-id="e46ce-149">Il tipo `seq<'T>` è un'abbreviazione di tipo per `IEnumerable<'T>`.</span><span class="sxs-lookup"><span data-stu-id="e46ce-149">The type `seq<'T>` is a type abbreviation for `IEnumerable<'T>`.</span></span> <span data-ttu-id="e46ce-150">Ciò significa che qualsiasi tipo che implementa l'`System.Collections.Generic.IEnumerable<'T>`generica, che include matrici, elenchi, set e mappe in F#e anche la maggior parte dei tipi di raccolte .NET, è compatibile con il tipo di `seq` e può essere usato ovunque sia prevista una sequenza.</span><span class="sxs-lookup"><span data-stu-id="e46ce-150">This means that any type that implements the generic `System.Collections.Generic.IEnumerable<'T>`, which includes arrays, lists, sets, and maps in F#, and also most .NET collection types, is compatible with the `seq` type and can be used wherever a sequence is expected.</span></span>

## <a name="module-functions"></a><span data-ttu-id="e46ce-151">Funzioni di modulo</span><span class="sxs-lookup"><span data-stu-id="e46ce-151">Module Functions</span></span>

<span data-ttu-id="e46ce-152">Il [modulo Seq](https://msdn.microsoft.com/library/54e8f059-ca52-4632-9ae9-49685ee9b684) nello [spazio dei nomi Microsoft. FSharp. Collections](https://msdn.microsoft.com/library/24f64e5f-5030-47d0-9759-8d3e398ed13f) contiene funzioni per l'utilizzo delle sequenze.</span><span class="sxs-lookup"><span data-stu-id="e46ce-152">The [Seq module](https://msdn.microsoft.com/library/54e8f059-ca52-4632-9ae9-49685ee9b684) in the [Microsoft.FSharp.Collections namespace](https://msdn.microsoft.com/library/24f64e5f-5030-47d0-9759-8d3e398ed13f) contains functions for working with sequences.</span></span> <span data-ttu-id="e46ce-153">Queste funzioni funzionano anche con elenchi, matrici, mappe e set, perché tutti questi tipi sono enumerabili e pertanto possono essere considerati come sequenze.</span><span class="sxs-lookup"><span data-stu-id="e46ce-153">These functions work with lists, arrays, maps, and sets as well, because all of those types are enumerable, and therefore can be treated as sequences.</span></span>

## <a name="creating-sequences"></a><span data-ttu-id="e46ce-154">Creazione di sequenze</span><span class="sxs-lookup"><span data-stu-id="e46ce-154">Creating Sequences</span></span>

<span data-ttu-id="e46ce-155">È possibile creare sequenze usando espressioni di sequenza, come descritto in precedenza, oppure usando determinate funzioni.</span><span class="sxs-lookup"><span data-stu-id="e46ce-155">You can create sequences by using sequence expressions, as described previously, or by using certain functions.</span></span>

<span data-ttu-id="e46ce-156">È possibile creare una sequenza vuota utilizzando [Seq. Empty](https://msdn.microsoft.com/library/3c7f1c69-6117-4782-b2da-0e04d6854f59)oppure è possibile creare una sequenza di un solo elemento specificato utilizzando [Seq. Singleton](https://msdn.microsoft.com/library/9b8cc460-a282-4ec5-b29a-630ab17e9de7).</span><span class="sxs-lookup"><span data-stu-id="e46ce-156">You can create an empty sequence by using [Seq.empty](https://msdn.microsoft.com/library/3c7f1c69-6117-4782-b2da-0e04d6854f59), or you can create a sequence of just one specified element by using [Seq.singleton](https://msdn.microsoft.com/library/9b8cc460-a282-4ec5-b29a-630ab17e9de7).</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet9.fs)]

<span data-ttu-id="e46ce-157">È possibile utilizzare [Seq. init](https://msdn.microsoft.com/library/059de69d-812c-4f8e-be86-88aa72101576) per creare una sequenza per la quale gli elementi vengono creati utilizzando una funzione fornita dall'utente.</span><span class="sxs-lookup"><span data-stu-id="e46ce-157">You can use [Seq.init](https://msdn.microsoft.com/library/059de69d-812c-4f8e-be86-88aa72101576) to create a sequence for which the elements are created by using a function that you provide.</span></span> <span data-ttu-id="e46ce-158">È anche possibile specificare una dimensione per la sequenza.</span><span class="sxs-lookup"><span data-stu-id="e46ce-158">You also provide a size for the sequence.</span></span> <span data-ttu-id="e46ce-159">Questa funzione è analoga a [List. init](https://msdn.microsoft.com/library/dd38c096-0ea8-4858-be6b-794b90418b83), ad eccezione del fatto che gli elementi non vengono creati fino a quando non si scorre la sequenza.</span><span class="sxs-lookup"><span data-stu-id="e46ce-159">This function is just like [List.init](https://msdn.microsoft.com/library/dd38c096-0ea8-4858-be6b-794b90418b83), except that the elements are not created until you iterate through the sequence.</span></span> <span data-ttu-id="e46ce-160">Il codice seguente illustra l'uso di `Seq.init`.</span><span class="sxs-lookup"><span data-stu-id="e46ce-160">The following code illustrates the use of `Seq.init`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet10.fs)]

<span data-ttu-id="e46ce-161">L'output è</span><span class="sxs-lookup"><span data-stu-id="e46ce-161">The output is</span></span>

```console
0 10 20 30 40
```

<span data-ttu-id="e46ce-162">Utilizzando la funzione [Seq. ofArray](https://msdn.microsoft.com/library/299cd4d9-be72-4511-aac8-089e1ddaac99) e [Seq.&#60;ofList&#62; t](https://msdn.microsoft.com/visualfsharpdocs/conceptual/seq.oflist%5b%27t%5d-function-%5bfsharp%5d), è possibile creare sequenze da matrici ed elenchi.</span><span class="sxs-lookup"><span data-stu-id="e46ce-162">By using [Seq.ofArray](https://msdn.microsoft.com/library/299cd4d9-be72-4511-aac8-089e1ddaac99) and [Seq.ofList&#60;'T&#62; Function](https://msdn.microsoft.com/visualfsharpdocs/conceptual/seq.oflist%5b%27t%5d-function-%5bfsharp%5d), you can create sequences from arrays and lists.</span></span> <span data-ttu-id="e46ce-163">Tuttavia, è anche possibile convertire matrici ed elenchi in sequenze utilizzando un operatore cast.</span><span class="sxs-lookup"><span data-stu-id="e46ce-163">However, you can also convert arrays and lists to sequences by using a cast operator.</span></span> <span data-ttu-id="e46ce-164">Entrambe le tecniche sono illustrate nel codice seguente.</span><span class="sxs-lookup"><span data-stu-id="e46ce-164">Both techniques are shown in the following code.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet11.fs)]

<span data-ttu-id="e46ce-165">Utilizzando [Seq. Cast](https://msdn.microsoft.com/library/1d087db3-a8b2-41dd-8ddc-227544529334), è possibile creare una sequenza da una raccolta con tipizzazione debole, ad esempio quelle definite in `System.Collections`.</span><span class="sxs-lookup"><span data-stu-id="e46ce-165">By using [Seq.cast](https://msdn.microsoft.com/library/1d087db3-a8b2-41dd-8ddc-227544529334), you can create a sequence from a weakly typed collection, such as those defined in `System.Collections`.</span></span> <span data-ttu-id="e46ce-166">Tali raccolte con tipizzazione debole hanno il tipo di elemento `System.Object` e vengono enumerate usando il tipo di `System.Collections.Generic.IEnumerable&#96;1` non generico.</span><span class="sxs-lookup"><span data-stu-id="e46ce-166">Such weakly typed collections have the element type `System.Object` and are enumerated by using the non-generic `System.Collections.Generic.IEnumerable&#96;1` type.</span></span> <span data-ttu-id="e46ce-167">Il codice seguente illustra l'uso di `Seq.cast` per convertire una `System.Collections.ArrayList` in una sequenza.</span><span class="sxs-lookup"><span data-stu-id="e46ce-167">The following code illustrates the use of `Seq.cast` to convert an `System.Collections.ArrayList` into a sequence.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet12.fs)]

<span data-ttu-id="e46ce-168">È possibile definire sequenze infinite usando la funzione [Seq. initInfinite (](https://msdn.microsoft.com/library/d1804e53-da92-48ec-8d6e-57eaf4c62bef) .</span><span class="sxs-lookup"><span data-stu-id="e46ce-168">You can define infinite sequences by using the [Seq.initInfinite](https://msdn.microsoft.com/library/d1804e53-da92-48ec-8d6e-57eaf4c62bef) function.</span></span> <span data-ttu-id="e46ce-169">Per una sequenza di questo tipo, è necessario fornire una funzione che genera ogni elemento dall'indice dell'elemento.</span><span class="sxs-lookup"><span data-stu-id="e46ce-169">For such a sequence, you provide a function that generates each element from the index of the element.</span></span> <span data-ttu-id="e46ce-170">Sono possibili sequenze infinite a causa della valutazione lazy; gli elementi vengono creati in base alle esigenze chiamando la funzione specificata.</span><span class="sxs-lookup"><span data-stu-id="e46ce-170">Infinite sequences are possible because of lazy evaluation; elements are created as needed by calling the function that you specify.</span></span> <span data-ttu-id="e46ce-171">Nell'esempio di codice seguente viene prodotta una sequenza infinita di numeri a virgola mobile, in questo caso la serie alternata di reciproci di quadrati di interi consecutivi.</span><span class="sxs-lookup"><span data-stu-id="e46ce-171">The following code example produces an infinite sequence of floating point numbers, in this case the alternating series of reciprocals of squares of successive integers.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet13.fs)]

<span data-ttu-id="e46ce-172">[Seq. unfold](https://msdn.microsoft.com/library/7d9232fc-742e-42bc-bdf7-6f130f0eff21) genera una sequenza da una funzione di calcolo che accetta uno stato e la trasforma per produrre ogni elemento successivo nella sequenza.</span><span class="sxs-lookup"><span data-stu-id="e46ce-172">[Seq.unfold](https://msdn.microsoft.com/library/7d9232fc-742e-42bc-bdf7-6f130f0eff21) generates a sequence from a computation function that takes a state and transforms it to produce each subsequent element in the sequence.</span></span> <span data-ttu-id="e46ce-173">Lo stato è solo un valore utilizzato per calcolare ogni elemento e può essere modificato quando ogni elemento viene calcolato.</span><span class="sxs-lookup"><span data-stu-id="e46ce-173">The state is just a value that is used to compute each element, and can change as each element is computed.</span></span> <span data-ttu-id="e46ce-174">Il secondo argomento per `Seq.unfold` è il valore iniziale utilizzato per avviare la sequenza.</span><span class="sxs-lookup"><span data-stu-id="e46ce-174">The second argument to `Seq.unfold` is the initial value that is used to start the sequence.</span></span> <span data-ttu-id="e46ce-175">`Seq.unfold` usa un tipo di opzione per lo stato, che consente di terminare la sequenza restituendo il valore di `None`.</span><span class="sxs-lookup"><span data-stu-id="e46ce-175">`Seq.unfold` uses an option type for the state, which enables you to terminate the sequence by returning the `None` value.</span></span> <span data-ttu-id="e46ce-176">Nel codice seguente vengono illustrati due esempi di sequenze, `seq1` e `fib`, generati da un'operazione `unfold`.</span><span class="sxs-lookup"><span data-stu-id="e46ce-176">The following code shows two examples of sequences, `seq1` and `fib`, that are generated by an `unfold` operation.</span></span> <span data-ttu-id="e46ce-177">Il primo, `seq1`, è semplicemente una sequenza semplice con numeri fino a 20.</span><span class="sxs-lookup"><span data-stu-id="e46ce-177">The first, `seq1`, is just a simple sequence with numbers up to 20.</span></span> <span data-ttu-id="e46ce-178">Il secondo `fib`utilizza `unfold` per calcolare la sequenza di Fibonacci.</span><span class="sxs-lookup"><span data-stu-id="e46ce-178">The second, `fib`, uses `unfold` to compute the Fibonacci sequence.</span></span> <span data-ttu-id="e46ce-179">Poiché ogni elemento nella sequenza di Fibonacci è la somma dei due numeri di Fibonacci precedenti, il valore di stato è una tupla costituita dai due numeri precedenti nella sequenza.</span><span class="sxs-lookup"><span data-stu-id="e46ce-179">Because each element in the Fibonacci sequence is the sum of the previous two Fibonacci numbers, the state value is a tuple that consists of the previous two numbers in the sequence.</span></span> <span data-ttu-id="e46ce-180">Il valore iniziale è `(1,1)`, i primi due numeri nella sequenza.</span><span class="sxs-lookup"><span data-stu-id="e46ce-180">The initial value is `(1,1)`, the first two numbers in the sequence.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet14.fs)]

<span data-ttu-id="e46ce-181">L'output è indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="e46ce-181">The output is as follows:</span></span>

```console
The sequence seq1 contains numbers from 0 to 20.

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

The sequence fib contains Fibonacci numbers.

2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
```

<span data-ttu-id="e46ce-182">Il codice seguente è un esempio che usa molte delle funzioni del modulo Sequence descritte qui per generare e calcolare i valori delle sequenze infinite.</span><span class="sxs-lookup"><span data-stu-id="e46ce-182">The following code is an example that uses many of the sequence module functions described here to generate and compute the values of infinite sequences.</span></span> <span data-ttu-id="e46ce-183">L'esecuzione del codice potrebbe richiedere alcuni minuti.</span><span class="sxs-lookup"><span data-stu-id="e46ce-183">The code might take a few minutes to run.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet15.fs)]

## <a name="searching-and-finding-elements"></a><span data-ttu-id="e46ce-184">Ricerca e ricerca di elementi</span><span class="sxs-lookup"><span data-stu-id="e46ce-184">Searching and Finding Elements</span></span>

<span data-ttu-id="e46ce-185">Le sequenze supportano la funzionalità disponibile con gli elenchi: [Seq. Exists](https://msdn.microsoft.com/library/428c97bf-599d-4c39-a5b9-f8717c198ad1), [Seq. exists2](https://msdn.microsoft.com/library/efdf14a4-27f7-4dc1-9281-52639e66d565), [Seq. Find](https://msdn.microsoft.com/library/02c21ecd-97e5-4e99-a4c1-b4d0b730b7d8), [Seq. FindIndex](https://msdn.microsoft.com/library/96dfe86b-df15-4d92-8316-7cd6055e09f3), [Seq. pick](https://msdn.microsoft.com/library/a87bc771-55f7-43f9-94f9-33d8f9bf325d), [Seq. tryFind](https://msdn.microsoft.com/library/ac43c6f5-4dc7-4e9a-a222-00b5736aee47)e [Seq. tryFindIndex](https://msdn.microsoft.com/library/c357b221-edf6-4f68-bf40-82a3156d945a).</span><span class="sxs-lookup"><span data-stu-id="e46ce-185">Sequences support functionality available with lists: [Seq.exists](https://msdn.microsoft.com/library/428c97bf-599d-4c39-a5b9-f8717c198ad1), [Seq.exists2](https://msdn.microsoft.com/library/efdf14a4-27f7-4dc1-9281-52639e66d565), [Seq.find](https://msdn.microsoft.com/library/02c21ecd-97e5-4e99-a4c1-b4d0b730b7d8), [Seq.findIndex](https://msdn.microsoft.com/library/96dfe86b-df15-4d92-8316-7cd6055e09f3), [Seq.pick](https://msdn.microsoft.com/library/a87bc771-55f7-43f9-94f9-33d8f9bf325d), [Seq.tryFind](https://msdn.microsoft.com/library/ac43c6f5-4dc7-4e9a-a222-00b5736aee47), and [Seq.tryFindIndex](https://msdn.microsoft.com/library/c357b221-edf6-4f68-bf40-82a3156d945a).</span></span> <span data-ttu-id="e46ce-186">Le versioni di queste funzioni disponibili per le sequenze valutano la sequenza solo fino all'elemento in cui viene eseguita la ricerca.</span><span class="sxs-lookup"><span data-stu-id="e46ce-186">The versions of these functions that are available for sequences evaluate the sequence only up to the element that is being searched for.</span></span> <span data-ttu-id="e46ce-187">Per esempi, vedere gli [elenchi](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d).</span><span class="sxs-lookup"><span data-stu-id="e46ce-187">For examples, see [Lists](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d).</span></span>

## <a name="obtaining-subsequences"></a><span data-ttu-id="e46ce-188">Acquisizione di sottosequenze</span><span class="sxs-lookup"><span data-stu-id="e46ce-188">Obtaining Subsequences</span></span>

<span data-ttu-id="e46ce-189">[Seq. Filter](https://msdn.microsoft.com/library/7f2e9850-a660-460c-9831-3bbff5613770) e [Seq. Choose](https://msdn.microsoft.com/library/63b83b06-4b24-4239-bf69-a2c12d891395) sono simili alle funzioni corrispondenti disponibili per gli elenchi, tranne per il fatto che il filtro e la scelta non vengono eseguiti fino a quando non vengono valutati gli elementi della sequenza.</span><span class="sxs-lookup"><span data-stu-id="e46ce-189">[Seq.filter](https://msdn.microsoft.com/library/7f2e9850-a660-460c-9831-3bbff5613770) and [Seq.choose](https://msdn.microsoft.com/library/63b83b06-4b24-4239-bf69-a2c12d891395) are like the corresponding functions that are available for lists, except that the filtering and choosing does not occur until the sequence elements are evaluated.</span></span>

<span data-ttu-id="e46ce-190">[Seq. Truncate](https://msdn.microsoft.com/library/1892dfeb-308e-45e2-857a-3c3405d02244) crea una sequenza da un'altra sequenza, ma limita la sequenza a un numero specificato di elementi.</span><span class="sxs-lookup"><span data-stu-id="e46ce-190">[Seq.truncate](https://msdn.microsoft.com/library/1892dfeb-308e-45e2-857a-3c3405d02244) creates a sequence from another sequence, but limits the sequence to a specified number of elements.</span></span> <span data-ttu-id="e46ce-191">[Seq. Take](https://msdn.microsoft.com/library/6e75f701-640b-4c4a-9d63-4313fc090596) crea una nuova sequenza che contiene solo un numero specificato di elementi dall'inizio di una sequenza.</span><span class="sxs-lookup"><span data-stu-id="e46ce-191">[Seq.take](https://msdn.microsoft.com/library/6e75f701-640b-4c4a-9d63-4313fc090596) creates a new sequence that contains only a specified number of elements from the start of a sequence.</span></span> <span data-ttu-id="e46ce-192">Se nella sequenza sono presenti meno elementi di quelli specificati, `Seq.take` genera un'`System.InvalidOperationException`.</span><span class="sxs-lookup"><span data-stu-id="e46ce-192">If there are fewer elements in the sequence than you specify to take, `Seq.take` throws a `System.InvalidOperationException`.</span></span> <span data-ttu-id="e46ce-193">La differenza tra `Seq.take` e `Seq.truncate` è che `Seq.truncate` non genera un errore se il numero di elementi è inferiore al numero specificato.</span><span class="sxs-lookup"><span data-stu-id="e46ce-193">The difference between `Seq.take` and `Seq.truncate` is that `Seq.truncate` does not produce an error if the number of elements is fewer than the number you specify.</span></span>

<span data-ttu-id="e46ce-194">Il codice seguente illustra il comportamento di e le differenze tra `Seq.truncate` e `Seq.take`.</span><span class="sxs-lookup"><span data-stu-id="e46ce-194">The following code shows the behavior of and differences between `Seq.truncate` and `Seq.take`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet16.fs)]

<span data-ttu-id="e46ce-195">L'output, prima che si verifichi l'errore, è il seguente.</span><span class="sxs-lookup"><span data-stu-id="e46ce-195">The output, before the error occurs, is as follows.</span></span>

```console
1 4 9 16 25
1 4 9 16 25 36 49 64 81 100
1 4 9 16 25
1 4 9 16 25 36 49 64 81 100
```

<span data-ttu-id="e46ce-196">Utilizzando [Seq. TakeWhile](https://msdn.microsoft.com/library/19eea4ce-66e0-4353-b015-72eb03421d92), è possibile specificare una funzione di predicato (funzione booleana) e creare una sequenza da un'altra sequenza costituita dagli elementi della sequenza originale per cui il predicato è `true`, ma si arresta prima del primo elemento per il predicato restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="e46ce-196">By using [Seq.takeWhile](https://msdn.microsoft.com/library/19eea4ce-66e0-4353-b015-72eb03421d92), you can specify a predicate function (a Boolean function) and create a sequence from another sequence made up of those elements of the original sequence for which the predicate is `true`, but stop before the first element for which the predicate returns `false`.</span></span> <span data-ttu-id="e46ce-197">[Seq. Skip](https://msdn.microsoft.com/library/b4eb3f08-8594-4d17-8180-852c6c688bf1) restituisce una sequenza che ignora un numero specificato di primi elementi di un'altra sequenza e restituisce gli elementi rimanenti.</span><span class="sxs-lookup"><span data-stu-id="e46ce-197">[Seq.skip](https://msdn.microsoft.com/library/b4eb3f08-8594-4d17-8180-852c6c688bf1) returns a sequence that skips a specified number of the first elements of another sequence and returns the remaining elements.</span></span> <span data-ttu-id="e46ce-198">[Seq. SkipWhile](https://msdn.microsoft.com/library/fb729021-2a3c-430f-83c3-0b37526f1a16) restituisce una sequenza che ignora i primi elementi di un'altra sequenza purché il predicato restituisca `true`e quindi restituisce gli elementi rimanenti, a partire dal primo elemento per il quale il predicato restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="e46ce-198">[Seq.skipWhile](https://msdn.microsoft.com/library/fb729021-2a3c-430f-83c3-0b37526f1a16) returns a sequence that skips the first elements of another sequence as long as the predicate returns `true`, and then returns the remaining elements, starting with the first element for which the predicate returns `false`.</span></span>

<span data-ttu-id="e46ce-199">Nell'esempio di codice seguente viene illustrato il comportamento di e le differenze tra `Seq.takeWhile`, `Seq.skip`e `Seq.skipWhile`.</span><span class="sxs-lookup"><span data-stu-id="e46ce-199">The following code example illustrates the behavior of and differences between `Seq.takeWhile`, `Seq.skip`, and `Seq.skipWhile`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet17.fs)]

<span data-ttu-id="e46ce-200">L'output è indicato di seguito.</span><span class="sxs-lookup"><span data-stu-id="e46ce-200">The output is as follows.</span></span>

```console
1 4 9
36 49 64 81 100
16 25 36 49 64 81 100
```

## <a name="transforming-sequences"></a><span data-ttu-id="e46ce-201">Trasformazione di sequenze</span><span class="sxs-lookup"><span data-stu-id="e46ce-201">Transforming Sequences</span></span>

<span data-ttu-id="e46ce-202">[Seq. pairwise](https://msdn.microsoft.com/library/210dcf26-4e24-4d83-af6d-a8288b2ae4b1) crea una nuova sequenza in cui gli elementi successivi della sequenza di input vengono raggruppati in Tuple.</span><span class="sxs-lookup"><span data-stu-id="e46ce-202">[Seq.pairwise](https://msdn.microsoft.com/library/210dcf26-4e24-4d83-af6d-a8288b2ae4b1) creates a new sequence in which successive elements of the input sequence are grouped into tuples.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet18.fs)]

<span data-ttu-id="e46ce-203">[Seq. windowed](https://msdn.microsoft.com/library/8b565b8f-d645-4dba-be22-099075fe4744) è come `Seq.pairwise`, ad eccezione del fatto che anziché produrre una sequenza di tuple, produce una sequenza di matrici che contengono copie di elementi adiacenti (una *finestra*) dalla sequenza.</span><span class="sxs-lookup"><span data-stu-id="e46ce-203">[Seq.windowed](https://msdn.microsoft.com/library/8b565b8f-d645-4dba-be22-099075fe4744) is like `Seq.pairwise`, except that instead of producing a sequence of tuples, it produces a sequence of arrays that contain copies of adjacent elements (a *window*) from the sequence.</span></span> <span data-ttu-id="e46ce-204">È possibile specificare il numero di elementi adiacenti che si desidera includere in ogni matrice.</span><span class="sxs-lookup"><span data-stu-id="e46ce-204">You specify the number of adjacent elements you want in each array.</span></span>

<span data-ttu-id="e46ce-205">L'esempio di codice seguente illustra l'uso di `Seq.windowed`.</span><span class="sxs-lookup"><span data-stu-id="e46ce-205">The following code example demonstrates the use of `Seq.windowed`.</span></span> <span data-ttu-id="e46ce-206">In questo caso il numero di elementi nella finestra è 3.</span><span class="sxs-lookup"><span data-stu-id="e46ce-206">In this case the number of elements in the window is 3.</span></span> <span data-ttu-id="e46ce-207">Nell'esempio viene usato `printSeq`, definito nell'esempio di codice precedente.</span><span class="sxs-lookup"><span data-stu-id="e46ce-207">The example uses `printSeq`, which is defined in the previous code example.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet180.fs)]

<span data-ttu-id="e46ce-208">L'output è indicato di seguito.</span><span class="sxs-lookup"><span data-stu-id="e46ce-208">The output is as follows.</span></span>

<span data-ttu-id="e46ce-209">Sequenza iniziale:</span><span class="sxs-lookup"><span data-stu-id="e46ce-209">Initial sequence:</span></span>

```console
1.0 1.5 2.0 1.5 1.0 1.5

Windows of length 3:
[|1.0; 1.5; 2.0|] [|1.5; 2.0; 1.5|] [|2.0; 1.5; 1.0|] [|1.5; 1.0; 1.5|]

Moving average:
1.5 1.666666667 1.5 1.333333333
```

## <a name="operations-with-multiple-sequences"></a><span data-ttu-id="e46ce-210">Operazioni con più sequenze</span><span class="sxs-lookup"><span data-stu-id="e46ce-210">Operations with Multiple Sequences</span></span>

<span data-ttu-id="e46ce-211">[Seq. zip](https://msdn.microsoft.com/library/0a5df8bf-0d48-44ce-bff4-e8ef1df5bca4) e [Seq. zip3](https://msdn.microsoft.com/library/ef13bebb-22ae-4eb9-873b-87dd29154d16) accettano due o tre sequenze e producono una sequenza di Tuple.</span><span class="sxs-lookup"><span data-stu-id="e46ce-211">[Seq.zip](https://msdn.microsoft.com/library/0a5df8bf-0d48-44ce-bff4-e8ef1df5bca4) and [Seq.zip3](https://msdn.microsoft.com/library/ef13bebb-22ae-4eb9-873b-87dd29154d16) take two or three sequences and produce a sequence of tuples.</span></span> <span data-ttu-id="e46ce-212">Queste funzioni sono simili alle funzioni corrispondenti disponibili per gli [elenchi](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d).</span><span class="sxs-lookup"><span data-stu-id="e46ce-212">These functions are like the corresponding functions available for [lists](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d).</span></span> <span data-ttu-id="e46ce-213">Non esiste alcuna funzionalità corrispondente per separare una sequenza in due o più sequenze.</span><span class="sxs-lookup"><span data-stu-id="e46ce-213">There is no corresponding functionality to separate one sequence into two or more sequences.</span></span> <span data-ttu-id="e46ce-214">Se questa funzionalità è necessaria per una sequenza, convertire la sequenza in un elenco e usare [List. unzip](https://msdn.microsoft.com/library/639db80c-41b5-45bb-a6b4-1eaa04d61d21).</span><span class="sxs-lookup"><span data-stu-id="e46ce-214">If you need this functionality for a sequence, convert the sequence to a list and use [List.unzip](https://msdn.microsoft.com/library/639db80c-41b5-45bb-a6b4-1eaa04d61d21).</span></span>

## <a name="sorting-comparing-and-grouping"></a><span data-ttu-id="e46ce-215">Ordinamento, confronto e raggruppamento</span><span class="sxs-lookup"><span data-stu-id="e46ce-215">Sorting, Comparing, and Grouping</span></span>

<span data-ttu-id="e46ce-216">Le funzioni di ordinamento supportate per gli elenchi funzionano anche con le sequenze.</span><span class="sxs-lookup"><span data-stu-id="e46ce-216">The sorting functions supported for lists also work with sequences.</span></span> <span data-ttu-id="e46ce-217">Sono inclusi [Seq. Sort](https://msdn.microsoft.com/library/327ea595-e77c-4529-b61e-8c6cbf5ec92e) e [Seq. sortBy](https://msdn.microsoft.com/library/4f8b4fb9-bf20-49d9-b4ee-dcc906c8208f).</span><span class="sxs-lookup"><span data-stu-id="e46ce-217">This includes [Seq.sort](https://msdn.microsoft.com/library/327ea595-e77c-4529-b61e-8c6cbf5ec92e) and [Seq.sortBy](https://msdn.microsoft.com/library/4f8b4fb9-bf20-49d9-b4ee-dcc906c8208f).</span></span> <span data-ttu-id="e46ce-218">Queste funzioni eseguono l'iterazione dell'intera sequenza.</span><span class="sxs-lookup"><span data-stu-id="e46ce-218">These functions iterate through the whole sequence.</span></span>

<span data-ttu-id="e46ce-219">Per confrontare due sequenze, utilizzare la funzione [Seq. compareWith](https://msdn.microsoft.com/library/5a740135-0b3a-4545-816f-8f91cc31290f) .</span><span class="sxs-lookup"><span data-stu-id="e46ce-219">You compare two sequences by using the [Seq.compareWith](https://msdn.microsoft.com/library/5a740135-0b3a-4545-816f-8f91cc31290f) function.</span></span> <span data-ttu-id="e46ce-220">La funzione Confronta gli elementi successivi a sua volta e si interrompe quando rileva la prima coppia diversa.</span><span class="sxs-lookup"><span data-stu-id="e46ce-220">The function compares successive elements in turn, and stops when it encounters the first unequal pair.</span></span> <span data-ttu-id="e46ce-221">Eventuali elementi aggiuntivi non contribuiscono al confronto.</span><span class="sxs-lookup"><span data-stu-id="e46ce-221">Any additional elements do not contribute to the comparison.</span></span>

<span data-ttu-id="e46ce-222">Il codice seguente illustra l'uso di `Seq.compareWith`.</span><span class="sxs-lookup"><span data-stu-id="e46ce-222">The following code shows the use of `Seq.compareWith`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet19.fs)]

<span data-ttu-id="e46ce-223">Nel codice precedente viene calcolato ed esaminato solo il primo elemento e il risultato è-1.</span><span class="sxs-lookup"><span data-stu-id="e46ce-223">In the previous code, only the first element is computed and examined, and the result is -1.</span></span>

<span data-ttu-id="e46ce-224">[Seq. countBy](https://msdn.microsoft.com/library/721702a5-150e-4fe8-81cd-ffbf8476cc1f) accetta una funzione che genera un valore denominato *chiave* per ogni elemento.</span><span class="sxs-lookup"><span data-stu-id="e46ce-224">[Seq.countBy](https://msdn.microsoft.com/library/721702a5-150e-4fe8-81cd-ffbf8476cc1f) takes a function that generates a value called a *key* for each element.</span></span> <span data-ttu-id="e46ce-225">Viene generata una chiave per ogni elemento chiamando questa funzione su ogni elemento.</span><span class="sxs-lookup"><span data-stu-id="e46ce-225">A key is generated for each element by calling this function on each element.</span></span> <span data-ttu-id="e46ce-226">`Seq.countBy` restituisce quindi una sequenza che contiene i valori di chiave e un conteggio del numero di elementi che hanno generato ogni valore della chiave.</span><span class="sxs-lookup"><span data-stu-id="e46ce-226">`Seq.countBy` then returns a sequence that contains the key values, and a count of the number of elements that generated each value of the key.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet201.fs)]

<span data-ttu-id="e46ce-227">L'output è indicato di seguito.</span><span class="sxs-lookup"><span data-stu-id="e46ce-227">The output is as follows.</span></span>

```console
(1, 34) (2, 33) (0, 33)
```

<span data-ttu-id="e46ce-228">L'output precedente mostra che sono presenti 34 elementi della sequenza originale che hanno prodotto la chiave 1, 33 valori che hanno prodotto la chiave 2 e 33 valori che hanno prodotto la chiave 0.</span><span class="sxs-lookup"><span data-stu-id="e46ce-228">The previous output shows that there were 34 elements of the original sequence that produced the key 1, 33 values that produced the key 2, and 33 values that produced the key 0.</span></span>

<span data-ttu-id="e46ce-229">È possibile raggruppare gli elementi di una sequenza chiamando [Seq. GroupBy](https://msdn.microsoft.com/library/d46a04df-1a42-40cc-a368-058c9c5806fd).</span><span class="sxs-lookup"><span data-stu-id="e46ce-229">You can group elements of a sequence by calling [Seq.groupBy](https://msdn.microsoft.com/library/d46a04df-1a42-40cc-a368-058c9c5806fd).</span></span> <span data-ttu-id="e46ce-230">`Seq.groupBy` accetta una sequenza e una funzione che genera una chiave da un elemento.</span><span class="sxs-lookup"><span data-stu-id="e46ce-230">`Seq.groupBy` takes a sequence and a function that generates a key from an element.</span></span> <span data-ttu-id="e46ce-231">La funzione viene eseguita su ogni elemento della sequenza.</span><span class="sxs-lookup"><span data-stu-id="e46ce-231">The function is executed on each element of the sequence.</span></span> <span data-ttu-id="e46ce-232">`Seq.groupBy` restituisce una sequenza di tuple, in cui il primo elemento di ogni tupla è la chiave e la seconda è una sequenza di elementi che producono tale chiave.</span><span class="sxs-lookup"><span data-stu-id="e46ce-232">`Seq.groupBy` returns a sequence of tuples, where the first element of each tuple is the key and the second is a sequence of elements that produce that key.</span></span>

<span data-ttu-id="e46ce-233">Nell'esempio di codice riportato di seguito viene illustrato l'utilizzo di `Seq.groupBy` per partizionare la sequenza di numeri da 1 a 100 in tre gruppi con i valori di chiave DISTINCT 0, 1 e 2.</span><span class="sxs-lookup"><span data-stu-id="e46ce-233">The following code example shows the use of `Seq.groupBy` to partition the sequence of numbers from 1 to 100 into three groups that have the distinct key values 0, 1, and 2.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet202.fs)]

<span data-ttu-id="e46ce-234">L'output è indicato di seguito.</span><span class="sxs-lookup"><span data-stu-id="e46ce-234">The output is as follows.</span></span>

```console
(1, seq [1; 4; 7; 10; ...]) (2, seq [2; 5; 8; 11; ...]) (0, seq [3; 6; 9; 12; ...])
```

<span data-ttu-id="e46ce-235">È possibile creare una sequenza che elimini gli elementi duplicati chiamando [Seq. Distinct](https://msdn.microsoft.com/library/99d01014-7e0e-4e7b-9d0a-41a61d93f401).</span><span class="sxs-lookup"><span data-stu-id="e46ce-235">You can create a sequence that eliminates duplicate elements by calling [Seq.distinct](https://msdn.microsoft.com/library/99d01014-7e0e-4e7b-9d0a-41a61d93f401).</span></span> <span data-ttu-id="e46ce-236">In alternativa, è possibile usare [Seq. distinctBy (](https://msdn.microsoft.com/library/9293293b-9420-49c8-848f-401a9cd49b75), che accetta una funzione di generazione delle chiavi da chiamare su ogni elemento.</span><span class="sxs-lookup"><span data-stu-id="e46ce-236">Or you can use [Seq.distinctBy](https://msdn.microsoft.com/library/9293293b-9420-49c8-848f-401a9cd49b75), which takes a key-generating function to be called on each element.</span></span> <span data-ttu-id="e46ce-237">La sequenza risultante contiene elementi della sequenza originale con chiavi univoche. gli elementi successivi che producono una chiave duplicata per un elemento precedente vengono eliminati.</span><span class="sxs-lookup"><span data-stu-id="e46ce-237">The resulting sequence contains elements of the original sequence that have unique keys; later elements that produce a duplicate key to an earlier element are discarded.</span></span>

<span data-ttu-id="e46ce-238">Nell'esempio di codice riportato di seguito viene illustrato l'utilizzo di `Seq.distinct`.</span><span class="sxs-lookup"><span data-stu-id="e46ce-238">The following code example illustrates the use of `Seq.distinct`.</span></span> <span data-ttu-id="e46ce-239">`Seq.distinct` viene dimostrato generando sequenze che rappresentano numeri binari e quindi mostrando che gli unici elementi distinti sono 0 e 1.</span><span class="sxs-lookup"><span data-stu-id="e46ce-239">`Seq.distinct` is demonstrated by generating sequences that represent binary numbers, and then showing that the only distinct elements are 0 and 1.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet22.fs)]

<span data-ttu-id="e46ce-240">Il codice seguente illustra `Seq.distinctBy` iniziando con una sequenza che contiene numeri negativi e positivi e usando la funzione valore assoluto come funzione di generazione delle chiavi.</span><span class="sxs-lookup"><span data-stu-id="e46ce-240">The following code demonstrates `Seq.distinctBy` by starting with a sequence that contains negative and positive numbers and using the absolute value function as the key-generating function.</span></span> <span data-ttu-id="e46ce-241">Nella sequenza risultante mancano tutti i numeri positivi che corrispondono ai numeri negativi nella sequenza, perché i numeri negativi vengono visualizzati in precedenza nella sequenza e pertanto vengono selezionati al posto dei numeri positivi con lo stesso valore assoluto valore o chiave.</span><span class="sxs-lookup"><span data-stu-id="e46ce-241">The resulting sequence is missing all the positive numbers that correspond to the negative numbers in the sequence, because the negative numbers appear earlier in the sequence and therefore are selected instead of the positive numbers that have the same absolute value, or key.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet23.fs)]

## <a name="readonly-and-cached-sequences"></a><span data-ttu-id="e46ce-242">Sequenze di sola lettura e memorizzate nella cache</span><span class="sxs-lookup"><span data-stu-id="e46ce-242">Readonly and Cached Sequences</span></span>

<span data-ttu-id="e46ce-243">[Seq. ReadOnly](https://msdn.microsoft.com/library/88059cb4-3bb0-4126-9448-fbcd48fe13a7) crea una copia di sola lettura di una sequenza.</span><span class="sxs-lookup"><span data-stu-id="e46ce-243">[Seq.readonly](https://msdn.microsoft.com/library/88059cb4-3bb0-4126-9448-fbcd48fe13a7) creates a read-only copy of a sequence.</span></span> <span data-ttu-id="e46ce-244">`Seq.readonly` è utile quando si dispone di una raccolta di lettura/scrittura, ad esempio una matrice, e non si desidera modificare la raccolta originale.</span><span class="sxs-lookup"><span data-stu-id="e46ce-244">`Seq.readonly` is useful when you have a read-write collection, such as an array, and you do not want to modify the original collection.</span></span> <span data-ttu-id="e46ce-245">Questa funzione può essere utilizzata per mantenere incapsulamento dei dati.</span><span class="sxs-lookup"><span data-stu-id="e46ce-245">This function can be used to preserve data encapsulation.</span></span> <span data-ttu-id="e46ce-246">Nell'esempio di codice seguente viene creato un tipo che contiene una matrice.</span><span class="sxs-lookup"><span data-stu-id="e46ce-246">In the following code example, a type that contains an array is created.</span></span> <span data-ttu-id="e46ce-247">Una proprietà espone la matrice, ma anziché restituire una matrice, restituisce una sequenza creata dalla matrice utilizzando `Seq.readonly`.</span><span class="sxs-lookup"><span data-stu-id="e46ce-247">A property exposes the array, but instead of returning an array, it returns a sequence that is created from the array by using `Seq.readonly`.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet24.fs)]

<span data-ttu-id="e46ce-248">[Seq. cache](https://msdn.microsoft.com/library/d197f9cc-08bf-4986-9869-246e72ca73f0) crea una versione archiviata di una sequenza.</span><span class="sxs-lookup"><span data-stu-id="e46ce-248">[Seq.cache](https://msdn.microsoft.com/library/d197f9cc-08bf-4986-9869-246e72ca73f0) creates a stored version of a sequence.</span></span> <span data-ttu-id="e46ce-249">Utilizzare `Seq.cache` per evitare la rivalutazione di una sequenza o quando si dispone di più thread che utilizzano una sequenza, ma è necessario assicurarsi che ogni elemento venga eseguito una sola volta.</span><span class="sxs-lookup"><span data-stu-id="e46ce-249">Use `Seq.cache` to avoid reevaluation of a sequence, or when you have multiple threads that use a sequence, but you must make sure that each element is acted upon only one time.</span></span> <span data-ttu-id="e46ce-250">Quando si dispone di una sequenza utilizzata da più thread, è possibile avere un thread che enumera e calcola i valori per la sequenza originale e i thread rimanenti possono utilizzare la sequenza memorizzata nella cache.</span><span class="sxs-lookup"><span data-stu-id="e46ce-250">When you have a sequence that is being used by multiple threads, you can have one thread that enumerates and computes the values for the original sequence, and remaining threads can use the cached sequence.</span></span>

## <a name="performing-computations-on-sequences"></a><span data-ttu-id="e46ce-251">Esecuzione di calcoli sulle sequenze</span><span class="sxs-lookup"><span data-stu-id="e46ce-251">Performing Computations on Sequences</span></span>

<span data-ttu-id="e46ce-252">Le operazioni aritmetiche semplici sono simili a quelle degli elenchi, ad esempio [Seq. Average](https://msdn.microsoft.com/library/609d793b-c70f-4e36-9ab4-d928056d65b8), [Seq. Sum](https://msdn.microsoft.com/library/01208515-4880-4358-91f5-af34f66dc77a), [Seq. averageBy](https://msdn.microsoft.com/library/47c855c1-2dbd-415a-885e-b909d9d3e4f8), [Seq. sumBy](https://msdn.microsoft.com/library/68cca78c-94ed-4a45-9b8d-34d2c5f2b1b1)e così via.</span><span class="sxs-lookup"><span data-stu-id="e46ce-252">Simple arithmetic operations are like those of lists, such as [Seq.average](https://msdn.microsoft.com/library/609d793b-c70f-4e36-9ab4-d928056d65b8), [Seq.sum](https://msdn.microsoft.com/library/01208515-4880-4358-91f5-af34f66dc77a), [Seq.averageBy](https://msdn.microsoft.com/library/47c855c1-2dbd-415a-885e-b909d9d3e4f8), [Seq.sumBy](https://msdn.microsoft.com/library/68cca78c-94ed-4a45-9b8d-34d2c5f2b1b1), and so on.</span></span>

<span data-ttu-id="e46ce-253">[Seq. fold](https://msdn.microsoft.com/library/30c4c95a-9563-4c96-bbe1-f7aacfd026e3), [Seq. reduce](https://msdn.microsoft.com/library/a2ad4f64-ac69-47d2-92f0-7173d9dfeae9)e [Seq. Scan](https://msdn.microsoft.com/library/7e2d23e9-f153-4411-a884-b6d415ff627e) sono simili alle funzioni corrispondenti disponibili per gli elenchi.</span><span class="sxs-lookup"><span data-stu-id="e46ce-253">[Seq.fold](https://msdn.microsoft.com/library/30c4c95a-9563-4c96-bbe1-f7aacfd026e3), [Seq.reduce](https://msdn.microsoft.com/library/a2ad4f64-ac69-47d2-92f0-7173d9dfeae9), and [Seq.scan](https://msdn.microsoft.com/library/7e2d23e9-f153-4411-a884-b6d415ff627e) are like the corresponding functions that are available for lists.</span></span> <span data-ttu-id="e46ce-254">Le sequenze supportano un subset delle varianti complete di queste funzioni che elenca il supporto.</span><span class="sxs-lookup"><span data-stu-id="e46ce-254">Sequences support a subset of the full variations of these functions that lists support.</span></span> <span data-ttu-id="e46ce-255">Per ulteriori informazioni ed esempi, vedere la pagina relativa agli [elenchi](lists.md).</span><span class="sxs-lookup"><span data-stu-id="e46ce-255">For more information and examples, see [Lists](lists.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="e46ce-256">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="e46ce-256">See also</span></span>

- [<span data-ttu-id="e46ce-257">Riferimenti per il linguaggio F#</span><span class="sxs-lookup"><span data-stu-id="e46ce-257">F# Language Reference</span></span>](index.md)
- [<span data-ttu-id="e46ce-258">Tipi F#</span><span class="sxs-lookup"><span data-stu-id="e46ce-258">F# Types</span></span>](fsharp-types.md)
