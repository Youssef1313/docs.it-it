---
title: Classi
description: Informazioni sul F# modo in cui le classi sono tipi che rappresentano oggetti che possono avere proprietà, metodi ed eventi.
ms.date: 05/16/2016
ms.openlocfilehash: 5c012d028bc1f89e3e9f5969b3461faab9aad3a0
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/30/2019
ms.locfileid: "68630449"
---
# <a name="classes"></a><span data-ttu-id="6a9d2-103">Classi</span><span class="sxs-lookup"><span data-stu-id="6a9d2-103">Classes</span></span>

<span data-ttu-id="6a9d2-104">*Le classi* sono tipi che rappresentano oggetti che possono avere proprietà, metodi ed eventi.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-104">*Classes* are types that represent objects that can have properties, methods, and events.</span></span>

## <a name="syntax"></a><span data-ttu-id="6a9d2-105">Sintassi</span><span class="sxs-lookup"><span data-stu-id="6a9d2-105">Syntax</span></span>

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a><span data-ttu-id="6a9d2-106">Note</span><span class="sxs-lookup"><span data-stu-id="6a9d2-106">Remarks</span></span>

<span data-ttu-id="6a9d2-107">Le classi rappresentano la descrizione fondamentale dei tipi di oggetto .NET; la classe è il concetto di tipo principale che supporta la programmazione orientata F#a oggetti in.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-107">Classes represent the fundamental description of .NET object types; the class is the primary type concept that supports object-oriented programming in F#.</span></span>

<span data-ttu-id="6a9d2-108">Nella sintassi precedente, `type-name` è qualsiasi identificatore valido.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-108">In the preceding syntax, the `type-name` is any valid identifier.</span></span> <span data-ttu-id="6a9d2-109">Descrive `type-params` i parametri facoltativi di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-109">The `type-params` describes optional generic type parameters.</span></span> <span data-ttu-id="6a9d2-110">È costituito da nomi di parametri di tipo e vincoli racchiusi tra`<` parentesi `>`angolari (e).</span><span class="sxs-lookup"><span data-stu-id="6a9d2-110">It consists of type parameter names and constraints enclosed in angle brackets (`<` and `>`).</span></span> <span data-ttu-id="6a9d2-111">Per altre informazioni, vedere [generics](./generics/index.md) and [Constraints](./generics/constraints.md).</span><span class="sxs-lookup"><span data-stu-id="6a9d2-111">For more information, see [Generics](./generics/index.md) and [Constraints](./generics/constraints.md).</span></span> <span data-ttu-id="6a9d2-112">Descrive `parameter-list` i parametri del costruttore.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-112">The `parameter-list` describes constructor parameters.</span></span> <span data-ttu-id="6a9d2-113">Il primo modificatore di accesso è relativo al tipo. il secondo riguarda il costruttore primario.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-113">The first access modifier pertains to the type; the second pertains to the primary constructor.</span></span> <span data-ttu-id="6a9d2-114">In entrambi i casi, il valore `public`predefinito è.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-114">In both cases, the default is `public`.</span></span>

<span data-ttu-id="6a9d2-115">È possibile specificare la classe di base per una classe usando `inherit` la parola chiave.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-115">You specify the base class for a class by using the `inherit` keyword.</span></span> <span data-ttu-id="6a9d2-116">È necessario fornire argomenti, tra parentesi, per il costruttore della classe base.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-116">You must supply arguments, in parentheses, for the base class constructor.</span></span>

<span data-ttu-id="6a9d2-117">Si dichiarano i campi o i valori delle funzioni locali alla classe `let` utilizzando le associazioni ed è necessario seguire le regole generali per `let` le associazioni.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-117">You declare fields or function values that are local to the class by using `let` bindings, and you must follow the general rules for `let` bindings.</span></span> <span data-ttu-id="6a9d2-118">La `do-bindings` sezione include il codice da eseguire alla costruzione dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-118">The `do-bindings` section includes code to be executed upon object construction.</span></span>

<span data-ttu-id="6a9d2-119">`member-list` È costituito da costruttori aggiuntivi, dichiarazioni di metodi e istanze statiche, dichiarazioni di interfaccia, associazioni astratte e dichiarazioni di proprietà e eventi.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-119">The `member-list` consists of additional constructors, instance and static method declarations, interface declarations, abstract bindings, and property and event declarations.</span></span> <span data-ttu-id="6a9d2-120">Questi sono descritti in [membri](./members/index.md).</span><span class="sxs-lookup"><span data-stu-id="6a9d2-120">These are described in [Members](./members/index.md).</span></span>

<span data-ttu-id="6a9d2-121">L' `identifier` oggetto utilizzato con la parola chiave `as` optional assegna un nome alla variabile di istanza o a un identificatore automatico che può essere utilizzato nella definizione del tipo per fare riferimento all'istanza del tipo.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-121">The `identifier` that is used with the optional `as` keyword gives a name to the instance variable, or self identifier, which can be used in the type definition to refer to the instance of the type.</span></span> <span data-ttu-id="6a9d2-122">Per ulteriori informazioni, vedere la sezione identificatori autonomi più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-122">For more information, see the section Self Identifiers later in this topic.</span></span>

<span data-ttu-id="6a9d2-123">Le parole `class` chiave `end` e che contrassegnano l'inizio e la fine della definizione sono facoltative.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-123">The keywords `class` and `end` that mark the start and end of the definition are optional.</span></span>

<span data-ttu-id="6a9d2-124">I tipi ricorsivamente ricorsivi, ovvero i tipi che fanno riferimento l'uno all'altro, vengono `and` Uniti insieme alla parola chiave come le funzioni ricorsive reciproche.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-124">Mutually recursive types, which are types that reference each other, are joined together with the `and` keyword just as mutually recursive functions are.</span></span> <span data-ttu-id="6a9d2-125">Per un esempio, vedere la sezione tipi ricorsivamente ricorsivi.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-125">For an example, see the section Mutually Recursive Types.</span></span>

## <a name="constructors"></a><span data-ttu-id="6a9d2-126">Costruttori</span><span class="sxs-lookup"><span data-stu-id="6a9d2-126">Constructors</span></span>

<span data-ttu-id="6a9d2-127">Il costruttore è un codice che crea un'istanza del tipo di classe.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-127">The constructor is code that creates an instance of the class type.</span></span> <span data-ttu-id="6a9d2-128">I costruttori per le classi funzionano in modo F# diverso in rispetto a quanto avviene in altri linguaggi .NET.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-128">Constructors for classes work somewhat differently in F# than they do in other .NET languages.</span></span> <span data-ttu-id="6a9d2-129">In una F# classe è sempre presente un costruttore primario i cui argomenti sono descritti in `parameter-list` che seguono il nome del tipo e il cui `let` corpo è costituito dalle associazioni `let rec`(e) all'inizio della dichiarazione di classe e `do` associazioni che seguono.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-129">In an F# class, there is always a primary constructor whose arguments are described in the `parameter-list` that follows the type name, and whose body consists of the `let` (and `let rec`) bindings at the start of the class declaration and the `do` bindings that follow.</span></span> <span data-ttu-id="6a9d2-130">Gli argomenti del costruttore primario rientrano nell'ambito della dichiarazione di classe.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-130">The arguments of the primary constructor are in scope throughout the class declaration.</span></span>

<span data-ttu-id="6a9d2-131">È possibile aggiungere ulteriori costruttori utilizzando la `new` parola chiave per aggiungere un membro, come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="6a9d2-131">You can add additional constructors by using the `new` keyword to add a member, as follows:</span></span>

<span data-ttu-id="6a9d2-132">`new`(`argument-list`) = `constructor-body`</span><span class="sxs-lookup"><span data-stu-id="6a9d2-132">`new`(`argument-list`) = `constructor-body`</span></span>

<span data-ttu-id="6a9d2-133">Il corpo del nuovo costruttore deve richiamare il costruttore primario specificato all'inizio della dichiarazione di classe.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-133">The body of the new constructor must invoke the primary constructor that is specified at the top of the class declaration.</span></span>

<span data-ttu-id="6a9d2-134">Nell'esempio seguente viene illustrato questo concetto.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-134">The following example illustrates this concept.</span></span> <span data-ttu-id="6a9d2-135">Nel codice seguente, `MyClass` dispone di due costruttori, un costruttore primario che accetta due argomenti e un altro costruttore che non accetta argomenti.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-135">In the following code, `MyClass` has two constructors, a primary constructor that takes two arguments and another constructor that takes no arguments.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]

## <a name="let-and-do-bindings"></a><span data-ttu-id="6a9d2-136">Associazioni let and do</span><span class="sxs-lookup"><span data-stu-id="6a9d2-136">let and do Bindings</span></span>

<span data-ttu-id="6a9d2-137">Le `let` associazioni `do` e in una definizione di classe formano il corpo del costruttore della classe primaria, quindi vengono eseguite ogni volta che viene creata un'istanza della classe.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-137">The `let` and `do` bindings in a class definition form the body of the primary class constructor, and therefore they run whenever a class instance is created.</span></span> <span data-ttu-id="6a9d2-138">Se un' `let` associazione è una funzione, viene compilata in un membro.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-138">If a `let` binding is a function, then it is compiled into a member.</span></span> <span data-ttu-id="6a9d2-139">Se l' `let` associazione è un valore che non viene usato in alcuna funzione o membro, viene compilato in una variabile locale del costruttore.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-139">If the `let` binding is a value that is not used in any function or member, then it is compiled into a variable that is local to the constructor.</span></span> <span data-ttu-id="6a9d2-140">In caso contrario, viene compilato in un campo della classe.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-140">Otherwise, it is compiled into a field of the class.</span></span> <span data-ttu-id="6a9d2-141">Le `do` espressioni che seguono vengono compilate nel costruttore primario ed eseguono il codice di inizializzazione per ogni istanza.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-141">The `do` expressions that follow are compiled into the primary constructor and execute initialization code for every instance.</span></span> <span data-ttu-id="6a9d2-142">Poiché tutti i costruttori aggiuntivi chiamano sempre il costruttore primario, le `let` associazioni e `do` le associazioni vengono sempre eseguite indipendentemente dal costruttore chiamato.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-142">Because any additional constructors always call the primary constructor, the `let` bindings and `do` bindings always execute regardless of which constructor is called.</span></span>

<span data-ttu-id="6a9d2-143">È possibile accedere ai campi `let` creati dalle associazioni in tutti i metodi e le proprietà della classe. Tuttavia, non è possibile accedervi dai metodi statici, anche se i metodi statici accettano una variabile di istanza come parametro.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-143">Fields that are created by `let` bindings can be accessed throughout the methods and properties of the class; however, they cannot be accessed from static methods, even if the static methods take an instance variable as a parameter.</span></span> <span data-ttu-id="6a9d2-144">Non è possibile accedervi usando l'identificatore automatico, se disponibile.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-144">They cannot be accessed by using the self identifier, if one exists.</span></span>

## <a name="self-identifiers"></a><span data-ttu-id="6a9d2-145">Identificatori autonomi</span><span class="sxs-lookup"><span data-stu-id="6a9d2-145">Self Identifiers</span></span>

<span data-ttu-id="6a9d2-146">Un *identificatore auto* è un nome che rappresenta l'istanza corrente.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-146">A *self identifier* is a name that represents the current instance.</span></span> <span data-ttu-id="6a9d2-147">Gli identificatori autonomi assomigliano `this` alla parola `Me` chiave in C# o C++ o in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-147">Self identifiers resemble the `this` keyword in C# or C++ or `Me` in Visual Basic.</span></span> <span data-ttu-id="6a9d2-148">È possibile definire un identificatore autonomo in due modi diversi, a seconda che si desideri che l'autoidentificatore sia nell'ambito per la definizione di classe intera o solo per un singolo metodo.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-148">You can define a self identifier in two different ways, depending on whether you want the self identifier to be in scope for the whole class definition or just for an individual method.</span></span>

<span data-ttu-id="6a9d2-149">Per definire un identificatore automatico per l'intera classe, usare la `as` parola chiave dopo le parentesi di chiusura dell'elenco di parametri del costruttore e specificare il nome dell'identificatore.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-149">To define a self identifier for the whole class, use the `as` keyword after the closing parentheses of the constructor parameter list, and specify the identifier name.</span></span>

<span data-ttu-id="6a9d2-150">Per definire un identificatore automatico per un solo metodo, specificare l'identificatore automatico nella dichiarazione del membro, immediatamente prima del nome del metodo e un punto (.) come separatore.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-150">To define a self identifier for just one method, provide the self identifier in the member declaration, just before the method name and a period (.) as a separator.</span></span>

<span data-ttu-id="6a9d2-151">Nell'esempio di codice riportato di seguito vengono illustrati i due modi per creare un identificatore automatico.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-151">The following code example illustrates the two ways to create a self identifier.</span></span> <span data-ttu-id="6a9d2-152">Nella prima riga, la `as` parola chiave viene usata per definire l'identificatore automatico.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-152">In the first line, the `as` keyword is used to define the self identifier.</span></span> <span data-ttu-id="6a9d2-153">Nella quinta riga, l'identificatore `this` viene usato per definire un identificatore autonomo il cui ambito è limitato al metodo. `PrintMessage`</span><span class="sxs-lookup"><span data-stu-id="6a9d2-153">In the fifth line, the identifier `this` is used to define a self identifier whose scope is restricted to the method `PrintMessage`.</span></span>

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

<span data-ttu-id="6a9d2-154">Diversamente da altri linguaggi .NET, è possibile assegnare un nome all'identificatore automatico, non si è limitati a nomi `self`come, `Me`o `this`.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-154">Unlike in other .NET languages, you can name the self identifier however you want; you are not restricted to names such as `self`, `Me`, or `this`.</span></span>

<span data-ttu-id="6a9d2-155">L'identificatore autonomo dichiarato con la `as` parola chiave non viene inizializzato finché non vengono eseguite le `let` associazioni.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-155">The self identifier that is declared with the `as` keyword is not initialized until after the `let` bindings are executed.</span></span> <span data-ttu-id="6a9d2-156">Pertanto, non può essere utilizzato nelle `let` associazioni.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-156">Therefore, it cannot be used in the `let` bindings.</span></span> <span data-ttu-id="6a9d2-157">È possibile usare l'identificatore automatico nella `do` sezione Bindings.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-157">You can use the self identifier in the `do` bindings section.</span></span>

## <a name="generic-type-parameters"></a><span data-ttu-id="6a9d2-158">Parametri di tipo generico</span><span class="sxs-lookup"><span data-stu-id="6a9d2-158">Generic Type Parameters</span></span>

<span data-ttu-id="6a9d2-159">I parametri di tipo generico sono specificati tra parentesi angolari (`<` e `>`), sotto forma di virgolette singole seguite da un identificatore.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-159">Generic type parameters are specified in angle brackets (`<` and `>`), in the form of a single quotation mark followed by an identifier.</span></span> <span data-ttu-id="6a9d2-160">Più parametri di tipo generico sono separati da virgole.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-160">Multiple generic type parameters are separated by commas.</span></span> <span data-ttu-id="6a9d2-161">Il parametro di tipo generico è nell'ambito dell'intera dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-161">The generic type parameter is in scope throughout the declaration.</span></span> <span data-ttu-id="6a9d2-162">Nell'esempio di codice seguente viene illustrato come specificare parametri di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-162">The following code example shows how to specify generic type parameters.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

<span data-ttu-id="6a9d2-163">Gli argomenti di tipo vengono dedotti quando viene usato il tipo.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-163">Type arguments are inferred when the type is used.</span></span> <span data-ttu-id="6a9d2-164">Nel codice seguente, il tipo dedotto è una sequenza di Tuple.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-164">In the following code, the inferred type is a sequence of tuples.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]

## <a name="specifying-inheritance"></a><span data-ttu-id="6a9d2-165">Specifica dell'ereditarietà</span><span class="sxs-lookup"><span data-stu-id="6a9d2-165">Specifying Inheritance</span></span>

<span data-ttu-id="6a9d2-166">La `inherit` clausola identifica la classe di base diretta, se ne esiste una.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-166">The `inherit` clause identifies the direct base class, if there is one.</span></span> <span data-ttu-id="6a9d2-167">In F#è consentita una sola classe di base diretta.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-167">In F#, only one direct base class is allowed.</span></span> <span data-ttu-id="6a9d2-168">Le interfacce implementate da una classe non sono considerate classi di base.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-168">Interfaces that a class implements are not considered base classes.</span></span> <span data-ttu-id="6a9d2-169">Le interfacce sono descritte nell'argomento [interfacce](Interfaces.md) .</span><span class="sxs-lookup"><span data-stu-id="6a9d2-169">Interfaces are discussed in the [Interfaces](Interfaces.md) topic.</span></span>

<span data-ttu-id="6a9d2-170">È possibile accedere ai metodi e alle proprietà della classe di base dalla classe derivata usando la parola chiave `base` del linguaggio come identificatore, seguito da un punto (.) e dal nome del membro.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-170">You can access the methods and properties of the base class from the derived class by using the language keyword `base` as an identifier, followed by a period (.) and the name of the member.</span></span>

<span data-ttu-id="6a9d2-171">Per altre informazioni, vedere [Ereditarietà](inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="6a9d2-171">For more information, see [Inheritance](inheritance.md).</span></span>

## <a name="members-section"></a><span data-ttu-id="6a9d2-172">Sezione Members</span><span class="sxs-lookup"><span data-stu-id="6a9d2-172">Members Section</span></span>

<span data-ttu-id="6a9d2-173">In questa sezione è possibile definire metodi statici o di istanza, proprietà, implementazioni di interfacce, membri astratti, dichiarazioni di eventi e costruttori aggiuntivi.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-173">You can define static or instance methods, properties, interface implementations, abstract members, event declarations, and additional constructors in this section.</span></span> <span data-ttu-id="6a9d2-174">Le associazioni let e do non possono essere visualizzate in questa sezione.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-174">Let and do bindings cannot appear in this section.</span></span> <span data-ttu-id="6a9d2-175">Poiché i membri possono essere aggiunti a un'ampia F# gamma di tipi, oltre alle classi, vengono illustrati in un argomento separato, ovvero [membri](./members/index.md).</span><span class="sxs-lookup"><span data-stu-id="6a9d2-175">Because members can be added to a variety of F# types in addition to classes, they are discussed in a separate topic, [Members](./members/index.md).</span></span>

## <a name="mutually-recursive-types"></a><span data-ttu-id="6a9d2-176">Tipi ricorsivi reciproci</span><span class="sxs-lookup"><span data-stu-id="6a9d2-176">Mutually Recursive Types</span></span>

<span data-ttu-id="6a9d2-177">Quando si definiscono i tipi che fanno riferimento l'uno all'altro in modo circolare, è possibile stringere le definizioni `and` dei tipi usando la parola chiave.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-177">When you define types that reference each other in a circular way, you string together the type definitions by using the `and` keyword.</span></span> <span data-ttu-id="6a9d2-178">La `and` parola chiave sostituisce `type` la parola chiave su All eccetto la prima definizione, come indicato di seguito.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-178">The `and` keyword replaces the `type` keyword on all except the first definition, as follows.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

<span data-ttu-id="6a9d2-179">L'output è un elenco di tutti i file nella directory corrente.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-179">The output is a list of all the files in the current directory.</span></span>

## <a name="when-to-use-classes-unions-records-and-structures"></a><span data-ttu-id="6a9d2-180">Quando utilizzare classi, unioni, record e strutture</span><span class="sxs-lookup"><span data-stu-id="6a9d2-180">When to Use Classes, Unions, Records, and Structures</span></span>

<span data-ttu-id="6a9d2-181">Data la varietà di tipi tra cui scegliere, è necessario avere una conoscenza approfondita di ciò che ciascun tipo è progettato per selezionare il tipo appropriato per una particolare situazione.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-181">Given the variety of types to choose from, you need to have a good understanding of what each type is designed for to select the appropriate type for a particular situation.</span></span> <span data-ttu-id="6a9d2-182">Le classi sono progettate per essere usate nei contesti di programmazione orientata a oggetti.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-182">Classes are designed for use in object-oriented programming contexts.</span></span> <span data-ttu-id="6a9d2-183">La programmazione orientata a oggetti è il paradigma principale utilizzato nelle applicazioni scritte per il .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-183">Object-oriented programming is the dominant paradigm used in applications that are written for the .NET Framework.</span></span> <span data-ttu-id="6a9d2-184">Se il F# codice deve collaborare strettamente con la .NET Framework o un'altra libreria orientata a oggetti e, soprattutto se è necessario estendere da un sistema di tipi orientato a oggetti, ad esempio una libreria dell'interfaccia utente, le classi sono probabilmente appropriate.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-184">If your F# code has to work closely with the .NET Framework or another object-oriented library, and especially if you have to extend from an object-oriented type system such as a UI library, classes are probably appropriate.</span></span>

<span data-ttu-id="6a9d2-185">Se non si interagisce strettamente con il codice orientato a oggetti o se si sta scrivendo codice indipendente e pertanto protetto da interazioni frequenti con codice orientato a oggetti, è consigliabile utilizzare record e unioni discriminate.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-185">If you are not interoperating closely with object-oriented code, or if you are writing code that is self-contained and therefore protected from frequent interaction with object-oriented code, you should consider using records and discriminated unions.</span></span> <span data-ttu-id="6a9d2-186">Un'unione discriminata unica, ben concepita, insieme al codice appropriato per i criteri di ricerca, può essere spesso utilizzata come alternativa più semplice a una gerarchia di oggetti.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-186">A single, well thought–out discriminated union, together with appropriate pattern matching code, can often be used as a simpler alternative to an object hierarchy.</span></span> <span data-ttu-id="6a9d2-187">Per altre informazioni sulle unioni discriminate, vedere [unioni discriminate](discriminated-unions.md).</span><span class="sxs-lookup"><span data-stu-id="6a9d2-187">For more information about discriminated unions, see [Discriminated Unions](discriminated-unions.md).</span></span>

<span data-ttu-id="6a9d2-188">I record hanno il vantaggio di essere più semplici delle classi, ma i record non sono appropriati quando le richieste di un tipo superano ciò che può essere ottenuto con la loro semplicità.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-188">Records have the advantage of being simpler than classes, but records are not appropriate when the demands of a type exceed what can be accomplished with their simplicity.</span></span> <span data-ttu-id="6a9d2-189">I record sono essenzialmente semplici aggregazioni di valori, senza costruttori distinti che possono eseguire azioni personalizzate, senza campi nascosti e senza implementazioni di ereditarietà o di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-189">Records are basically simple aggregates of values, without separate constructors that can perform custom actions, without hidden fields, and without inheritance or interface implementations.</span></span> <span data-ttu-id="6a9d2-190">Sebbene i membri come proprietà e metodi possano essere aggiunti ai record per rendere il loro comportamento più complesso, i campi archiviati in un record sono ancora una semplice aggregazione di valori.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-190">Although members such as properties and methods can be added to records to make their behavior more complex, the fields stored in a record are still a simple aggregate of values.</span></span> <span data-ttu-id="6a9d2-191">Per ulteriori informazioni sui record, vedere [record](records.md).</span><span class="sxs-lookup"><span data-stu-id="6a9d2-191">For more information about records, see [Records](records.md).</span></span>

<span data-ttu-id="6a9d2-192">Le strutture sono utili anche per piccole aggregazioni di dati, ma si differenziano dalle classi e dai record in quanto sono tipi di valore .NET.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-192">Structures are also useful for small aggregates of data, but they differ from classes and records in that they are .NET value types.</span></span> <span data-ttu-id="6a9d2-193">Le classi e i record sono tipi di riferimento .NET.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-193">Classes and records are .NET reference types.</span></span> <span data-ttu-id="6a9d2-194">La semantica dei tipi di valore e i tipi di riferimento sono diversi in quanto i tipi di valore vengono passati per valore.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-194">The semantics of value types and reference types are different in that value types are passed by value.</span></span> <span data-ttu-id="6a9d2-195">Ciò significa che vengono copiati bit per bit quando vengono passati come parametro o restituiti da una funzione.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-195">This means that they are copied bit for bit when they are passed as a parameter or returned from a function.</span></span> <span data-ttu-id="6a9d2-196">Vengono inoltre archiviati nello stack o, se vengono utilizzati come campo, incorporati all'interno dell'oggetto padre anziché archiviati nella propria posizione separata nell'heap.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-196">They are also stored on the stack or, if they are used as a field, embedded inside the parent object instead of stored in their own separate location on the heap.</span></span> <span data-ttu-id="6a9d2-197">Pertanto, le strutture sono appropriate per i dati a cui si accede di frequente quando l'overhead di accesso all'heap costituisce un problema.</span><span class="sxs-lookup"><span data-stu-id="6a9d2-197">Therefore, structures are appropriate for frequently accessed data when the overhead of accessing the heap is a problem.</span></span> <span data-ttu-id="6a9d2-198">Per ulteriori informazioni sulle strutture, vedere [strutture](structures.md).</span><span class="sxs-lookup"><span data-stu-id="6a9d2-198">For more information about structures, see [Structures](structures.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="6a9d2-199">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="6a9d2-199">See also</span></span>

- [<span data-ttu-id="6a9d2-200">Riferimenti per il linguaggio F#</span><span class="sxs-lookup"><span data-stu-id="6a9d2-200">F# Language Reference</span></span>](index.md)
- [<span data-ttu-id="6a9d2-201">Membri</span><span class="sxs-lookup"><span data-stu-id="6a9d2-201">Members</span></span>](./members/index.md)
- [<span data-ttu-id="6a9d2-202">Ereditarietà</span><span class="sxs-lookup"><span data-stu-id="6a9d2-202">Inheritance</span></span>](inheritance.md)
- [<span data-ttu-id="6a9d2-203">Interfacce</span><span class="sxs-lookup"><span data-stu-id="6a9d2-203">Interfaces</span></span>](interfaces.md)
