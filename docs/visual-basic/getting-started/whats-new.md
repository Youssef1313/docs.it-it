---
title: Novità in Visual Basic
ms.date: 10/24/2018
f1_keywords:
- VB.StartPage.WhatsNew
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
ms.openlocfilehash: 20d403e4a6410257068cc3414fcb8dc1e45709e9
ms.sourcegitcommit: cdf67135a98a5a51913dacddb58e004a3c867802
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 08/21/2019
ms.locfileid: "69666870"
---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="cdb86-102">Novità in Visual Basic</span><span class="sxs-lookup"><span data-stu-id="cdb86-102">What's new for Visual Basic</span></span>

<span data-ttu-id="cdb86-103">Questo argomento elenca i nomi delle funzionalità principali per ogni versione di Visual Basic, con descrizioni dettagliate delle funzionalità nuove e migliorate nelle più recenti versioni del linguaggio.</span><span class="sxs-lookup"><span data-stu-id="cdb86-103">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the latest versions of the language.</span></span>

## <a name="current-version"></a><span data-ttu-id="cdb86-104">Versione corrente</span><span class="sxs-lookup"><span data-stu-id="cdb86-104">Current version</span></span>

<span data-ttu-id="cdb86-105">Visual Basic 15.8 / Visual Studio 2017 versione 15.8 - Per le nuove funzionalità, vedere [Visual Basic 15.8](#visual-basic-158)</span><span class="sxs-lookup"><span data-stu-id="cdb86-105">Visual Basic 15.8 / Visual Studio 2017 Version 15.8 For new features, see [Visual Basic 15.8](#visual-basic-158)</span></span>

## <a name="previous-versions"></a><span data-ttu-id="cdb86-106">Versioni precedenti</span><span class="sxs-lookup"><span data-stu-id="cdb86-106">Previous versions</span></span>

<span data-ttu-id="cdb86-107">Visual Basic 15.5 / Visual Studio 2017 versione 15.5 - Per le nuove funzionalità, vedere [Visual Basic 15.5](#visual-basic-155)</span><span class="sxs-lookup"><span data-stu-id="cdb86-107">Visual Basic 15.5 / Visual Studio 2017 Version 15.5 For new features, see [Visual Basic 15.5](#visual-basic-155)</span></span>

<span data-ttu-id="cdb86-108">Visual Basic 15.3 / Visual Studio 2017 versione 15.3 - Per le nuove funzionalità, vedere [Visual Basic 15.3](#visual-basic-153)</span><span class="sxs-lookup"><span data-stu-id="cdb86-108">Visual Basic 15.3 / Visual Studio 2017 Version 15.3 For new features, see [Visual Basic 15.3](#visual-basic-153)</span></span>

<span data-ttu-id="cdb86-109">Visual Basic 2017 / Visual Studio 2017 - Per le nuove funzionalità, vedere [Visual Basic 2017](#visual-basic-2017)</span><span class="sxs-lookup"><span data-stu-id="cdb86-109">Visual Basic 2017 / Visual Studio 2017 For new features, see [Visual Basic 2017](#visual-basic-2017)</span></span>

<span data-ttu-id="cdb86-110">Visual Basic / Visual Studio 2015 - Per le nuove funzionalità, vedere [Visual Basic 14](#visual-basic-14)</span><span class="sxs-lookup"><span data-stu-id="cdb86-110">Visual Basic / Visual Studio 2015 For new features, see [Visual Basic 14](#visual-basic-14)</span></span>

<span data-ttu-id="cdb86-111">Visual Basic / Visual Studio 2013 - Technology Preview della piattaforma del compilatore .NET ("Roslyn")</span><span class="sxs-lookup"><span data-stu-id="cdb86-111">Visual Basic / Visual Studio 2013 Technology previews of the .NET Compiler Platform (“Roslyn”)</span></span>

<span data-ttu-id="cdb86-112">Visual Basic / Visual Studio 2012 - Parole chiave `Async` e `await`, iteratori, attributi relativi alle informazioni sul chiamante</span><span class="sxs-lookup"><span data-stu-id="cdb86-112">Visual Basic / Visual Studio 2012 `Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="cdb86-113">Visual Basic, Visual Studio 2010 - Proprietà implementate automaticamente, inizializzatori di insieme, continuazione di riga implicita, elementi dinamici, covarianza/controvarianza generica, accesso agli spazi dei nomi globali</span><span class="sxs-lookup"><span data-stu-id="cdb86-113">Visual Basic, Visual Studio 2010 Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="cdb86-114">Visual Basic / Visual Studio 2008 - Language Integrated Query (LINQ), valori letterali XML, inferenza del tipo di variabile locale, inizializzatori di oggetto, tipi anonimi, metodi di estensione, inferenza del tipo `var` locale, espressioni lambda, operatore `if`, metodi parziali, tipi di valore nullable</span><span class="sxs-lookup"><span data-stu-id="cdb86-114">Visual Basic / Visual Studio 2008 Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>

<span data-ttu-id="cdb86-115">Visual Basic / Visual Studio 2005 - Tipo `My` e tipi di helper (accesso all'app, al computer, al file system, alla rete)</span><span class="sxs-lookup"><span data-stu-id="cdb86-115">Visual Basic / Visual Studio 2005 The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="cdb86-116">Visual Basic / Visual Studio .NET 2003 - Operatori di scorrimento bit, dichiarazione di variabile del ciclo</span><span class="sxs-lookup"><span data-stu-id="cdb86-116">Visual Basic / Visual Studio .NET 2003 Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="cdb86-117">Visual Basic / Visual Studio .NET 2002 - Prima versione di Visual Basic .NET</span><span class="sxs-lookup"><span data-stu-id="cdb86-117">Visual Basic / Visual Studio .NET 2002 The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-158"></a><span data-ttu-id="cdb86-118">Visual Basic 15.8</span><span class="sxs-lookup"><span data-stu-id="cdb86-118">Visual Basic 15.8</span></span>

<span data-ttu-id="cdb86-119">**Ottimizzazione della conversione da virgola mobile a Integer**</span><span class="sxs-lookup"><span data-stu-id="cdb86-119">**Optimized floating-point to integer conversion**</span></span>

<span data-ttu-id="cdb86-120">Nelle versioni precedenti di Visual Basic, le prestazioni della conversione dei valori [Double](../language-reference/data-types/double-data-type.md) e [Single](../language-reference/data-types/single-data-type.md) in valori Integer erano relativamente scarse.</span><span class="sxs-lookup"><span data-stu-id="cdb86-120">In previous versions of Visual Basic, conversion of [Double](../language-reference/data-types/double-data-type.md) and [Single](../language-reference/data-types/single-data-type.md) values to integers offered relatively poor performance.</span></span> <span data-ttu-id="cdb86-121">Visual Basic 15.8 migliora significativamente le prestazioni delle conversioni di valori da virgola mobile a Integer quando il valore restituito da uno dei metodi seguenti viene passato a una delle [funzioni intrinseche di conversione di interi di Visual Basic](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng) o quando per il valore restituito da uno dei metodi seguenti viene eseguito il cast implicito a un tipo Integer e [Option Strict](../language-reference/statements/option-strict-statement.md) è `Off`:</span><span class="sxs-lookup"><span data-stu-id="cdb86-121">Visual Basic 15.8 significantly enhances the performance of floating-point conversions to integers when you pass the value returned by any of the following methods to one of the [intrinsic Visual Basic integer conversion functions](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng), or when the value returned by any of the following methods is implicitly cast to an integral type when [Option Strict](../language-reference/statements/option-strict-statement.md) is set to `Off`:</span></span>

- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Single)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Single)?displayProperty=nameWithType>
- <xref:System.Math.Ceiling(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Floor(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Round(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Truncate(System.Double)?displayProperty=nameWithType>

<span data-ttu-id="cdb86-122">Questa ottimizzazione consente un'esecuzione più rapida del codice, fino a due volte più rapida nei casi di esecuzione di un numero elevato di conversioni a tipi Integer.</span><span class="sxs-lookup"><span data-stu-id="cdb86-122">This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types.</span></span> <span data-ttu-id="cdb86-123">L'esempio seguente illustra alcune semplici chiamate di metodi interessati da questa ottimizzazione:</span><span class="sxs-lookup"><span data-stu-id="cdb86-123">The following example illustrates some simple method calls that are affected by this optimization:</span></span>

```vb
Dim s As Single = 173.7619
Dim d As Double = s

Dim i1 As Integer = CInt(Fix(s))               ' Result: 173
Dim b1 As Byte = CByte(Int(d))                 ' Result: 173
Dim s1 AS Short = CShort(Math.Truncate(s))     ' Result: 173
Dim i2 As Integer = CInt(Math.Ceiling(d))      ' Result: 174
Dim i3 As Integer = CInt(Math.Round(s))        ' Result: 174

```

<span data-ttu-id="cdb86-124">Si noti che in questo caso i valori a virgola mobile vengono troncati anziché arrotondati.</span><span class="sxs-lookup"><span data-stu-id="cdb86-124">Note that this truncates rather than rounds floating-point values.</span></span>

## <a name="visual-basic-155"></a><span data-ttu-id="cdb86-125">Visual Basic 15.5</span><span class="sxs-lookup"><span data-stu-id="cdb86-125">Visual Basic 15.5</span></span>

[<span data-ttu-id="cdb86-126">Argomenti denominati non finali</span><span class="sxs-lookup"><span data-stu-id="cdb86-126">Non-trailing named arguments</span></span>](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)

<span data-ttu-id="cdb86-127">In Visual Basic 15.3 e versioni precedenti, quando una chiamata al metodo includeva argomenti in base alla posizione e al nome, gli argomenti posizionali dovevano precedere gli argomenti denominati.</span><span class="sxs-lookup"><span data-stu-id="cdb86-127">In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.</span></span> <span data-ttu-id="cdb86-128">A partire da Visual Basic 15,5, gli argomenti posizionali e denominati possono trovarsi in qualsiasi ordine, purché tutti gli argomenti fino all'ultimo argomento posizionale si trovino nella posizione corretta.</span><span class="sxs-lookup"><span data-stu-id="cdb86-128">Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.</span></span> <span data-ttu-id="cdb86-129">Ciò è particolarmente utile quando gli argomenti denominati vengono utilizzati per rendere il codice più leggibile.</span><span class="sxs-lookup"><span data-stu-id="cdb86-129">This is particularly useful when named arguments are used to make code more readable.</span></span>

<span data-ttu-id="cdb86-130">Ad esempio, la seguente chiamata al metodo ha due argomenti posizionali tra un argomento denominato.</span><span class="sxs-lookup"><span data-stu-id="cdb86-130">For example, the following method call has two positional arguments between a named argument.</span></span> <span data-ttu-id="cdb86-131">L'argomento denominato chiarisce che il valore 19 rappresenta un'età.</span><span class="sxs-lookup"><span data-stu-id="cdb86-131">The named argument makes it clear that the value 19 represents an age.</span></span>

```vb
StudentInfo.Display("Mary", age:=19, #9/21/1998#)
```

[<span data-ttu-id="cdb86-132">Modificatore di accesso ai membri `Private Protected`</span><span class="sxs-lookup"><span data-stu-id="cdb86-132">`Private Protected` member access modifier</span></span>](../language-reference/modifiers/private-protected.md)

<span data-ttu-id="cdb86-133">Questa nuova combinazione di parole chiave definisce un membro accessibile da tutti i membri nella classe che lo contiene, oltre che dai tipi derivati dalla classe che lo contiene, ma solo se si trovano anche nell'assembly che lo contiene.</span><span class="sxs-lookup"><span data-stu-id="cdb86-133">This new keyword combination defines a member that is accessible by all members in its containing class as well as by types derived from the containing class, but only if they are also found in the containing assembly.</span></span> <span data-ttu-id="cdb86-134">Poiché le strutture non possono essere ereditate, è possibile applicare `Private Protected` solo ai membri di una classe.</span><span class="sxs-lookup"><span data-stu-id="cdb86-134">Because structures cannot be inherited, `Private Protected` can only be applied to the members of a class.</span></span>

<span data-ttu-id="cdb86-135">**Separatore esadecimale/binario/ottali iniziale**</span><span class="sxs-lookup"><span data-stu-id="cdb86-135">**Leading hex/binary/octal separator**</span></span>

<span data-ttu-id="cdb86-136">Visual Basic 2017 ha aggiunto il supporto del carattere di sottolineatura (`_`) come separatore di cifre.</span><span class="sxs-lookup"><span data-stu-id="cdb86-136">Visual Basic 2017 added support for the underscore character (`_`) as a digit separator.</span></span> <span data-ttu-id="cdb86-137">A partire da Visual Basic 15.5, è possibile usare il carattere di sottolineatura come separatore iniziale tra il prefisso e la cifra esadecimale, binaria o ottale.</span><span class="sxs-lookup"><span data-stu-id="cdb86-137">Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.</span></span> <span data-ttu-id="cdb86-138">L'esempio seguente usa il separatore di cifra iniziali per definire 3.271.948.384 come numero esadecimale:</span><span class="sxs-lookup"><span data-stu-id="cdb86-138">The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:</span></span>

```vb
Dim number As Integer = &H_C305_F860
```

<span data-ttu-id="cdb86-139">Per usare il carattere di sottolineatura come separatore iniziale, è necessario aggiungere l'elemento seguente al file di progetto (\*.vbproj) di Visual Basic:</span><span class="sxs-lookup"><span data-stu-id="cdb86-139">To use the underscore character as a leading separator, you must add the following element to your Visual Basic project (\*.vbproj) file:</span></span>

```xml
<PropertyGroup>
  <LangVersion>15.5</LangVersion>
</PropertyGroup>
```

## <a name="visual-basic-153"></a><span data-ttu-id="cdb86-140">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="cdb86-140">Visual Basic 15.3</span></span>

[<span data-ttu-id="cdb86-141">**Inferenza di tupla denominata**</span><span class="sxs-lookup"><span data-stu-id="cdb86-141">**Named tuple inference**</span></span>](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)

<span data-ttu-id="cdb86-142">Quando si assegna il valore di elementi di tupla provenienti da variabili, Visual Basic deduce il nome degli elementi di tupla dai nomi di variabili corrispondenti; non è necessario assegnare esplicitamente un nome a un elemento di tupla.</span><span class="sxs-lookup"><span data-stu-id="cdb86-142">When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.</span></span> <span data-ttu-id="cdb86-143">L'esempio seguente usa l'inferenza per creare una tupla con tre elementi denominati, `state`, `stateName`, e `capital`.</span><span class="sxs-lookup"><span data-stu-id="cdb86-143">The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`.</span></span>

[!code-vb[Inferred tuple names](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

<span data-ttu-id="cdb86-144">**Nuove opzioni del compilatore**</span><span class="sxs-lookup"><span data-stu-id="cdb86-144">**Additional compiler switches**</span></span>

<span data-ttu-id="cdb86-145">Il compilatore della riga di comando di Visual Basic ora supporta le opzioni [ **-refout**](../reference/command-line-compiler/refout-compiler-option.md) e [ **-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) per il controllo dell'output degli assembly di riferimento.</span><span class="sxs-lookup"><span data-stu-id="cdb86-145">The Visual Basic command-line compiler now supports the [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) and [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) compiler options to control the output of reference assemblies.</span></span> <span data-ttu-id="cdb86-146">**-refout** definisce la directory di output dell'assembly di riferimento, mentre **-refonly** specifica che il risultato della compilazione può essere solo un assembly di riferimento.</span><span class="sxs-lookup"><span data-stu-id="cdb86-146">**-refout** defines the output directory of the reference assembly, and **-refonly** specifies that only a reference assembly is to be output by compilation.</span></span>

## <a name="visual-basic-2017"></a><span data-ttu-id="cdb86-147">Visual Basic 2017</span><span class="sxs-lookup"><span data-stu-id="cdb86-147">Visual Basic 2017</span></span>

[<span data-ttu-id="cdb86-148">**Tuple**</span><span class="sxs-lookup"><span data-stu-id="cdb86-148">**Tuples**</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="cdb86-149">Le tuple sono una semplice struttura dei dati che viene solitamente usata per restituire più valori da una singola chiamata al metodo.</span><span class="sxs-lookup"><span data-stu-id="cdb86-149">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="cdb86-150">In genere, per restituire più valori da un metodo, è necessario eseguire una delle operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="cdb86-150">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="cdb86-151">Definire un tipo personalizzato (`Class` o `Structure`).</span><span class="sxs-lookup"><span data-stu-id="cdb86-151">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="cdb86-152">Si tratta di una soluzione complicata.</span><span class="sxs-lookup"><span data-stu-id="cdb86-152">This is a heavyweight solution.</span></span>

- <span data-ttu-id="cdb86-153">Definire uno o più parametri `ByRef` e restituire un valore dal metodo.</span><span class="sxs-lookup"><span data-stu-id="cdb86-153">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>

<span data-ttu-id="cdb86-154">Grazie al supporto per tuple di Visual Basic è possibile definire rapidamente una tupla, assegnare facoltativamente nomi semantici ai rispettivi valori e recuperare rapidamente i relativi valori.</span><span class="sxs-lookup"><span data-stu-id="cdb86-154">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="cdb86-155">L'esempio seguente esegue il wrapping di una chiamata al metodo <xref:System.Int32.TryParse%2A> e restituisce una tupla.</span><span class="sxs-lookup"><span data-stu-id="cdb86-155">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="cdb86-156">A questo punto è possibile chiamare il metodo e gestire la tupla restituita con codice simile al seguente.</span><span class="sxs-lookup"><span data-stu-id="cdb86-156">You can then call the method and handle the returned tuple with code like the following.</span></span>

[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]

<span data-ttu-id="cdb86-157">**Valori letterali binari e separatori di cifre**</span><span class="sxs-lookup"><span data-stu-id="cdb86-157">**Binary literals and digit separators**</span></span>

<span data-ttu-id="cdb86-158">È possibile definire un valore letterale binario usando il prefisso `&B` o `&b`.</span><span class="sxs-lookup"><span data-stu-id="cdb86-158">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="cdb86-159">È anche possibile usare il carattere di sottolineatura `_` come separatore di cifre per rendere il codice più leggibile.</span><span class="sxs-lookup"><span data-stu-id="cdb86-159">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="cdb86-160">Nell'esempio seguente vengono usate entrambe le funzionalità per assegnare un valore `Byte` e visualizzarlo come un numero decimale, esadecimale e binario.</span><span class="sxs-lookup"><span data-stu-id="cdb86-160">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]

<span data-ttu-id="cdb86-161">Per altre informazioni, vedere la sezione dedicata alle assegnazioni di valori letterali dei tipi di dati [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments) e [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments).</span><span class="sxs-lookup"><span data-stu-id="cdb86-161">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

[<span data-ttu-id="cdb86-162">**Supporto per valori di riferimento restituiti C#** </span><span class="sxs-lookup"><span data-stu-id="cdb86-162">**Support for C# reference return values**</span></span>](../programming-guide/language-features/procedures/ref-return-values.md)

<span data-ttu-id="cdb86-163">A partire dalla versione 7.0, C# supporta i valori di riferimento restituiti.</span><span class="sxs-lookup"><span data-stu-id="cdb86-163">Starting with C# 7.0, C# supports reference return values.</span></span> <span data-ttu-id="cdb86-164">Pertanto, quando la chiamata al metodo riceve un valore di riferimento restituito, lo può modificare.</span><span class="sxs-lookup"><span data-stu-id="cdb86-164">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="cdb86-165">Visual Basic non consente di creare metodi con valori di riferimento restituiti, ma consente di usare e modificare tali valori.</span><span class="sxs-lookup"><span data-stu-id="cdb86-165">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="cdb86-166">Ad esempio, la classe `Sentence` seguente scritta in C# include un metodo `FindNext` che rileva la parola successiva in una frase che inizia con una sottostringa specificata.</span><span class="sxs-lookup"><span data-stu-id="cdb86-166">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="cdb86-167">La stringa viene restituita come valore di riferimento restituito. Una variabile `Boolean` passata dal riferimento al metodo indica se la ricerca ha avuto esito positivo.</span><span class="sxs-lookup"><span data-stu-id="cdb86-167">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="cdb86-168">A questo punto il chiamante non solo può leggere il valore restituito, ma lo può anche modificare. Tale modifica si riflette sulla classe `Sentence`.</span><span class="sxs-lookup"><span data-stu-id="cdb86-168">This means that the caller can not only read the returned value; he or she can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]

<span data-ttu-id="cdb86-169">In parole semplici, è possibile modificare la parola trovata nella frase usando un codice simile al seguente.</span><span class="sxs-lookup"><span data-stu-id="cdb86-169">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="cdb86-170">Si noti che non si sta assegnando un valore al metodo, ma all'espressione che il metodo restituisce, ovvero il valore di riferimento restituito.</span><span class="sxs-lookup"><span data-stu-id="cdb86-170">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]

<span data-ttu-id="cdb86-171">Esiste tuttavia un problema con questo codice. Se non viene trovata una corrispondenza, il metodo restituisce la prima parola.</span><span class="sxs-lookup"><span data-stu-id="cdb86-171">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="cdb86-172">L'esempio non esamina il valore dell'argomento `Boolean` per determinare se viene trovata una corrispondenza. Modifica quindi la prima parola se non esiste corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="cdb86-172">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="cdb86-173">Nell'esempio seguente questo problema viene risolto sostituendo la prima parola con la parola stessa se non esiste corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="cdb86-173">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]

<span data-ttu-id="cdb86-174">Una soluzione migliore consiste nell'usare un metodo helper al quale il riferimento passa il valore di riferimento restituito.</span><span class="sxs-lookup"><span data-stu-id="cdb86-174">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="cdb86-175">Il metodo helper può quindi modificare l'argomento passato dal riferimento.</span><span class="sxs-lookup"><span data-stu-id="cdb86-175">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="cdb86-176">Nell'esempio seguente viene eseguita questa operazione.</span><span class="sxs-lookup"><span data-stu-id="cdb86-176">The following example does that.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]

<span data-ttu-id="cdb86-177">Per altre informazioni, vedere [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md) (Valori di riferimento restituiti).</span><span class="sxs-lookup"><span data-stu-id="cdb86-177">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="cdb86-178">Visual Basic 14</span><span class="sxs-lookup"><span data-stu-id="cdb86-178">Visual Basic 14</span></span>

[<span data-ttu-id="cdb86-179">Nameof</span><span class="sxs-lookup"><span data-stu-id="cdb86-179">Nameof</span></span>](../../csharp/language-reference/operators/nameof.md)

<span data-ttu-id="cdb86-180">È possibile ottenere il nome di stringa non qualificato di un tipo o di un membro, da usare in un messaggio di errore senza definire una stringa a livello di codice.</span><span class="sxs-lookup"><span data-stu-id="cdb86-180">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="cdb86-181">In questo modo il codice sarà corretto anche durante il refactoring.</span><span class="sxs-lookup"><span data-stu-id="cdb86-181">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="cdb86-182">Questa funzionalità è utile anche per l'associazione di collegamenti MVC (Modello-Vista-Controller) e la generazione di eventi di modifica di proprietà.</span><span class="sxs-lookup"><span data-stu-id="cdb86-182">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>

[<span data-ttu-id="cdb86-183">Interpolazione di stringhe</span><span class="sxs-lookup"><span data-stu-id="cdb86-183">String interpolation</span></span>](../../visual-basic/programming-guide/language-features/strings/interpolated-strings.md)

<span data-ttu-id="cdb86-184">È possibile usare espressioni di interpolazione di stringhe per costruire stringhe.</span><span class="sxs-lookup"><span data-stu-id="cdb86-184">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="cdb86-185">Un'espressione di stringa interpolata è simile a una stringa di modello che contiene espressioni.</span><span class="sxs-lookup"><span data-stu-id="cdb86-185">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="cdb86-186">In relazione agli argomenti, è più facile comprendere una stringa interpolata che la [formattazione composita](../../standard/base-types/composite-format.md).</span><span class="sxs-lookup"><span data-stu-id="cdb86-186">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-format.md).</span></span>

[<span data-ttu-id="cdb86-187">Indicizzazione e accesso ai membri condizionali null</span><span class="sxs-lookup"><span data-stu-id="cdb86-187">Null-conditional member access and indexing</span></span>](../language-reference/operators/null-conditional-operators.md)

<span data-ttu-id="cdb86-188">È possibile verificare la presenza di valori null con una sintassi molto leggera prima di eseguire un'operazione di accesso ai membri (`?.`) o di indice (`?[]`).</span><span class="sxs-lookup"><span data-stu-id="cdb86-188">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="cdb86-189">Questi operatori consentono di scrivere meno codice per gestire i controlli null, soprattutto per l'ordinamento decrescente delle strutture di dati.</span><span class="sxs-lookup"><span data-stu-id="cdb86-189">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="cdb86-190">Se l'operando di sinistra o il riferimento a un oggetto è null, le operazioni restituiscono null.</span><span class="sxs-lookup"><span data-stu-id="cdb86-190">If the left operand or object reference is null, the operations returns null.</span></span>

[<span data-ttu-id="cdb86-191">Valori letterali multilinea</span><span class="sxs-lookup"><span data-stu-id="cdb86-191">Multi-line string literals</span></span>](../../visual-basic/programming-guide/language-features/strings/string-basics.md)

<span data-ttu-id="cdb86-192">I valori letterali stringa possono contenere sequenze di nuove righe.</span><span class="sxs-lookup"><span data-stu-id="cdb86-192">String literals can contain newline sequences.</span></span>  <span data-ttu-id="cdb86-193">Non è più necessario usare `<xml><![CDATA[...text with newlines...]]></xml>.Value` come soluzione alternativa.</span><span class="sxs-lookup"><span data-stu-id="cdb86-193">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>

<span data-ttu-id="cdb86-194">**Commenti**</span><span class="sxs-lookup"><span data-stu-id="cdb86-194">**Comments**</span></span>

<span data-ttu-id="cdb86-195">È possibile inserire commenti dopo le continuazioni di riga implicita, all'interno delle espressioni dell'inizializzatore e tra i termini delle espressioni LINQ.</span><span class="sxs-lookup"><span data-stu-id="cdb86-195">You can put comments after implicit line continuations, inside initializer expressions, and among LINQ expression terms.</span></span>

<span data-ttu-id="cdb86-196">**Risoluzione dei nomi completi più intelligente**</span><span class="sxs-lookup"><span data-stu-id="cdb86-196">**Smarter fully-qualified name resolution**</span></span>

<span data-ttu-id="cdb86-197">In precedenza, con un codice come `Threading.Thread.Sleep(1000)`, Visual Basic cercava lo spazio dei nomi "Threading", individuava un'ambiguità tra System.Threading e System.Windows.Threading e quindi segnalava un errore.</span><span class="sxs-lookup"><span data-stu-id="cdb86-197">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="cdb86-198">Visual Basic ora prende in considerazione entrambi gli spazi dei nomi possibili.</span><span class="sxs-lookup"><span data-stu-id="cdb86-198">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="cdb86-199">Se si visualizza l'elenco di completamento, l'editor di Visual Studio elenca i membri di entrambi i tipi in questo elenco.</span><span class="sxs-lookup"><span data-stu-id="cdb86-199">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>

<span data-ttu-id="cdb86-200">**Valori letterali data con anno all'inizio**</span><span class="sxs-lookup"><span data-stu-id="cdb86-200">**Year-first date literals**</span></span>

<span data-ttu-id="cdb86-201">I valori letterali data possono avere il formato aaaa-mm-gg, `#2015-03-17 16:10 PM#`.</span><span class="sxs-lookup"><span data-stu-id="cdb86-201">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>

<span data-ttu-id="cdb86-202">**Proprietà dell'interfaccia readonly**</span><span class="sxs-lookup"><span data-stu-id="cdb86-202">**Readonly interface properties**</span></span>

<span data-ttu-id="cdb86-203">È possibile implementare proprietà dell'interfaccia readonly usando una proprietà readonly.</span><span class="sxs-lookup"><span data-stu-id="cdb86-203">You can implement readonly interface properties using a readwrite property.</span></span>  <span data-ttu-id="cdb86-204">L'interfaccia garantisce la funzionalità minima e le classi di implementazione non smettono di consentire l'impostazione della proprietà.</span><span class="sxs-lookup"><span data-stu-id="cdb86-204">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>

[<span data-ttu-id="cdb86-205">TypeOf \<espressione> IsNot \<tipo></span><span class="sxs-lookup"><span data-stu-id="cdb86-205">TypeOf \<expr> IsNot \<type></span></span>](../../visual-basic/language-reference/operators/typeof-operator.md)

<span data-ttu-id="cdb86-206">Per una maggiore leggibilità del codice, ora è possibile usare `TypeOf` con `IsNot`.</span><span class="sxs-lookup"><span data-stu-id="cdb86-206">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>

[<span data-ttu-id="cdb86-207">#Disable Warning \<ID> e #Enable Warning \<ID></span><span class="sxs-lookup"><span data-stu-id="cdb86-207">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../../visual-basic/language-reference/directives/index.md)

<span data-ttu-id="cdb86-208">È possibile disabilitare e abilitare avvisi specifici per le aree all'interno di un file di origine.</span><span class="sxs-lookup"><span data-stu-id="cdb86-208">You can disable and enable specific warnings for regions within a source file.</span></span>

<span data-ttu-id="cdb86-209">**Miglioramenti dei commenti in formato documentazione XML**</span><span class="sxs-lookup"><span data-stu-id="cdb86-209">**XML doc comment improvements**</span></span>

<span data-ttu-id="cdb86-210">Quando si scrivono commenti ai documenti, si accede a Smart Editor e al supporto per la compilazione per la convalida di nomi di parametro, la corretta gestione di `crefs` (generics, operatori e così via), la colorazione e il refactoring.</span><span class="sxs-lookup"><span data-stu-id="cdb86-210">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>

[<span data-ttu-id="cdb86-211">Definizioni di interfacce e moduli parziali</span><span class="sxs-lookup"><span data-stu-id="cdb86-211">Partial module and interface definitions</span></span>](../../visual-basic/language-reference/modifiers/partial.md)

<span data-ttu-id="cdb86-212">Oltre a classi e struct, è possibile dichiarare interfacce e moduli parziali.</span><span class="sxs-lookup"><span data-stu-id="cdb86-212">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>

[<span data-ttu-id="cdb86-213">Direttive #Region in corpi di metodo</span><span class="sxs-lookup"><span data-stu-id="cdb86-213">#Region directives inside method bodies</span></span>](../../visual-basic/language-reference/directives/region-directive.md)

<span data-ttu-id="cdb86-214">È possibile inserire delimitatori #Region...#End Region in qualsiasi punto di un file, nelle funzioni o nei corpi delle funzioni.</span><span class="sxs-lookup"><span data-stu-id="cdb86-214">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>

[<span data-ttu-id="cdb86-215">Le definizioni Overrides sono overload impliciti</span><span class="sxs-lookup"><span data-stu-id="cdb86-215">Overrides definitions are implicitly overloads</span></span>](../../visual-basic/language-reference/modifiers/overrides.md)

<span data-ttu-id="cdb86-216">Se si aggiunge il modificatore `Overrides` a una definizione, il compilatore aggiunge in modo implicito `Overloads`. In questo modo è possibile digitare meno codice nella maggior parte dei casi.</span><span class="sxs-lookup"><span data-stu-id="cdb86-216">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>

<span data-ttu-id="cdb86-217">**CObj consentito negli argomenti degli attributi**</span><span class="sxs-lookup"><span data-stu-id="cdb86-217">**CObj allowed in attributes arguments**</span></span>

<span data-ttu-id="cdb86-218">Il compilatore generava un errore indicante che CObj(...), se usato nelle costruzioni degli attributi, non era una costante.</span><span class="sxs-lookup"><span data-stu-id="cdb86-218">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>

<span data-ttu-id="cdb86-219">**Dichiarazione e utilizzo di metodi ambigui da interfacce diverse**</span><span class="sxs-lookup"><span data-stu-id="cdb86-219">**Declaring and consuming ambiguous methods from different interfaces**</span></span>

<span data-ttu-id="cdb86-220">In precedenza il codice seguente restituiva errori che impedivano di dichiarare `IMock` o di chiamare `GetDetails` (se questi erano stati dichiarati in c#):</span><span class="sxs-lookup"><span data-stu-id="cdb86-220">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>

```vb
Interface ICustomer
  Sub GetDetails(x As Integer)
End Interface

Interface ITime
  Sub GetDetails(x As String)
End Interface

Interface IMock : Inherits ICustomer, ITime
  Overloads Sub GetDetails(x As Char)
End Interface

Interface IMock2 : Inherits ICustomer, ITime
End Interface
```

<span data-ttu-id="cdb86-221">Ora il compilatore userà le normali regole di risoluzione dell'overload per scegliere l'oggetto `GetDetails` più appropriato da chiamare ed è possibile dichiarare le relazioni tre le interfacce in Visual Basic, come quelle mostrate nell'esempio.</span><span class="sxs-lookup"><span data-stu-id="cdb86-221">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>

## <a name="see-also"></a><span data-ttu-id="cdb86-222">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="cdb86-222">See also</span></span>

- [<span data-ttu-id="cdb86-223">Novità di Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="cdb86-223">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-in-visual-studio)
