---
title: Sovranità dei dati per microservizio
description: La sovranità dei dati per microservizio è uno dei punti chiave dei microservizi. Ogni microservizio deve essere l'unico proprietario del proprio database, che non viene condiviso con nessun altro. Naturalmente, tutte le istanze di un microservizio si connettono allo stesso database a disponibilità elevata.
ms.date: 09/20/2018
ms.openlocfilehash: cd7be23800394b231e15bdc503d15a960a25a20a
ms.sourcegitcommit: 29a9b29d8b7d07b9c59d46628da754a8bff57fa4
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 08/17/2019
ms.locfileid: "69566208"
---
# <a name="data-sovereignty-per-microservice"></a><span data-ttu-id="ad241-105">Sovranità dei dati per microservizio</span><span class="sxs-lookup"><span data-stu-id="ad241-105">Data sovereignty per microservice</span></span>

<span data-ttu-id="ad241-106">Una regola importate per l'architettura dei microservizi prevede che ogni microservizio sia proprietario dei rispettivi dati di dominio e della rispettiva logica.</span><span class="sxs-lookup"><span data-stu-id="ad241-106">An important rule for microservices architecture is that each microservice must own its domain data and logic.</span></span> <span data-ttu-id="ad241-107">Analogamente a un'applicazione completa che è proprietaria della rispettiva logica e dei rispettivi dati, ogni microservizio deve essere proprietario della rispettiva logica e dei rispettivi dati in un ciclo di vita autonomo, con una distribuzione indipendente per ogni microservizio.</span><span class="sxs-lookup"><span data-stu-id="ad241-107">Just as a full application owns its logic and data, so must each microservice own its logic and data under an autonomous lifecycle, with independent deployment per microservice.</span></span>

<span data-ttu-id="ad241-108">Il modello concettuale del dominio presenterà quindi differenze tra sottosistemi e microservizi.</span><span class="sxs-lookup"><span data-stu-id="ad241-108">This means that the conceptual model of the domain will differ between subsystems or microservices.</span></span> <span data-ttu-id="ad241-109">È possibile prendere in considerazione le applicazioni aziendali, in cui le applicazioni CRM (Customer Relationship Management), i sottosistemi di acquisto transazionale e i sottosistemi di supporto clienti chiamano attributi e dati univoci dell'entità cliente e in cui ogni applicazione usa un contesto delimitato.</span><span class="sxs-lookup"><span data-stu-id="ad241-109">Consider enterprise applications, where customer relationship management (CRM) applications, transactional purchase subsystems, and customer support subsystems each call on unique customer entity attributes and data, and where each employs a different Bounded Context (BC).</span></span>

<span data-ttu-id="ad241-110">Questo principio è simile nella [progettazione basata su domini (DDD, Domain-Driven Design)](https://en.wikipedia.org/wiki/Domain-driven_design), in cui ogni [contesto delimitato](https://martinfowler.com/bliki/BoundedContext.html) o sottosistema autonomo o servizio deve essere proprietario del proprio modello di dominio (dati più logica e comportamento).</span><span class="sxs-lookup"><span data-stu-id="ad241-110">This principle is similar in [Domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design), where each [Bounded Context](https://martinfowler.com/bliki/BoundedContext.html) or autonomous subsystem or service must own its domain model (data plus logic and behavior).</span></span> <span data-ttu-id="ad241-111">Ogni contesto delimitato DDD è correlato a un microservizio aziendale (uno o più servizi).</span><span class="sxs-lookup"><span data-stu-id="ad241-111">Each DDD Bounded Context correlates to one business microservice (one or several services).</span></span> <span data-ttu-id="ad241-112">Il concetto relativo al criterio Bounded Context verrà illustrato in maggiore dettaglio nella sezione successiva.</span><span class="sxs-lookup"><span data-stu-id="ad241-112">This point about the Bounded Context pattern is expanded in the next section.</span></span>

<span data-ttu-id="ad241-113">L'approccio tradizionale (dati monolitici) usato in molte applicazioni prevede tuttavia un singolo database centralizzato o qualche database.</span><span class="sxs-lookup"><span data-stu-id="ad241-113">On the other hand, the traditional (monolithic data) approach used in many applications is to have a single centralized database or just a few databases.</span></span> <span data-ttu-id="ad241-114">Si tratta spesso di un database SQL normalizzato, usato per l'intera applicazione e per tutti i rispettivi sottosistemi interni, come mostrato nella figura 4-7.</span><span class="sxs-lookup"><span data-stu-id="ad241-114">This is often a normalized SQL database that's used for the whole application and all its internal subsystems, as shown in Figure 4-7.</span></span>

![Nell'approccio tradizionale, è presente un database singolo condiviso tra tutti i servizi, in genere in un'architettura a più livelli.](./media/image7.png)

<span data-ttu-id="ad241-117">**Figura 4-7**.</span><span class="sxs-lookup"><span data-stu-id="ad241-117">**Figure 4-7**.</span></span> <span data-ttu-id="ad241-118">Confronto relativo alla sovranità dei dati: database monolitico e microservizi</span><span class="sxs-lookup"><span data-stu-id="ad241-118">Data sovereignty comparison: monolithic database versus microservices</span></span>

<span data-ttu-id="ad241-119">L'approccio basato sul database centralizzato risulta apparentemente più semplice e sembra consentire il riutilizzo delle entità nei diversi sottosistemi per assicurare la coerenza complessiva.</span><span class="sxs-lookup"><span data-stu-id="ad241-119">The centralized database approach initially looks simpler and seems to enable reuse of entities in different subsystems to make everything consistent.</span></span> <span data-ttu-id="ad241-120">In realtà si ottengono tuttavia tabelle di grandi dimensioni che gestiscono molti sottosistemi diversi e che includono attributi e colonne che risultano nella maggior parte dei casi superflui.</span><span class="sxs-lookup"><span data-stu-id="ad241-120">But the reality is you end up with huge tables that serve many different subsystems, and that include attributes and columns that aren't needed in most cases.</span></span> <span data-ttu-id="ad241-121">Questo approccio è paragonabile all'uso della stessa mappa fisica per una breve passeggiata, per una gita di un giorno in auto e per l'apprendimento della geografia.</span><span class="sxs-lookup"><span data-stu-id="ad241-121">It's like trying to use the same physical map for hiking a short trail, taking a day-long car trip, and learning geography.</span></span>

<span data-ttu-id="ad241-122">Un'applicazione monolitica con in genere un singolo database relazionale offre due vantaggi importanti: le [transazioni ACID](https://en.wikipedia.org/wiki/ACID) e il linguaggio SQL, che possono essere usati in tutte le tabelle e in tutti i dati correlati all'applicazione.</span><span class="sxs-lookup"><span data-stu-id="ad241-122">A monolithic application with typically a single relational database has two important benefits: [ACID transactions](https://en.wikipedia.org/wiki/ACID) and the SQL language, both working across all the tables and data related to your application.</span></span> <span data-ttu-id="ad241-123">Questo approccio consente di scrivere con facilità una query che combina dati da più tabelle.</span><span class="sxs-lookup"><span data-stu-id="ad241-123">This approach provides a way to easily write a query that combines data from multiple tables.</span></span>

<span data-ttu-id="ad241-124">L'accesso ai dati risulta tuttavia più complesso quando si passa a un'architettura di microservizi.</span><span class="sxs-lookup"><span data-stu-id="ad241-124">However, data access becomes much more complex when you move to a microservices architecture.</span></span> <span data-ttu-id="ad241-125">Anche nel caso in cui sia possibile o necessario usare le transazioni ACID entro un microservizio o un contesto delimitato, i dati di proprietà di ogni microservizio sono privati per il microservizio specifico ed è possibile accedervi solo tramite la rispettiva API di microservizio.</span><span class="sxs-lookup"><span data-stu-id="ad241-125">But even when ACID transactions can or should be used within a microservice or Bounded Context, the data owned by each microservice is private to that microservice and can only be accessed via its microservice API.</span></span> <span data-ttu-id="ad241-126">L'incapsulamento dei dati assicura che i microservizi siano a regime di controllo libero e possano evolversi in modo indipendente.</span><span class="sxs-lookup"><span data-stu-id="ad241-126">Encapsulating the data ensures that the microservices are loosely coupled and can evolve independently of one another.</span></span> <span data-ttu-id="ad241-127">Se più servizi accedono agli stessi dati, gli aggiornamenti dello schema richiederebbero aggiornamenti coordinati per tutti i servizi.</span><span class="sxs-lookup"><span data-stu-id="ad241-127">If multiple services were accessing the same data, schema updates would require coordinated updates to all the services.</span></span> <span data-ttu-id="ad241-128">Ciò comprometterebbe l'autonomia del ciclo di vita dei microservizi.</span><span class="sxs-lookup"><span data-stu-id="ad241-128">This would break the microservice lifecycle autonomy.</span></span> <span data-ttu-id="ad241-129">Le strutture di dati distribuite tuttavia non consentono di eseguire alcuna transazione ACID tra microservizi.</span><span class="sxs-lookup"><span data-stu-id="ad241-129">But distributed data structures mean that you can't make a single ACID transaction across microservices.</span></span> <span data-ttu-id="ad241-130">È quindi necessario usare la coerenza finale quando un processo aziendale interessa più microservizi.</span><span class="sxs-lookup"><span data-stu-id="ad241-130">This in turn means you must use eventual consistency when a business process spans multiple microservices.</span></span> <span data-ttu-id="ad241-131">Ciò è molto più difficile da implementare rispetto ai semplici join SQL, perché non è possibile creare vincoli di integrità o usare le transazioni distribuite tra database distinti, come verrà spiegato in un secondo momento.</span><span class="sxs-lookup"><span data-stu-id="ad241-131">This is much harder to implement than simple SQL joins, because you can't create integrity constraints or use distributed transactions between separate databases, as we'll explain later on.</span></span> <span data-ttu-id="ad241-132">Analogamente, molte altre funzionalità di database relazionali non sono disponibili tra più microservizi.</span><span class="sxs-lookup"><span data-stu-id="ad241-132">Similarly, many other relational database features aren't available across multiple microservices.</span></span>

<span data-ttu-id="ad241-133">I diversi microservizi inoltre usano spesso diversi *tipi* di database.</span><span class="sxs-lookup"><span data-stu-id="ad241-133">Going even further, different microservices often use different *kinds* of databases.</span></span> <span data-ttu-id="ad241-134">Le applicazioni moderne archiviano ed elaborano diversi tipi di dati e un database relazionale non è sempre la scelta ottimale.</span><span class="sxs-lookup"><span data-stu-id="ad241-134">Modern applications store and process diverse kinds of data, and a relational database isn't always the best choice.</span></span> <span data-ttu-id="ad241-135">Per alcuni casi d'uso è possibile che un database NoSQL, ad esempio Azure CosmosDB o MongoDB, offra un modello di dati più appropriato e prestazioni e scalabilità migliori rispetto a un database SQL come SQL Server o il database SQL di Azure.</span><span class="sxs-lookup"><span data-stu-id="ad241-135">For some use cases, a NoSQL database such as Azure CosmosDB or MongoDB might have a more convenient data model and offer better performance and scalability than a SQL database like SQL Server or Azure SQL Database.</span></span> <span data-ttu-id="ad241-136">In altri casi un database relazionale è comunque l'approccio migliore.</span><span class="sxs-lookup"><span data-stu-id="ad241-136">In other cases, a relational database is still the best approach.</span></span> <span data-ttu-id="ad241-137">Le applicazioni basate su microservizi usano quindi spesso una combinazione di database SQL e NoSQL. Questo approccio viene a volte definito [persistenza poliglotta](https://martinfowler.com/bliki/PolyglotPersistence.html).</span><span class="sxs-lookup"><span data-stu-id="ad241-137">Therefore, microservices-based applications often use a mixture of SQL and NoSQL databases, which is sometimes called the [polyglot persistence](https://martinfowler.com/bliki/PolyglotPersistence.html) approach.</span></span>

<span data-ttu-id="ad241-138">Un'architettura partizionata, con persistenza poliglotta per l'archiviazione dei dati presenta molti vantaggi,</span><span class="sxs-lookup"><span data-stu-id="ad241-138">A partitioned, polyglot-persistent architecture for data storage has many benefits.</span></span> <span data-ttu-id="ad241-139">tra cui servizi a regime di controllo libero e prestazioni, scalabilità, costi e gestibilità migliori.</span><span class="sxs-lookup"><span data-stu-id="ad241-139">These include loosely coupled services and better performance, scalability, costs, and manageability.</span></span> <span data-ttu-id="ad241-140">Può tuttavia introdurre alcuni problemi a livello di gestione dei dati distribuiti, come illustrato in "[Identificazione dei limiti del modello di dominio](identify-microservice-domain-model-boundaries.md)" più avanti in questo capitolo.</span><span class="sxs-lookup"><span data-stu-id="ad241-140">However, it can introduce some distributed data management challenges, as explained in "[Identifying domain-model boundaries](identify-microservice-domain-model-boundaries.md)" later in this chapter.</span></span>

## <a name="the-relationship-between-microservices-and-the-bounded-context-pattern"></a><span data-ttu-id="ad241-141">Relazione tra microservizi e schema Bounded Context</span><span class="sxs-lookup"><span data-stu-id="ad241-141">The relationship between microservices and the Bounded Context pattern</span></span>

<span data-ttu-id="ad241-142">Il concetto di microservizi deriva dallo [schema Bounded Context](https://martinfowler.com/bliki/BoundedContext.html) in [DDD (Domain-Driven Design)](https://en.wikipedia.org/wiki/Domain-driven_design).</span><span class="sxs-lookup"><span data-stu-id="ad241-142">The concept of microservice derives from the [Bounded Context (BC) pattern](https://martinfowler.com/bliki/BoundedContext.html) in [domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design).</span></span> <span data-ttu-id="ad241-143">DDD gestisce modelli di grandi dimensioni suddividendoli in più contesti delimitato e fornendo informazioni esplicite sui rispettivi limiti.</span><span class="sxs-lookup"><span data-stu-id="ad241-143">DDD deals with large models by dividing them into multiple BCs and being explicit about their boundaries.</span></span> <span data-ttu-id="ad241-144">Ogni contesto delimitato deve avere il proprio modello e il proprio database. Analogamente, ogni microservizio è proprietario dei rispettivi dati correlati.</span><span class="sxs-lookup"><span data-stu-id="ad241-144">Each BC must have its own model and database; likewise, each microservice owns its related data.</span></span> <span data-ttu-id="ad241-145">Ogni contesto delimitato inoltre ha un [linguaggio comune](https://martinfowler.com/bliki/UbiquitousLanguage.html) specifico che semplifica le comunicazioni tra sviluppatori software ed esperti di dominio.</span><span class="sxs-lookup"><span data-stu-id="ad241-145">In addition, each BC usually has its own [ubiquitous language](https://martinfowler.com/bliki/UbiquitousLanguage.html) to help communication between software developers and domain experts.</span></span>

<span data-ttu-id="ad241-146">Questi termini, principalmente entità di dominio, nel linguaggio comune possono avere nomi diversi in contesti delimitati diversi, anche quando diverse entità di dominio condividono la stessa identità, ovvero l'ID univoco usato per leggere l'entità dalla risorsa di archiviazione.</span><span class="sxs-lookup"><span data-stu-id="ad241-146">Those terms (mainly domain entities) in the ubiquitous language can have different names in different Bounded Contexts, even when different domain entities share the same identity (that is, the unique ID that's used to read the entity from storage).</span></span> <span data-ttu-id="ad241-147">In un contesto delimitato di un profilo utente, ad esempio, è possibile che l'entità di dominio utente condivida l'identità con l'entità di dominio acquirente nel contesto delimitato di ordinazione.</span><span class="sxs-lookup"><span data-stu-id="ad241-147">For instance, in a user-profile Bounded Context, the User domain entity might share identity with the Buyer domain entity in the ordering Bounded Context.</span></span>

<span data-ttu-id="ad241-148">Un microservizio è quindi simile a un contesto delimitato, ma specifica anche che si tratta di un servizio distribuito.</span><span class="sxs-lookup"><span data-stu-id="ad241-148">A microservice is therefore like a Bounded Context, but it also specifies that it's a distributed service.</span></span> <span data-ttu-id="ad241-149">È basato su un processo separato per ogni contesto delimitato e deve usare i protocolli distribuiti indicati in precedenza, ad esempio HTTP/HTTPS, WebSockets o [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span><span class="sxs-lookup"><span data-stu-id="ad241-149">It's built as a separate process for each Bounded Context, and it must use the distributed protocols noted earlier, like HTTP/HTTPS, WebSockets, or [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span></span> <span data-ttu-id="ad241-150">Lo schema Bounded Context, tuttavia, non specifica se il contesto delimitato è un servizio distribuito o se si tratta semplicemente di un limite logico, ad esempio un sottosistema generico, entro un'applicazione con distribuzione monolitica.</span><span class="sxs-lookup"><span data-stu-id="ad241-150">The Bounded Context pattern, however, doesn't specify whether the Bounded Context is a distributed service or if it's simply a logical boundary (such as a generic subsystem) within a monolithic-deployment application.</span></span>

<span data-ttu-id="ad241-151">È importante evidenziare che la definizione di un servizio per ogni contesto delimitato è un buon punto di partenza.</span><span class="sxs-lookup"><span data-stu-id="ad241-151">It's important to highlight that defining a service for each Bounded Context is a good place to start.</span></span> <span data-ttu-id="ad241-152">Non è tuttavia necessario limitare la progettazione a questo aspetto.</span><span class="sxs-lookup"><span data-stu-id="ad241-152">But you don't have to constrain your design to it.</span></span> <span data-ttu-id="ad241-153">In alcuni casi è necessario progettare un contesto delimitato o un microservizio aziendale costituito da diversi servizi fisici.</span><span class="sxs-lookup"><span data-stu-id="ad241-153">Sometimes you must design a Bounded Context or business microservice composed of several physical services.</span></span> <span data-ttu-id="ad241-154">Entrambi gli schemi, ovvero Bounded Context e il microservizio, sono tuttavia essenzialmente strettamente correlati.</span><span class="sxs-lookup"><span data-stu-id="ad241-154">But ultimately, both patterns -Bounded Context and microservice- are closely related.</span></span>

<span data-ttu-id="ad241-155">I microservizi risultano vantaggiosi per DDD perché forniscono limiti reali sotto forma di microservizi distribuiti.</span><span class="sxs-lookup"><span data-stu-id="ad241-155">DDD benefits from microservices by getting real boundaries in the form of distributed microservices.</span></span> <span data-ttu-id="ad241-156">In un contesto con limiti tuttavia è consigliabile non condividere il modello tra microservizi.</span><span class="sxs-lookup"><span data-stu-id="ad241-156">But ideas like not sharing the model between microservices are what you also want in a Bounded Context.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="ad241-157">Risorse aggiuntive</span><span class="sxs-lookup"><span data-stu-id="ad241-157">Additional resources</span></span>

- <span data-ttu-id="ad241-158">**Chris Richardson. Criterio:  database per servizio** </span><span class="sxs-lookup"><span data-stu-id="ad241-158">**Chris Richardson. Pattern: Database per service** </span></span>\
  <https://microservices.io/patterns/data/database-per-service.html>

- <span data-ttu-id="ad241-159">**Martin Fowler. BoundedContext** </span><span class="sxs-lookup"><span data-stu-id="ad241-159">**Martin Fowler. BoundedContext** </span></span>\
  <https://martinfowler.com/bliki/BoundedContext.html>

- <span data-ttu-id="ad241-160">**Martin Fowler. PolyglotPersistence** </span><span class="sxs-lookup"><span data-stu-id="ad241-160">**Martin Fowler. PolyglotPersistence** </span></span>\
  <https://martinfowler.com/bliki/PolyglotPersistence.html>

- <span data-ttu-id="ad241-161">**Alberto Brandolini. Progettazione orientata al dominio strategico con il Mapping del contesto** </span><span class="sxs-lookup"><span data-stu-id="ad241-161">**Alberto Brandolini. Strategic Domain Driven Design with Context Mapping** </span></span>\
  <https://www.infoq.com/articles/ddd-contextmapping>

>[!div class="step-by-step"]
><span data-ttu-id="ad241-162">[Precedente](microservices-architecture.md)
>[Successivo](logical-versus-physical-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="ad241-162">[Previous](microservices-architecture.md)
[Next](logical-versus-physical-architecture.md)</span></span>
